{"componentChunkName":"component---src-templates-blog-template-js","path":"/221213-devops-linux-\bchaining-operator/","result":{"data":{"cur":{"id":"b92fbf26-e7a1-56cb-ac11-adcab732c949","html":"<h1 id=\"1-배경-상황\" style=\"position:relative;\"><a href=\"#1-%EB%B0%B0%EA%B2%BD-%EC%83%81%ED%99%A9\" aria-label=\"1 배경 상황 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 배경 상황</h1>\n<p>Node.js 프로젝트를 진행하다가 package.json에 npm 명령어를 정의해주고 있었는데, 초기에 빌드 아웃풋 폴더 내의 파일을 삭제한 뒤에 빌드를 실행하도록 명령어를 아래와 같이 지정해주었었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token string\">\"scripts\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token string\">\"init\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"rm ./bin/*\"</span>,\n    <span class=\"token string\">\"start\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"nodemon ./server.js\"</span>,\n    <span class=\"token string\">\"test\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"echo <span class=\"token entity\" title=\"\\&quot;\">\\\"</span>Error: no test specified<span class=\"token entity\" title=\"\\&quot;\">\\\"</span> &amp;&amp; exit 1\"</span>,\n    <span class=\"token string\">\"build\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"npm run init; &amp;&amp; pkg . --out-path bin\"</span>\n  <span class=\"token punctuation\">}</span>,</code></pre></div>\n<br/>\n<p>하지만 bin에 아무 파일이 없는 상태에서 실행하니 아래와 같은 에러가 발생해서 다중 명령어를 <code class=\"language-text\">&amp;&amp;</code> 에서 <code class=\"language-text\">;</code> 로 고쳐주었다(뭔가 init쪽 명령어를 고쳐주는 게 좋을 것 같은데 나중에 더 찾아보기로).</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">rm: ./bin/*: No such <span class=\"token function\">file</span> or directory</code></pre></div>\n<br/>\n<h1 id=\"2-리눅스linux-다중-명령어-차이\" style=\"position:relative;\"><a href=\"#2-%EB%A6%AC%EB%88%85%EC%8A%A4linux-%EB%8B%A4%EC%A4%91-%EB%AA%85%EB%A0%B9%EC%96%B4-%EC%B0%A8%EC%9D%B4\" aria-label=\"2 리눅스linux 다중 명령어 차이 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 리눅스(Linux) 다중 명령어 차이</h1>\n<p>리눅스 쉘에서 다중 명령어를 사용하면 하나의 라인에서 여러 명령어를 실행할 수 가 있는데, 다중 명령어를 실행하는 <code class=\"language-text\">;</code> , <code class=\"language-text\">&amp;&amp;</code> , <code class=\"language-text\">||</code> 세 명령어 사이에 차이가 있어 정리해두려 한다.</p>\n<ol>\n<li>\n<p>세미콜론(<code class=\"language-text\">;</code>)</p>\n<p>선행 명령어의 성공, 실패 여부와 관계 없이 모든 명령어를 실행한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ 명령1<span class=\"token punctuation\">;</span> 명령2<span class=\"token punctuation\">;</span> 명령3<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">..</span>.</code></pre></div>\n<ul>\n<li>명령 2이 실패하더라도 명령 3이후의 명령어가 실행된다.</li>\n</ul>\n</li>\n</ol>\n<br/>\n<ol start=\"2\">\n<li>\n<p>엠퍼센트(<code class=\"language-text\">&amp;&amp;</code>)</p>\n<p>앞에서부터 순차적으로 실행 되고, 선행 명령어가 <strong>실패</strong>할 경우, 뒤의 명령어를 실행하지 않는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ 명령1 <span class=\"token operator\">&amp;&amp;</span> 명령2 <span class=\"token operator\">&amp;&amp;</span> 명령3 <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">..</span>.</code></pre></div>\n<ul>\n<li>명령 2가 실패할 경우 명령 3 이후는 실행되지 않는다.</li>\n</ul>\n</li>\n</ol>\n<br/>\n<ol start=\"3\">\n<li>\n<p>더블 버티컬바(<code class=\"language-text\">||</code>)</p>\n<p>앞에서부터 명령어가 순차적으로 실행되고, 선행 명령어가 <strong>성공</strong>할 경우, 뒤의 명령어를 실행하지 않는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ 명령1 <span class=\"token operator\">||</span> 명령2 <span class=\"token operator\">||</span> 명령3 <span class=\"token operator\">||</span> <span class=\"token punctuation\">..</span>.</code></pre></div>\n<ul>\n<li>명령 2가 성공할 경우 명령 3 이후는 실행되지 않는다.</li>\n</ul>\n</li>\n</ol>\n<br/>","excerpt":"1. 배경 상황 Node.js 프로젝트를 진행하다가 package.json에 npm 명령어를 정의해주고 있었는데, 초기에 빌드 아웃풋 폴더 내의 파일을 삭제한 뒤에 빌드를 실행하도록 명령어를 아래와 같이 지정해주었었다. 하지만 bin에 아무 파일이 없는 상태에서 실행하니 아래와 같은 에러가 발생해서 다중 명령어를  에서  로 고쳐주었다(뭔가 init쪽 명령어를 고쳐주는 게 좋을 것 같은데 나중에 더 찾아보기로). 2. 리눅스(Linux) 다중 명령어 차이 리눅스 쉘에서 다중 명령어를 사용하면 하나의 라인에서 여러 명령어를 실행할 수 가 있는데, 다중 명령어를 실행하는  ,  ,  세 명령어 사이에 차이가 있어 정리해두려 한다. 세미콜론() 선행 명령어의 성공, 실패 여부와 관계 없이 모든 명령어를 실행한다. 명령 2이 실패하더라도 명령 3이후의 명령어가 실행된다. 엠퍼센트() 앞에서부터 순차적으로 실행 되고, 선행 명령어가 실패할 경우, 뒤의 명령어를 실행하지 않는다. 명령 2가 …","frontmatter":{"date":"December 13, 2022","title":"리눅스(Linux) 다중 명령어(;, &&, ||)","categories":"devops","author":"jinnypark9393","emoji":"💫"},"fields":{"slug":"/221213-devops-linux-\bchaining-operator/"}},"next":{"id":"a724a556-6b02-5c8b-ba85-4543b0520906","html":"<p>MacOS에서는 기본적으로 ⌘ + ⇧ + 4 등의 단축키를 이용해 캡처를 할 수 있지만, 스크롤이 있는 페이지의 경우에는 전체 스크롤을 캡처하기가 어렵다.</p>\n<br/>\n<p>하지만 캡처 대상이 Chrome 브라우저일 경우에는 Chrome 브라우저에서 제공하는 스크린 샷 기능을 활용해 웹사이트의 전체 스크롤 혹은 특정 컴포넌트를 캡처할 수 있다.</p>\n<ol>\n<li>해당하는 웹페이지로 이동 후 F12키를 누르거나,  해당 웹페이지 빈 곳 우클릭 후 검사(Inspect) 클릭( ⌥+⌘+I)</li>\n<li>개발자 도구가 열리면 Console 탭으로 이동한 뒤, ⌘ + ⇧ + P 단축키를 눌러 명령 메뉴를 연다. 명령 메뉴에 screenshot을 검색해서 <code class=\"language-text\">Capture full size screenshot</code>을 클릭하면 PNG파일로 저장된다.</li>\n</ol>\n<br/>\n<p>웹페이지의 특정 컴포넌트만 캡처하고 싶은 경우,</p>\n<ol>\n<li>해당하는 웹페이지로 이동 후 F12키를 누르거나,  해당 웹페이지 빈 곳 우클릭 후 검사(Inspect) 클릭( ⌥+⌘+I)</li>\n<li>Element 탭에서 캡처를 원하는 태그를 우클릭 후 <code class=\"language-text\">Capture node screenshot</code> 을 클릭하면 PNG파일로 저장된다.</li>\n</ol>\n<br/>","frontmatter":{"date":"December 12, 2022","title":"Chrome 브라우저 창 전체 스크롤/특정 컴포넌트만 스크린샷하기(크롬 개발자도구 활용)","categories":"etc","author":"jinnypark9393","emoji":"💫"},"fields":{"slug":"/221212-etc-chrome-screenshot/"}},"prev":{"id":"d4dede07-a475-50c0-bf8f-c4899a733c19","html":"<h1 id=\"1-배경-상황\" style=\"position:relative;\"><a href=\"#1-%EB%B0%B0%EA%B2%BD-%EC%83%81%ED%99%A9\" aria-label=\"1 배경 상황 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 배경 상황</h1>\n<p>node.js(Express.js)프로젝트의 EKS 배포를 위한 CodePipeline CI/CD 구성 중 노드 프로젝트를 불러와서 npm install로 패키지를 설치하는 도중 다음과 같은 경고 메시지가 발생했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">npm</span> WARN read-shrinkwrap This version of <span class=\"token function\">npm</span> is compatible with lockfileVersion@1, but package-lock.json was generated <span class=\"token keyword\">for</span> lockfileVersion@2. I'll try to <span class=\"token keyword\">do</span> my best with it<span class=\"token operator\">!</span>\nEEXIST: <span class=\"token function\">file</span> already exists</code></pre></div>\n<br/>\n<h1 id=\"2-해결-방법\" style=\"position:relative;\"><a href=\"#2-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95\" aria-label=\"2 해결 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 해결 방법</h1>\n<p>여기서 중요한 메시지는 <code class=\"language-text\">EEXIST: file already exists</code> 라는 메시지. package-lock.json 파일 및 node_modules가 기존에 이미 존재하고 있기 때문에 npm install로 새로운 모듈을 받지 못한다는 메시지였는데, 로컬이었다면 수작업으로 <code class=\"language-text\">package-lock.json</code>파일과 <code class=\"language-text\">node_modules</code> 라는 디렉터리를 삭제해줄 수도 있었겠지만, CodeBuild상에서 삭제하는 과정이 필요했기 때문에 아래와 같이 package.json 파일에서 해당 파일들을 삭제해주는 <code class=\"language-text\">\"clean\"</code>  scripts를 추가해주고,</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token string\">\"scripts\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token string\">\"clean\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"rm package-lock.json; rm -rf node_modules\"</span>,\n    <span class=\"token string\">\"init\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"rm ./bin/*\"</span>,\n    <span class=\"token string\">\"start\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"nodemon ./server.js\"</span>,\n    <span class=\"token string\">\"test\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"echo <span class=\"token entity\" title=\"\\&quot;\">\\\"</span>Error: no test specified<span class=\"token entity\" title=\"\\&quot;\">\\\"</span> &amp;&amp; exit 1\"</span>,\n    <span class=\"token string\">\"build\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"npm run init; pkg . --out-path bin\"</span>\n  <span class=\"token punctuation\">}</span>,</code></pre></div>\n<p>CodeBuild위에서 실행할 명령어들을 정의하는 buildspec.yaml 파일에 <code class=\"language-text\">npm run clean</code> 커맨드를 추가했더니 위와 같은 에러가 해결되었다.</p>\n<br/>","frontmatter":{"date":"December 14, 2022","title":"AWS CodeBuild “EEXIST: file already exists” 에러 해결","categories":"클라우드","author":"jinnypark9393","emoji":"💫"},"fields":{"slug":"/221214-aws-codebuild-file-already-exist/"}},"site":{"siteMetadata":{"siteUrl":"https://jinnypark9393.github.io","comments":{"utterances":{"repo":"jinnypark9393/jinnypark9393.github.io"}}}}},"pageContext":{"slug":"/221213-devops-linux-\bchaining-operator/","nextSlug":"/221212-etc-chrome-screenshot/","prevSlug":"/221214-aws-codebuild-file-already-exist/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}