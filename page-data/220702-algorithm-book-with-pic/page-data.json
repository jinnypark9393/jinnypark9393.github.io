{"componentChunkName":"component---src-templates-blog-template-js","path":"/220702-algorithm-book-with-pic/","result":{"data":{"cur":{"id":"ba9bfb49-a752-5391-b236-9cd1ef1de1b3","html":"<h1 id=\"algorithm그림으로-배우는-알고리즘-제-3장-자료구조-5\" style=\"position:relative;\"><a href=\"#algorithm%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%A0%9C-3%EC%9E%A5-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-5\" aria-label=\"algorithm그림으로 배우는 알고리즘 제 3장 자료구조 5 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[Algorithm]그림으로 배우는 알고리즘 제 3장: 자료구조 (5)</h1>\n<h1 id=\"1-그림으로-배우는-알고리즘-제-3장-자료구조-5\" style=\"position:relative;\"><a href=\"#1-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%A0%9C-3%EC%9E%A5-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-5\" aria-label=\"1 그림으로 배우는 알고리즘 제 3장 자료구조 5 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 그림으로 배우는 알고리즘 제 3장: 자료구조 (5)</h1>\n<h2 id=\"31-마지막-요소까지-이동하면-1번째-요소로-되돌아오는-링-버퍼\" style=\"position:relative;\"><a href=\"#31-%EB%A7%88%EC%A7%80%EB%A7%89-%EC%9A%94%EC%86%8C%EA%B9%8C%EC%A7%80-%EC%9D%B4%EB%8F%99%ED%95%98%EB%A9%B4-1%EB%B2%88%EC%A7%B8-%EC%9A%94%EC%86%8C%EB%A1%9C-%EB%90%98%EB%8F%8C%EC%95%84%EC%98%A4%EB%8A%94-%EB%A7%81-%EB%B2%84%ED%8D%BC\" aria-label=\"31 마지막 요소까지 이동하면 1번째 요소로 되돌아오는 링 버퍼 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>31. 마지막 요소까지 이동하면 1번째 요소로 되돌아오는 링 버퍼</h2>\n<ul>\n<li>1차원 배열의 요소들ㅇ르 처음부터 마지막까지 순서대로 조회하려면 배열 요소를 조회할 때 첨자를 1씩 더해나가면 된다.</li>\n<li><strong>링 버퍼</strong>: 1차원 배열의 1번째 요소와 마지막 요소를 합쳐 배열 마지막 요소의 다음에도 요소가 존재한다고 만드는 자료구조\n<ul>\n<li>예 요소가 10개인 BUFFER라는 1차원 배열 ⇒ BUFFER[9]의 다음 요소를 BUFFER[0]으로 설정</li>\n</ul>\n</li>\n</ul>\n<br/>\n<h2 id=\"32-부모-하나에-자식-둘이-딸린-구조는-이진트리\" style=\"position:relative;\"><a href=\"#32-%EB%B6%80%EB%AA%A8-%ED%95%98%EB%82%98%EC%97%90-%EC%9E%90%EC%8B%9D-%EB%91%98%EC%9D%B4-%EB%94%B8%EB%A6%B0-%EA%B5%AC%EC%A1%B0%EB%8A%94-%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC\" aria-label=\"32 부모 하나에 자식 둘이 딸린 구조는 이진트리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>32. 부모 하나에 자식 둘이 딸린 구조는 이진트리</h2>\n<ul>\n<li><strong>이진트리</strong>: 다음 요소를 가리키는 포인터를 2개 가진 단방향 리스트</li>\n<li><strong>노드</strong>: 이진트리의 구성요소\n<ul>\n<li>부모 노드: 자식 노드를 2개 이상 가질 수 없다.</li>\n<li>자식 노드: 하위에 자식노드가 있을 경우 부모노드가 된다.</li>\n<li>뿌리/루트 노드: 부모노드가 없는 노드</li>\n<li>잎/리프 노드: 자식 노드가 없는 노드</li>\n<li>깊이: 뿌리에서 특정 노드로 도달하기까지 경로의 길이(루트 노드 = 0 기준)</li>\n</ul>\n</li>\n</ul>\n<p><br/><br/></p>","excerpt":"[Algorithm]그림으로 배우는 알고리즘 제 3장: 자료구조 (5) 1. 그림으로 배우는 알고리즘 제 3장: 자료구조 (5) 31. 마지막 요소까지 이동하면 1번째 요소로 되돌아오는 링 버퍼 1차원 배열의 요소들ㅇ르 처음부터 마지막까지 순서대로 조회하려면 배열 요소를 조회할 때 첨자를 1씩 더해나가면 된다. 링 버퍼: 1차원 배열의 1번째 요소와 마지막 요소를 합쳐 배열 마지막 요소의 다음에도 요소가 존재한다고 만드는 자료구조 예 요소가 10개인 BUFFER라는 1차원 배열 ⇒ BUFFER[9]의 다음 요소를 BUFFER[0]으로 설정 32. 부모 하나에 자식 둘이 딸린 구조는 이진트리 이진트리: 다음 요소를 가리키는 포인터를 2개 가진 단방향 리스트 노드: 이진트리의 구성요소 부모 노드: 자식 노드를 2개 이상 가질 수 없다. 자식 노드: 하위에 자식노드가 있을 경우 부모노드가 된다. 뿌리/루트 노드: 부모노드가 없는 노드 잎/리프 노드: 자식 노드가 없는 노드 깊이: 뿌리에…","frontmatter":{"date":"July 02, 2022","title":"그림으로 배우는 알고리즘 제3장 - 자료구조(5)","categories":"알고리즘","author":"jinnypark9393","emoji":"🤖"},"fields":{"slug":"/220702-algorithm-book-with-pic/"}},"next":{"id":"465bca39-efbc-5509-8965-09b28ece7f41","html":"<h1 id=\"1-raid란\" style=\"position:relative;\"><a href=\"#1-raid%EB%9E%80\" aria-label=\"1 raid란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. RAID란?</h1>\n<ul>\n<li><strong>RAID(Redundant Array of Independent Disks)</strong>: 여러 물리 디스크를 하나로 모아 논리적 유닛으로 만든 것(=하나의 논리적인 드라이브)</li>\n<li>사용하는 이유?\n<ul>\n<li>원래는 값싼 디스크 여러 개를 묶어 용량을 증가시키는 데에 사용</li>\n<li>현재는 내고장성, 고가용성, 성능, 또는 이 세 가지를 조합해 기업 내 데이터가 손실되지 않도록 하는 데에 사용</li>\n</ul>\n</li>\n</ul>\n<p><br/><br/></p>\n<h1 id=\"2-raid의-종류\" style=\"position:relative;\"><a href=\"#2-raid%EC%9D%98-%EC%A2%85%EB%A5%98\" aria-label=\"2 raid의 종류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. RAID의 종류</h1>\n<p>RAID의 구성 방식은 RAID 0, 1, 01, 2, 3, 4, 5 등 다수 존재하나 가장 많이 사용하는 구성 방식은 아래 다섯 가지이다.</p>\n<br/>\n<h2 id=\"1-raid-0-stripping\" style=\"position:relative;\"><a href=\"#1-raid-0-stripping\" aria-label=\"1 raid 0 stripping permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. RAID 0 (Stripping)</h2>\n<ul>\n<li>데이터를 두 개 이상의 디스크에 동일하게 분할해 저장</li>\n<li>각 디스크 용량의 합만큼 전체로 용량을 사용 가능</li>\n<li>장애 발생 시 해당 부분의 디스크 복구 불가 ⇒ 기업 사용에 권장하지 않음</li>\n</ul>\n<br/>\n<h2 id=\"2-raid-1-mirroring\" style=\"position:relative;\"><a href=\"#2-raid-1-mirroring\" aria-label=\"2 raid 1 mirroring permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. RAID 1 (Mirroring)</h2>\n<ul>\n<li>데이터를 2개 디스크에 동시 저장하는 방식이다.</li>\n<li>성능이 느린 편이다.</li>\n<li>가용성 측면에서 안정적으로 데이터 장애 방지 위해 구성된다.</li>\n<li>서버에 OS를 설치하게 될 경우 활용하는 방식이다(OS 설치 디스크를 보호하기 위한 목적).</li>\n</ul>\n<br/>\n<h2 id=\"3-raid-1--0\" style=\"position:relative;\"><a href=\"#3-raid-1--0\" aria-label=\"3 raid 1  0 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. RAID 1 + 0</h2>\n<ul>\n<li>RAID 0과 RAID 1의 장점을 결합한 방식이다.</li>\n<li>RAID 1로 미러링한 뒤 스트라이프 하는 방식</li>\n<li>많은 디스크가 소요된다.</li>\n<li>안정적이며 성능 저하가 일어나지 않아 기업형 스토리지에서 구성하는 방식이다.</li>\n</ul>\n<br/>\n<h2 id=\"4-raid-5-parity\" style=\"position:relative;\"><a href=\"#4-raid-5-parity\" aria-label=\"4 raid 5 parity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. RAID 5 (Parity)</h2>\n<ul>\n<li>3개 이상의 디스크로 구성, 디스크 1개 결함까지 보장한다.</li>\n<li>데이터를 RAID 0 방식으로 저장하나 중간에 parity 형태의 데이터를 동시에 저장한다.</li>\n<li>장애 발생 시 나머지 디스크들에서 정보를 얻어 복구해 데이터 가용성을 향상한다.</li>\n</ul>\n<br/>\n<h2 id=\"5-raid-6-double-parity\" style=\"position:relative;\"><a href=\"#5-raid-6-double-parity\" aria-label=\"5 raid 6 double parity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. RAID 6 (Double Parity)</h2>\n<ul>\n<li>디스크 2개 장애까지 보장하는 구성 방식이다.</li>\n<li>가용 용량은 RAID5 보다 감소한다.</li>\n<li>기업에서 많이 구축하는 형태이다.</li>\n</ul>\n<p><br/><br/></p>","frontmatter":{"date":"July 01, 2022","title":"RAID란? (정의 및 종류)","categories":"CS","author":"jinnypark9393","emoji":"💫"},"fields":{"slug":"/220701-cs-storage-raid/"}},"prev":{"id":"f99d9ef3-8995-5c9f-b589-2d4943ccf990","html":"<h1 id=\"1-그림으로-배우는-알고리즘-제-3장-자료구조-6\" style=\"position:relative;\"><a href=\"#1-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%A0%9C-3%EC%9E%A5-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-6\" aria-label=\"1 그림으로 배우는 알고리즘 제 3장 자료구조 6 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 그림으로 배우는 알고리즘 제 3장: 자료구조 (6)</h1>\n<h2 id=\"33-부모-노드의-값이-자식-노드의-값보다-항상-적은-이진-트리는-힙heap\" style=\"position:relative;\"><a href=\"#33-%EB%B6%80%EB%AA%A8-%EB%85%B8%EB%93%9C%EC%9D%98-%EA%B0%92%EC%9D%B4-%EC%9E%90%EC%8B%9D-%EB%85%B8%EB%93%9C%EC%9D%98-%EA%B0%92%EB%B3%B4%EB%8B%A4-%ED%95%AD%EC%83%81-%EC%A0%81%EC%9D%80-%EC%9D%B4%EC%A7%84-%ED%8A%B8%EB%A6%AC%EB%8A%94-%ED%9E%99heap\" aria-label=\"33 부모 노드의 값이 자식 노드의 값보다 항상 적은 이진 트리는 힙heap permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>33. 부모 노드의 값이 자식 노드의 값보다 항상 적은 이진 트리는 힙(Heap)</h2>\n<ul>\n<li><strong>힙(Heap)</strong>: 각 노드의 값이 다음 조건을 충족하도록 관리되는 이진트리\n<ul>\n<li>부모 노드의 값은 <strong>항상 하위 노드 값보다 작다</strong>(또는 부모 노드의 값은 <strong>항상 하위 노드 값보다 크다</strong>)</li>\n<li>첫번째 경우 자식 노드의 값은 둘 중 어느쪽이 크더라도 상관 없음.</li>\n<li>위 조건에 따라 관리되는 힙은 뿌리 부분에 모든 값 중 가장 작은 값(또는 가장 큰 값)이 배치됨.</li>\n<li><strong>최소 값(또는 최대 값)을 효율적으로 구하는 용도에 적합.</strong></li>\n</ul>\n</li>\n<li>힙을 구현할 때 일반적으로 <strong>배열</strong>을 사용.\n<ul>\n<li>배열 요소 번호 1번 = 힙의 뿌리요소.</li>\n<li>깊이가 작은 쪽 → 큰 쪽</li>\n<li>노드의 왼쪽 → 오른쪽</li>\n</ul>\n</li>\n</ul>\n<p><br/><br/></p>\n<h2 id=\"34-해시-테이블은-배열과-리스트를-조합한-자료-구조\" style=\"position:relative;\"><a href=\"#34-%ED%95%B4%EC%8B%9C-%ED%85%8C%EC%9D%B4%EB%B8%94%EC%9D%80-%EB%B0%B0%EC%97%B4%EA%B3%BC-%EB%A6%AC%EC%8A%A4%ED%8A%B8%EB%A5%BC-%EC%A1%B0%ED%95%A9%ED%95%9C-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0\" aria-label=\"34 해시 테이블은 배열과 리스트를 조합한 자료 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>34. 해시 테이블은 배열과 리스트를 조합한 자료 구조</h2>\n<ul>\n<li>\n<p><strong>해시 테이블(Hash Table)</strong>: 아래 2개 자료구조가 조합된 것</p>\n<ul>\n<li>N개의 요소를 가진 <strong>루트 배열</strong>이라는 이름의  배열</li>\n<li>루트 배열의 각 요소가 가리키는 <strong>리스트</strong></li>\n</ul>\n</li>\n<li>\n<p>먼저 루트 배열의 요소 번호를 구해야 한다</p>\n<ul>\n<li><strong>해시함수</strong>를 이용</li>\n<li><strong>해시 함수</strong>: 관리할 데이터를 입력받아 해당 데이터를 ‘0~(N-1)’ (N: 루트 배열의 요소 개수) 사이의 값으로 바꾸어 주는 함수.</li>\n<li><strong>해시 값</strong>: 해시 함수에 의해 구해진 값. 루트 배열의 요소 번호로 삼으면 데이터를 루트 배열의 몇 번째 요소가 가리키는 리스트에 저장해야할 지 결정할 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>해시 테이블의 경우 같은 배열 요소에 그룹화 된 데이터가 여러개 나오는 상황이 발생 ⇒ <strong>충돌</strong></p>\n</li>\n<li>\n<p>충돌을 피하려면 각 그룹이 여러 개의 데이터를 관리할 수 있도록 만들어야 하기 때문에 루트 배열의 각 요소가 리스트를 가리키도록 만들어 해시 값이 동일한 데이터를 여러 개 관리할 수 있다.</p>\n</li>\n<li>\n<p>해시 테이블이 관리하는 데이터 중 특정 데이터 찾는 방법</p>\n<ul>\n<li>해시값을 구해 데이터가 속한 그룹(리스트)을 찾는다.</li>\n<li>리스트 데이터를 순서대로 검색한다.</li>\n</ul>\n</li>\n</ul>\n<p><br/><br/></p>","frontmatter":{"date":"July 03, 2022","title":"그림으로 배우는 알고리즘 제3장 - 자료구조(6)","categories":"알고리즘","author":"jinnypark9393","emoji":"🤖"},"fields":{"slug":"/220703-algorithm-book-with-pic/"}},"site":{"siteMetadata":{"siteUrl":"https://jinnypark9393.github.io","comments":{"utterances":{"repo":"jinnypark9393/jinnypark9393.github.io"}}}}},"pageContext":{"slug":"/220702-algorithm-book-with-pic/","nextSlug":"/220701-cs-storage-raid/","prevSlug":"/220703-algorithm-book-with-pic/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}