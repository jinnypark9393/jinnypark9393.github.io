var store = [{
        "title": "첫 글",
        "excerpt":"깃허브 블로그 첫 글  우여곡절 끝에 깃허브 블로그를 생성했다.   MacOS 와 Jekyll(이라기보다는 ruby 버전 호환 문제) 설치 문제 때문에 임시로 티스토리를 사용했었는데, Ubuntu 20.04 버전 환경에서 설치하니 이렇게 금방 설치 될 수가 없더라…(허무)   기존 티스토리 블로그에 있던 포스팅은 조만간 전부 이관할 예정.   이제 깃허브 블로그도 생성했겠다 1일 1커밋을 생활화 해야지.  ","categories": ["ETC"],
        "tags": ["GithubPages","깃허브페이지","깃허브블로그","개발자블로그비교"],
        "url": "/etc/my-first-post/",
        "teaser": null
      },{
        "title": "[Linux/Ubuntu]VMware Fusion에서 Ubuntu 20.04 설치하기",
        "excerpt":"   💡 MacOS 환경에서 VMware로 Ubuntu를 설치하려면 “VMware Fusion”을 설치해야 한다.        이번 포스팅에서는 VMware Fusion에서 Ubuntu 20.04 버전을 설치해보도록 하겠다. 코딩 강의를 수강하거나 스터디 할 때 실습 환경을 맞춰주기 위해서 우분투를 설치했었는데, 이번에는 Jekyll을 설치하기 위해 우분투 환경을 만들어주게 되었다.     만약 나와 같이 MacOS(Catalina 이상 버전)에서 Jekyll 설치에 실패했던 사람은 Ubuntu 20.04 버전에서 설치 해보는 걸 추천한다. (참고로 Ubuntu 18.04 버전에서는 Jekyll 설치는 가능했었으나 테마 적용에서 버전 이슈가 발생했다.)     그럼 VMware Fusion과 Ubuntu가 무엇인지에 대해 간단하게 살펴본 뒤 두 소프트웨어를 설치해보도록 하자.      1. VMware Fusion이란?   VMware Fusion은 VMware사에서 제공하는 MacOS 컴퓨터용 가상머신 소프트웨어이다. 무료버전인 VMware Fusion Player와 유료버전인 VMware Fusion Pro 두 가지 버전을 배포하고 있다.     VMware 에서는 VMware Fusion외에도 Windows 환경에서 사용할 수 있는 VMware Workstation이 있으며, VMware Workstation도 Player와 마찬가지로 Player(무료 버전), Pro(유료 버전) 두 가지 버전을 배포하고 있다.      2. 우분투(Ubuntu)란?   우분투(Ubuntu)는 데비안(Debian) GNU/리눅스를 기반으로 만들어진 운영체제로, 남아공 출신의 사업가인 Canonical의 CEO인 마크 셔틀워스(Mark Shuttleworth)에 의해 시작되었다. 우분투라는 제품명도 남아프리카의 반투어에서 따온 것으로, 사람들간의 관계와 헌신에 중점을 둔 윤리 사상, 인본주의에 기반한 아프리카의 전통적 사상이다. 우분투는 이러한 ‘우분투’ 정신을 개발 철학으로 삼고 있어 1. 소프트웨어 사용이 무료여야하고, 2. 모든 사람들의 모국어로 사용되어야하며, 3. 장애를 가진 사람도 이용할 수 있어야 한다고 한다. 또한 우분투는 오픈소스 소프트웨어로 무료로 제공되며 사람들이 자유롭게 소프트웨어를 수정할 수 있다.     뿐만 아니라 대부분의 리눅스 배포판들이 서버용으로 사용되고 있는 데 반해, 우분투는 개인 사용자나 데스크탑 환경에 최적화 되도록 개발되어 개인 컴퓨터에 리눅스 환경을 구축하고 싶을 때 매우 유용하다.      3. VMware Fusion 설치하기           구글에서 vmware fusion download 12를 검색해 맨 위의 링크로 들어간다.                       VMware Fusion Player - Personal Use License에 접속해 로그인한다(아이디가 없을 경우 Create an Account 탭을 클릭 ⇒ 빨간 박스 안에 들어간 내용을 입력해 회원가입을 진행한 뒤 로그인한다).                       패키지를 다운로드 및 설치한다(License Key가 필요한 경우 다운로드 창 위에 발급된 라이선스 키를 사용한다).                 4. Ubuntu 20.04 버전 설치하기            구글에서 “Ubuntu 20.04 download”를 검색해 우분투 공식 웹사이트 링크로 접속한다.                       다운로드를 클릭한다.                       iso 파일을 다운로드 받는다.                       VMware Fusion을 구동한 뒤, File &gt; New를 클릭한다.                       Install from disc or image에 다운로드 받은 iso파일을 드래그앤드롭 한다.                       ubuntu-20.04버전이 선택된 것을 확인 한 뒤 Continue 클릭한다.                       계정명과 비밀번호를 입력한 뒤 Continue 버튼을 클릭한다.                       내용을 확인한 뒤 Finish를 클릭한다(만일 생성되는 머신의 이름을 변경하고 싶은 경우 Customize Settings를 클릭해 이름을 변경해준다).                       설치가 완료되면 화면을 더블클릭해 활성화 한 뒤 설정한 비밀번호를 입력한 후 접속할 수 있다.            이렇게 MacOS 환경에서 VMware Fusion을 이용해 Ubuntu20.04 환경을 구성해보았다. 다음 포스팅에서는 Ubuntu 환경 위에서 Jekyll을 설치한 뒤, Github Pages(깃허브 블로그)를 생성해보도록 하자.      ","categories": ["DevOps"],
        "tags": ["GithubPages","깃허브페이지","깃허브블로그","macosvmware설치","vmwarefusion설치","ubuntu20.04설치","ubuntu","linux"],
        "url": "/devops/Linux-Ubuntu-VMware-ubuntu/",
        "teaser": null
      },{
        "title": "[Python]패스트캠퍼스 캐시백 챌린지 1일차",
        "excerpt":"     회사분의 추천을 받고 또 충동적으로 구매해버린 패스트캠퍼스 강의… 이번에야말로 꼭 완강을 해보겠다는 의지로 캐시백 챌린지를 신청해보았다. 이번에 내가 신청한 강의는 “한 번에 끝내는 파이썬 웹 개발 초격차 패키지 Online”. 파이썬 기초 언어 뿐만 아니라 배포, 관련 라이브러리 등을 한꺼번에 습득할 수 있는 커리큘럼인데다 이미 강의를 듣고 계신 회사분이 설명도 나쁘지 않다고 해주셔서 12개월 할부로 긁었다.      캐시백 챌린지는 기본적으로 매일 최소 1강 이상씩 듣고 공부기록을 블로그에 올리면 강의료를 환급해주는 형식인데, 중간과제가 있긴 하나 코딩 관련이 아닌 리뷰 개념이라 부담없이 성공할 수 있을 듯 한 느낌. (하지만 이러고 실패하면 정말 노간지인데….^^ 열심히 해야겠다)           강의를 미리 결제해놓았어서 1일차는 그동안 미리 들어두었던 공부 내용을 전체적으로 정리해보았다.      Part 1. 파이썬 필수 문법   Ch01. 강의소개   1. 파이썬을 선택하는 세 가지 이유           문법이 쉽고 간결하다       아래는 같은 결과값을 출력하는데 필요한 코딩 양.   [첫번째 코드블록: C]        #include&lt;studio.h&gt;  int main (void){  \tprintf(\"안녕하세요\\n\");  \treturn 0;  }          [두번째 코드블록: Python]       print(\"안녕하세요\")                   인기가 많다.            학습 자료가 많음 (책, 온/오프라인 강의, 블로그 등)       오류가 생겼을 때 누군가 해결 방법을 찾아놓았을 경우가 많다.                    다양한 분야에 활용 가능하다            웹 서버 개발(Django, flask)       크롤링       업무자동화       데이터분석       인공지능       게임제작                 Ch02. 환경 설정             참고: MacOS에서 설치를 진행했기 때문에 MacOS 에 대한 설명만 기재하였다.        1. 파이썬 설치      https://www.python.org &gt; Download &gt; 파이썬 패키지 다운로드   패키지 파일 더블클릭해 설치 (이용약관: 동의)   설치가 완료되면 아래와 같이 파이썬 디렉토리가 생성된다.              python 3 명령어로 설치된 버전을 확인 할 수 있다.              python 명령어를 실행해보자.            2. idle로 파이썬 실행      Launchpad에서 ‘Idle’을 검색해 더블클릭으로 실행   명령어 한줄씩 실행 예시:              명령어 여러줄 실행: File &gt; New File            실행하고 싶은 명령어 입력                         Run &gt; Run Module 클릭 &gt; 파일 저장                    실행 결과가 최초 실행했던 idle 창에 표시된다.                                      idle을 사용하지 않는 이유            UI가 예쁘지 않다       자동완성 기능이 없다       파일 탐색기능이 없어 폴더/파일 기능 관리가 어렵다           ⇒ 결론: VScode를 사용하자!            3. 소스코드 편집기를 사용하는 이유      폴더, 파일 쉽게 정리   코드 자동완성 기능   디버깅(오류수정)이 쉽다: 오타, 문법오류 날 시 알려 준다   유용한 단축키가 많다        4. vscode 설치      vscode 공식 홈페이지 &gt; Download   루트폴더 지정            File &gt; Open &gt; ‘Documents’ &gt; 새로운 폴더 ‘python_basic’을 root로 지정       vscode에서 보는 디렉토리/파일과 실제 디렉토리/파일이 연동 되어있다.                    vscode에서 생성 ⇒ 실제 폴더에도 생성           실제 폴더 생성 ⇒ vscode 에도 생성                                              파일 생성 버튼 &gt; ‘hello.py’ 이름 입력 후 엔터 &gt; 파이썬 파일 생성됨                    print(”hello python!”) 입력하기                                                     저장 되었는지 여부 판단하기: 탭 이름 옆 흰 동그라미가 있을 경우 변경사항이 저장이 되지 않은 것.                                                       [추가] 폰트 설정 바꾸기: Code &gt; Preferences &gt; 폰트사이즈 입력 후 ‘Settings’ 닫아줌                                  폰트 크기 변경이 적용이 된 것을 확인할 수 있다.                                               Extensions에서 확장 프로그램 “Python(Microsoft)” 설치                                               파이썬 코드 실행방법: Run &gt; Run without Debugging                                               파이썬 코드 실행방법 2: vscode 오른쪽 상단의 재생 버튼 클릭                                               하단 콘솔에서 파이썬 코드가 실행됨을 확인할 수 있다.                                   5. VScode의 장점           파일과 폴더를 보기 쉽게 정리할 수 있다(탐색기 내장).                           코드 자동완성 기능 (클릭 혹은 엔터키로 입력 가능)                           디버깅, 오류 수정이 쉽다(아래처럼 오류가 난 부분을 표시해준다).                           유용한 단축키가 많다.             예: option + shift + 아래/위 방향키로 간단하게 복사 가능                                 예: option + 클릭 (여러 줄을 동시에 선택/수정할 수 있다).                       6. 가상환경 설정(Mac)   1. 가상환경을 사용하는 이유      A 프로젝트: 패키지 1.0 버전 사용        B 프로젝트: 패키지 2.0 버전 사용       ⇒ 컴퓨터 안 공간을 나누면 한 컴퓨터 안에서 다른 버전을 사용할 수 있다.            2. 가상환경 만들고 패키지 설치      venv로 설치        myvenv 라는 이름의 가상환경 만들기                           myvenv 라는 새로운 폴더가 생성된 것을 확인할 수 있다.                      myvenv &gt; bin &gt; activate 파일을 이용해 활성화            (myvenv) 라는 가상환경명이 명령줄 앞에 붙게 된다.             python_basic source ./myvenv/bin/activate   (myvenv) ➜  python_basic                          가상환경에서 빠져나오려면 deactivate 명령어를 실행해주면 된다.             (myvenv) ➜  python_basic deactivate   ➜  python_basic                         TIP) 위/아래 방향키로 이전에 사용했던 명령어들을 사용할 수 있다.                           pip 명령어를 통해 가상환경에 설치된 모듈이나 패키지를 확인할 수 있다.                                 예 1) pip list: 현재 설치되어 있는 패키지 파일 리스트 확인                 (myvenv) ➜  python_basic pip list   Package    Version   ---------- -------   pip        22.0.4   setuptools 58.1.0                                                  예 2) pip install requests: requests 라는 패키지 파일을 myvenv라는 가상환경 안에 설치                            따라서 다른 프로젝트와 충돌이 나지 않게 된다.                             (myvenv) ➜  python_basic pip install requests   Collecting requests     Downloading requests-2.27.1-py2.py3-none-any.whl (63 kB)        ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 63.1/63.1 KB 3.0 MB/s eta 0:00:00   Collecting charset-normalizer~=2.0.0     Downloading charset_normalizer-2.0.12-py3-none-any.whl (39 kB)   Collecting idna&lt;4,&gt;=2.5     Downloading idna-3.3-py3-none-any.whl (61 kB)        ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 61.2/61.2 KB 1.9 MB/s eta 0:00:00   Collecting urllib3&lt;1.27,&gt;=1.21.1     Downloading urllib3-1.26.9-py2.py3-none-any.whl (138 kB)        ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 139.0/139.0 KB 2.6 MB/s eta 0:00:00   Collecting certifi&gt;=2017.4.17     Downloading certifi-2021.10.8-py2.py3-none-any.whl (149 kB)        ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 149.2/149.2 KB 1.9 MB/s eta 0:00:00   Installing collected packages: certifi, urllib3, idna, charset-normalizer, requests   Successfully installed certifi-2021.10.8 charset-normalizer-2.0.12 idna-3.3 requests-2.27.1 urllib3-1.26.9                                                  예 3) pip list 로 설치된 패키지 파일을 다시 확인한다.                            requests 패키지와 requests 패키지가 필요로 하는 다른 패키지들이 설치된 것을 확인할 수 있다.                             (myvenv) ➜  python_basic pip list               Package            Version   ------------------ ---------   certifi            2021.10.8   charset-normalizer 2.0.12   idna               3.3   pip                22.0.4   requests           2.27.1   setuptools         58.1.0   urllib3            1.26.9                                                                  강의에서의 소스코드 디렉토리 구성: myvenv 하위에 Chapter 별로 폴더 생성 ⇒ 필요한 실습 소스 파일 생성해 코드 작성            myvenv/Chapter 2/01.가상환경세팅.py 구조로 폴더 및 파일 생성                                 01.가상환경세팅.py 파일 안에 실습코드 작성 및 실행                           본 포스팅은 패스트캠퍼스 환급 챌린지 참여를 위해 작성되었습니다.          패스트캠퍼스 강의 등록하기: https://bit.ly/3L3avNW       #패스트캠퍼스 #패캠챌린지 #직장인인강 #직장인자기계발 #패스트캠퍼스후기 #캐시백챌린지 #캐시백 #환급챌린지 #한번에끝내는파이썬웹개발초격차패키지Online  ","categories": ["Programming"],
        "tags": ["패스트캠퍼스","패캠챌린지","직장인인강","직장인자기계발","패스트캠퍼스후기","캐시백챌린지","캐시백","환급챌린지","한번에끝내는파이썬웹개발초격차패키지Online"],
        "url": "/programming/Python-Day1/",
        "teaser": null
      },{
        "title": "[Python]패스트캠퍼스 캐시백 챌린지 2일차",
        "excerpt":"     오늘은 패스트캠퍼스(Fastcampus) 캐시백 챌린지 2일차 포스팅. 어제에 이어서 “한 번에 끝내는 파이썬 웹 개발 초격차 패키지 Online” 의 챕터 3-1. 숫자, 문자, 불린형, 자료형을 듣고 강의 내용을 정리해 보았다. 이 포스팅은 공부용으로 요약한 것으로, 자세한 강의 내용은 위 링크를 참조할 것.         Ch03.자료형과 변수            1. 자료형이란?      자료(Data)란?            많은 자료를 분류하기 위해서 자료의 형태(종류)를 나눠주는 것.                1. 숫자형      숫자 데이터를 뜻한다.   정수형(Integer: int): 1, 2, 3, 0, -1, -10 (소수점이 없다)   실수형(Float): 1.5, 0, -3, 1.4 (소수점이 있다)   # 주석(Comments) # 1. 코드에 설명을 추가하고 싶을 때 사용한다. # 2. 코드를 실행하고 싶지 않을 때 사용한다.  # 출력문 # print(\"hello world\") # 출력문  # - 숫자 자료형 # 1. 정수형: 소수점이 없는 수 # print(1) # print(3) # print(-1) print(1,3,0,-1)  # 2. 실수형: 소수점이 있는 수 # print(1.1) # print(3.1) # print(0) # print(-1.4) print(1.1,3.1,0,-1.4)        2. 문자열      문자를 나열한 것을 뜻한다.   \"(큰따옴표) '(작은따옴표) 로 문자열의 시작과 끝을 나타낸다.   예 1: “123” (문자열), 123 (숫자열)   예 2: 따옴표 속의 따옴표 표현 ⇒ ‘”개 짖는 소리좀 안 나게 해라!”라고 말했다.’   # - 문자열 자료형 # \"\" or '' 로 감싸서 표현한다. print(\"파이썬 너무 재밌다\") print('파이썬 정말 재밌자너!')  # 문자열에 \"\" 따옴표가 포함되어있는 경우 ''로 감싸서 표현 print('\"개 짖는 소리 좀 안나게 해라\"라고 그는 외쳤다.')        3. 불린형(Boolean)      참 또는 거짓으로 나뉜다.   예: True, False (불린형의 경우 대문자로 시작함에 유의할 것)   print(True) #참 print(False) #거짓        4. 참고      print 함수 중 속성값으로 줄 수 있는 항목.          SEP: print 함수 출력 시 값 사이의 공백을 없애준다.         print(1, 3, 0, -1, sep=\"\")              출력결과        print(130-1)                       END: print 함수가 끝나도 줄바꿈이 되지 않도록 하는 기능         print(1, 3, 0, -1, end=\"\")              아래는 강의 인증샷 두번째.           오늘은 숫자, 문자, 불린형, 자료형에 대해 알아보았다. 내일은 파이썬(Python)에서 다루게 될 변수에 대해 알아보도록 하겠다.      본 포스팅은 패스트캠퍼스 환급 챌린지 참여를 위해 작성되었습니다.      패스트캠퍼스 강의 등록하기: https://bit.ly/3L3avNW   패스트캠퍼스 [직장인 실무교육]   #패스트캠퍼스 #패캠챌린지 #직장인인강 #직장인자기계발 #패스트캠퍼스후기 #캐시백챌린지 #캐시백 #환급챌린지 #한번에끝내는파이썬웹개발초격차패키지Online  ","categories": ["Programming"],
        "tags": ["패스트캠퍼스","패캠챌린지","직장인인강","직장인자기계발","패스트캠퍼스후기","캐시백챌린지","캐시백","환급챌린지","한번에끝내는파이썬웹개발초격차패키지Online"],
        "url": "/programming/Python/",
        "teaser": null
      },{
        "title": "[Python]패스트캠퍼스 캐시백 챌린지 3일차",
        "excerpt":"     오늘도 어제에 이어서 “한 번에 끝내는 파이썬 웹 개발 초격차 패키지 Online” 의챕터 3-2. 변수 강의를 듣고 정리해보았다. 참고로 이 포스팅은 공부용으로 강의 내용을 요약한 것으로 자세한 강의 내용은 위 링크를 참조 할 것.            2. 변수   1. 변수란?      데이터를 저장할 공간   저장한 데이터를 언제든지 변경할 수 있다.        2. 변수를 만드는 방법      변수이름 = 데이터   = 는 할당 연산자: 오른쪽의 데이터를 왼쪽의 변수에 저장        3. 변수 이름 규칙      데이터를 표현할 수 있는 이름으로 짓는다(중요).   문자부터 시작해야 한다.   대소문자는 구분한다.   _로 시작할 수 있다.   미리 예약된 키워드는 사용할 수 없다.           4. 실습      변수이름에 데이터를 저장한 뒤 출력해보자.   # 변수 # 변수이름 = 데이터  # 마스터이 챔피언 데이터를 변수에 저장 name = \"마스터이\" level = 5 health = 800 attack = 90  print(name, level, health, attack) # print(\"마스터이\", 5, 800, 90)와 같음           실행버튼을 눌러 결과를 확인한다. 저장한 데이터가 출력됨을 알 수 있다.   (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter3/02.변수.py 마스터이 5 800 90           변수에 저장된 데이터를 변경하기   # 변수에 저장된 데이터를 변경하기 level = 6 health = 850 attack = 100 print(name, level, health, attack)           실행버튼을 눌러 결과를 확인한다. 기존에 저장되었던 데이터가 변경되어 있는 것을 확인할 수 있다.   (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter3/02.변수.py 마스터이 6 850 100           연산자를 이용해 데이터를 변경할 수도 있다.   # 변수에 저장된 데이터를 변경하기 level = level + 1 # 5 + 1 health = health + 50 # 800 + 50 attack = attack + 10 # 90 + 10 print(name, level, health, attack)           결과를 출력해보면 데이터가 변경된 것을 확인할 수 있다.   (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter3/02.변수.py 마스터이 6 850 100        다음 시간에는 더하기(+ ) 연산자 외에 곱하기, 빼기 등의 연산자, 연산식을 간단하게 표현할 수 있는 복합 연산자, True/False 등의 값을 연산하는 비교연산자 등에 대해서 배워보도록 하겠다.        본 포스팅은 패스트캠퍼스 환급 챌린지 참여를 위해 작성되었습니다.          패스트캠퍼스 강의 등록하기: https://bit.ly/3L3avNW       #패스트캠퍼스 #패캠챌린지 #직장인인강 #직장인자기계발 #패스트캠퍼스후기 #캐시백챌린지 #캐시백 #환급챌린지 #한번에끝내는파이썬웹개발초격차패키지Online  ","categories": ["Programming"],
        "tags": ["패스트캠퍼스","패캠챌린지","직장인인강","직장인자기계발","패스트캠퍼스후기","캐시백챌린지","캐시백","환급챌린지","한번에끝내는파이썬웹개발초격차패키지Online"],
        "url": "/programming/Python-%ED%8C%A8%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%8D%BC%EC%8A%A4-%EC%BA%90%EC%8B%9C%EB%B0%B1-%EC%B1%8C%EB%A6%B0%EC%A7%80-3%EC%9D%BC%EC%B0%A8/",
        "teaser": null
      },{
        "title": "[Python]패스트캠퍼스 캐시백 챌린지 4일차",
        "excerpt":"     오늘도 어제에 이어서 “한 번에 끝내는 파이썬 웹 개발 초격차 패키지 Online” 의챕터 3-2. 변수 강의를 듣고 정리해보았다. 참고로 이 포스팅은 공부용으로 강의 내용을 요약한 것으로 자세한 강의 내용은 위 링크를 참조 할 것.            Ch04. 연산과 연산자   1. 연산(1)   1. 연산이란?      수나 식을 일정한 규칙에 따라 계산하는 것        2. 연산의 종류      가장 많이 쓰이는 연산은 아래 네 가지.   대입연산   산술연산   비교연산   논리연산        3. 대입연산      ‘변수이름 = 데이터’   오른쪽의 데이터를 왼쪽의 변수이름에 할당한다(=: 할당연산자)        4. 산술연산                  연산자(연산기호)       설명                       +       더하기                 -       빼기                 *       곱하기                 /       나누기                 //       몫                 %       나머지                 **       제곱                5. 실습               대입 연산은 지난 시간 실습을 진행해 이번에는 생략하도록 한다.        산술연산 예시         # 1. 대입연산   # 변수이름 = 데이터        # 2. 산술연산   # - 숫자 연산   x = 5   y = 2        print(x + y)   print(x - y)   print(x * y)   print(x / y)   print(x // y) # 몫   print(x % y) #나머지   print(x ** y) # 제곱                        결과값은 아래와 같다.         7   3   10   2.5   2   1   25                   숫자 뿐만 아니라 문자열도 서로 더할 수 있다.   # - 문자열 연산 tag1 = \"#내꺼하자\" tag2 = \"#오늘부터1일\" tag3 = \"#여친생김\"  tag = tag1 + tag2 + tag3 print(tag)           연산 결과는 아래와 같다.   #내꺼하자#오늘부터#여친생김           문자열을 서로 곱할 수도 있다.   message = \"우리 모두 파이썬을 사랑합니다.\" * 5 print(message)           연산 결과 아래와 같이 문자열이 5번만큼 출력되는 것을 확인할 수 있다.   우리 모두 파이썬을 사랑합니다.우리 모두 파이썬을 사랑합니다.우리 모두 파이썬을 사랑합니다.우리 모두 파이썬을 사랑합니다.우리 모두 파이썬을 사랑합니다.           문장이 끝난 뒤 줄 바꿈을 하고 싶은 경우 줄바꿈문자 \\n 을 넣어주면 된다.   message = \"우리 모두 파이썬을 사랑합니다.\\n\" * 5 print(message)           연산결과 아래와 같이 문자열이 끝날때마다 줄이 바뀌는 것을 확인할 수 있다.   우리 모두 파이썬을 사랑합니다. 우리 모두 파이썬을 사랑합니다. 우리 모두 파이썬을 사랑합니다. 우리 모두 파이썬을 사랑합니다. 우리 모두 파이썬을 사랑합니다.           복합할당연산자   # 복합할당연산자 level = 10 # (레벨 1 증가) level = level + 1 # 이 식을 아래와같이 표현할 수 있다. level += 1 # 복합할당연산자를 사용(= level = level + 1)  health = 2000 # (체력 300 감소) health -= 300 # health = health - 300  attack = 300 # (공격력 1.5배 증가) attack *= 1.5 # attack = attack * 1.5   speed = 420 # (이동속도 50% 감소) speed /= 2 (speed = speed/2)  print(level, health, attack, speed)           출력 결과는 하기와 같다   11 1700 450 210        다음에는 비교연산, 논리연산, 멤버십연산에 대해 알아보도록 하겠다.        본 포스팅은 패스트캠퍼스 환급 챌린지 참여를 위해 작성되었습니다.           패스트캠퍼스 강의 등록하기: https://bit.ly/3L3avNW        #패스트캠퍼스 #패캠챌린지 #직장인인강 #직장인자기계발 #패스트캠퍼스후기 #캐시백챌린지 #캐시백 #환급챌린지 #한번에끝내는파이썬웹개발초격차패키지Online  ","categories": ["Programming"],
        "tags": ["패스트캠퍼스","패캠챌린지","직장인인강","직장인자기계발","패스트캠퍼스후기","캐시백챌린지","캐시백","환급챌린지","한번에끝내는파이썬웹개발초격차패키지Online"],
        "url": "/programming/Python-Day4/",
        "teaser": null
      },{
        "title": "[Python]패스트캠퍼스 캐시백 챌린지 5일차",
        "excerpt":"     오늘도 어제에 이어서 “한 번에 끝내는 파이썬 웹 개발 초격차 패키지 Online” 의 챕터 4-2. 연산자 강의를 듣고 정리해보았다. 참고로 이 포스팅은 공부용으로 강의 내용을 요약한 것으로 자세한 강의 내용은 위 링크를 참조 할 것.            2. 연산(2)   1. 비교연산                  연산자(연산기호)       설명(왼쪽이 오른쪽보다)                       &gt;       크다                 &lt;       작다                 &gt;=       크거나 같다                 &lt;=       작거나 같다                 ==       같다                 !=       다르다                  조건문을 이해하기 위해 꼭 필요한 내용   예: 1 &gt; 2 ⇒ False(거짓),  1 &lt; 2 ⇒ True(참)           VScode로 비교연산자를 활용해보자.   # 1. 비교연산 print(2 &gt; 3) # False  print(15 &lt; 30) # True print(1.5 &gt;= 0) # True print(3 &lt;= 3) # True print(\"팛팛팛\" == \"팛팛팗\") # False print(\"1111111111111111\" != \"1111111111111111\") # True        2. 논리연산                           연산자       설명                       A and B       A,B 모두 참이라면 True                 A or B       A,B 중 하나라도 참이라면 True                 not A       A가 참이라면 False                  논리 연산은 두 개의 비교연산을 합칠 때 자주 사용   예: 1 &lt; 2 and 1 == 1 ⇒ 1 &lt; 2 , 1 == 1 모두 참일 경우에만 True           VScode로 비교연산자를 활용해보자.   # 2. 논리연산 print(4 &lt; 6 and 10 &gt;= 10) # True and True -&gt; True print(\"포기하지말아요\" != \"포기하지말아요\" or \"나는 할 수 있다\" == \"나는 할 수 있다\") # False or True =&gt; True print(not 5==5) # not True -&gt; False        3. 멤버십 연산                  연산자(연산기호)       설명(왼쪽이 오른쪽에)                       in       포함되어 있다                 not in       포함되어 있지 않다                  리스트 자료형을 알아야 더 잘 활용 할 수 있다.   예: “a” in “abc” ⇒ True           VScode로 비교연산자를 활용해보자.   # 3. 멤버십 연산 print(\"- 멤버십 문제\") print(\"a\" in \"abc\") # 포함되어 있다면 True print(\"d\" not in \"abc\") # 포함되어 있지 않다면 True        연산 자체는 어렵지 않은 내용이나, 다다음 시간에 배울 조건문과 같이 활용하게 됨. 다음은 입력과 자료형 변환에 대해 알아보도록 하자.        본 포스팅은 패스트캠퍼스 환급 챌린지 참여를 위해 작성되었습니다.      패스트캠퍼스 강의 등록하기: https://bit.ly/3L3avNW   패스트캠퍼스 [직장인 실무교육]   #패스트캠퍼스 #패캠챌린지 #직장인인강 #직장인자기계발 #패스트캠퍼스후기 #캐시백챌린지 #캐시백 #환급챌린지 #한번에끝내는파이썬웹개발초격차패키지Online  ","categories": ["Programming"],
        "tags": ["패스트캠퍼스","패캠챌린지","직장인인강","직장인자기계발","패스트캠퍼스후기","캐시백챌린지","캐시백","환급챌린지","한번에끝내는파이썬웹개발초격차패키지Online"],
        "url": "/programming/Python-Day5/",
        "teaser": null
      },{
        "title": "[Kubernetes/NGINX] NGINX Ingress의 Sticky Session 설정이 되지 않는 이슈 해결",
        "excerpt":"     💡   TL;DR : NGINX Ingress Controller 사용 시 nginx.ingress.kubernetes.io 어노테이션을 사용해야 Sticky session 등의 설정값이 적용된다(일반 ingress.kubernetes.io 설정 적용시 설정 적용 안됨)        1. 에러 상황   컨테이너 전환 프로젝트 진행 도중 Ingress Controller를 Contour에서 NGINX-Ingress Controller로 변경 후, 시스템에 간헐적으로 접속이 되지 않는 현상이 발생했다(구체적으로는 브라우저에서 관리자에게 문의하라는 페이지가 뜨며 접속이 되지 않다가 새로고침 시 접속이 되는 현상).        해당 시스템은 Multi Pod로 구성되어있었는데(replicas = 2), 각 Pod로그를 보니 아래와 같은 SQL 에러가 발생하고 있었다.   Error querying database. Cause: com.edb.util.SQLException: FATAL: terminating connection due to administrator command        로그를 추가적으로 살펴보니 user 정보를 SELECT하는 데에서 오류가 나고 있었고, 각 파드에서 로그인 아이디 정보를 찍어주는 로그에 아래와 같은 로그가 발생하고 있었다.          Pod A 로그   2022-MM-DD_hh:mm:ss.000:loginId=null, /파일경로, clientTimezone=Asia/Seoul          Pod B 로그   2022-MM-DD_hh:mm:ss.000:loginid=canary,/파일경로, userId=canary        로그인 아이디를 한쪽에서만 받아주고 있었는데, 브라우저에서 관리자도구(F12키로 관리자 도구 기동 ⇒ Network에서 JSESSIONID 확인) 로 확인해보니 새로고침마다 다른 Pod에서 세션을 받아오는 round robin 방식으로 세션 설정이 되어있어 로그인 정보가 저장되지 않은 Pod에 접근할 때 에러가 나고있었다.        쿠버네티스 대시보드의 Ingress 설정을 확인해보니, annotation 값들이 nginx.ingress.kubernetes (NGINX ingress controller를 적용했을 때의 설정)가 아닌 ingress.kubernetes , 즉 일반 쿠버네티스 ingress 객체 설정으로 되어있어 annotation 설정이 적용이 되지 않고 있었다.        2. 해결 방법   따라서 해당 설정을 아래와 같이 nginx.ingress로 변경해 round robin 대신  sticky session을 적용했다. sticky sesison 적용 후 사용자 로그인 정보가 저장된 Pod로만 요청이 라우팅되어 에러가 해결되었다.           nginx-ingress.yaml 설정   apiVersion: netwroking.k8s.io/v1 kind: Ingress metadata:  name: nginx-ingress  namespace: web-app  annotations:   kubernetes.io/ingress.class: nginx   nginx.ingress.kuberentes.io/affinity: cookie   nginx.ingress.kuberentes.io/affinity-mode: persistent   nginx.ingress.kuberentes.io/session-cookie-expires: '172800'   nginx.ingress.kuberentes.io/session--cookie-max-age: '172800'  (이하 생략)       kubernetes.io/ingress.class: nginx : 어떤 인그레스를 쓸 것인지 설정   nginx.ingress.kuberentes.io/affinity-mode: cookie : 세션 어피니티(session affinity = sticky session) 설정 활성화. 현재 NGINX에서 사용 가능한 어피니티 타입은 cookie 하나 뿐이다.   nginx.ingress.kuberentes.io/affinity-mode: persistent : 얼마나 sticky 하게 설정할 것인지 설정. balanced (기본값) 과 persistent 두 가지가 있다. Persistent로 설정할 경우 Pod가 확장되어도 서버간 부하를 분산하지 않는다.   nginx.ingress.kuberentes.io/session-cookie-expires: '172800' : 쿠키 만료시까지의 시간(초 단위)   nginx.ingress.kuberentes.io/session--cookie-max-age: '172800' : 오래된 브라우저와 호환되는 이전 버전의 Annotation 값. Expires 쿠키를 생성함.           참고            NGINX Configuration (https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/)       NGINX Examples Sticky Sessions (https://kubernetes.github.io/ingress-nginx/examples/affinity/cookie/)          ","categories": ["DevOps"],
        "tags": ["NGINX","kubernetes","NGINXingresscontroller","nginxstickysession","stickysession설정","스티키세션설정","데브옵스엔지니어","DevOps"],
        "url": "/devops/Kubernetes-NGINX-Ingress-Sticky-Session-Issue/",
        "teaser": null
      },{
        "title": "[Python]패스트캠퍼스 캐시백 챌린지 6일차",
        "excerpt":"     오늘도 어제에 이어서 “한 번에 끝내는 파이썬 웹 개발 초격차 패키지 Online” 의 챕터 4-3. 입력과 자료형 변환 강의를 듣고 정리해보았다. 참고로 이 포스팅은 공부용으로 강의 내용을 요약한 것으로 자세한 강의 내용은 위 링크를 참조 할 것.        아래는 공부 인증 사진.                  3. 입력과 자료형 변환   1. 데이터 입력 받기      입력 함수: input()   사용자로부터 데이터를 입력 받는 함수   예시 1            아래 코드를 파이썬 인터프리터가 어떻게 해석하고 실행할까?       파이썬 인터프리터: 파이썬 소스코드를 해석 &amp; 실행             x = input()                [파이썬 코드 실행 순서]              할당연산자 (=) 오른쪽부터 실행       input 함수 실행 시, 입력을 기다린다       사용자가 데이터를 입력하고 엔터를 치면       input 함수 자리에 데이터가 들어간다.       x에 데이터가 할당된다.                        예시 2         x = input(\"입력하세요 &gt;&gt;&gt; \")                  입력하세요 &gt;&gt;&gt; : 입력을 유도하게끔 하는 안내문                    [파이썬 코드 실행 순서]              할당연산자 (=) 오른쪽부터 실행       input 함수 실행 시, 메시지를 출력하고 입력을 기다린다.       사용자가 데이터를 입력하고 엔터를 치면       input 함수 자리에 데이터가 들어간다.       x에 데이터가 할당된다.                [실습문제 4.3.1]      사용자로부터 2개의 숫자(20, 40)를 입력 받고, 더한 결과를 출력하기   먼저 푼 뒤 강의 이어 들을 것        내가 푼 결과         NumOne = input(\"첫번째 숫자를 입력하세요 &gt;&gt;&gt; \")   NumTwo = input(\"두번째 숫자를 입력하세요 &gt;&gt;&gt; \")        result = int(NumOne) + int(NumTwo)   print(result)                        강의 해설         # 실습문제 4.3.1   # 사용자로부터 두 개의 숫자를 입력 받고,   # 더한 결과를 출력하기        x = input(\"첫번째 숫자를 입력하세요 &gt;&gt;&gt;\")   y = input(\"두번째 숫자를 입력하세요 &gt;&gt;&gt;\")        result = x + y   print(result)           ⇒ 코드를 실행한 뒤 차례로 20, 40의 입력값을 넣고 엔터를 치면 “2040”라는 결과값이 출력된다.                    자료형을 확인해본다         # 자료형 확인하기 : type(x)   # str = string = 문자열   print(type(x))                  &lt;class ‘str’&gt;라는 결과값이 출력된다. 즉, x의 자료형은 문자열이다.                      # 숫자형으로 변환   # int 함수를 사용 : int(데이터)   result = int(x) + int(y)   print(result)                  x, y 값을 정수로 변환해주면 정상적으로 작동한다.                [실습문제 4.3.2]   사용자로부터 태어난 연도를 입력 받으면, 현재 나이를 출력하기      표준 입력: 태어난 연도를 입력하세요 »&gt; 1994   표준 출력: 현재 나이는 29세입니다.   내가 푼 방법   birth_year = input(\"태어난 연도를 입력하세요 &gt;&gt;&gt; \") current_year = 2022 current_age = current_year - int(birth_year)  result = \"현재 나이는\" + str(current_age) + \"세 입니다.\" print(result)      수정이 필요한 부분: 현재 나이를 계산할 때에는 현재연도 - 출생연도에 1을 더해주어야한다.                강의 해설         year = input(\"태어난 연도를 입력하세요 &gt;&gt;&gt; \")   age = 2022 - year + 1   print(\"현재나이는\", age, \"세 입니다.\")                  해당 함수 실행 시 TypeError: unsupported operator type(s) for : 'int' and 'str' 에러 발생                input으로 받은 값이 str이기 때문에 age에서 숫자 연산이 불가능               year를 정수형으로 변환한다.             // 바로 int로 감싸도 됨   year = int(input(\"태어난 연도를 입력하세요 &gt;&gt;&gt; \"))        age = 2022 - year + 1   print(\"현재나이는\", age, \"세 입니다.\")                  해당 함수 실행 및 태어난 연도를 입력하면 “현재나이는 현재나이 세 입니다”라는 결과가 나온다.                    ## 2. 정리              사용자로부터 입력받기: `input(“입력할 시 출력할 메시지”))       자료형변환: 숫자형으로 변환(int(데이터))                본 포스팅은 패스트캠퍼스 환급 챌린지 참여를 위해 작성되었습니다.           패스트캠퍼스 강의 등록하기: https://bit.ly/3L3avNW        #패스트캠퍼스 #패캠챌린지 #직장인인강 #직장인자기계발 #패스트캠퍼스후기 #캐시백챌린지 #캐시백 #환급챌린지 #한번에끝내는파이썬웹개발초격차패키지Online  ","categories": ["Programming"],
        "tags": ["패스트캠퍼스","패캠챌린지","직장인인강","직장인자기계발","패스트캠퍼스후기","캐시백챌린지","캐시백","환급챌린지","한번에끝내는파이썬웹개발초격차패키지Online"],
        "url": "/programming/Python-Day6/",
        "teaser": null
      },{
        "title": "[Python]패스트캠퍼스 캐시백 챌린지 7일차",
        "excerpt":"     오늘도 어제에 이어서 “한 번에 끝내는 파이썬 웹 개발 초격차 패키지 Online” 의 챕터 5-1. 조건문 개념 강의를 듣고 정리해보았다. 참고로 이 포스팅은 공부용으로 강의 내용을 요약한 것으로 자세한 강의 내용은 위 링크를 참조 할 것.        아래는 공부 인증 사진.                  Ch05. 제어문   1. 조건문 개념   1. 제어문 사용 이유      프로그램은 기본적으로 위에서 아래로 순차적으로 실행   명령 A,B 중 한 개를 선택해 실행하고 싶거나 - 조건문   명령들을 반복해 실행하고 싶을 때 - 반복문   제어문 = 조건문 + 반복문          예시1: 치킨 or 피자? - 조건문   예시2: 유투브 영상보기 - 반복문        2. 조건문의 개념      예시: 술집이나 클럽에 입장할 때 입장 가능 여부를 출력하는 조건문                 start: 시작   age = 20: age에 20이라는 값을 저장   age &gt; 19: 조건문   입장 가능: age가 19보다 클 경우   입장 불가능: age가 19보다 크지 않을 경우   end          이 개념을 파이썬에 적용하면? if문        3. if 문 사용법      기존 비밀번호 = “1234”   입력한 비밀번호 = “1234”        만약 비밀번호를 정확히 입력했으면       ⇒ 로그인 성공           [파이썬 코드]   origin_pass = \"1234\" input_pass = \"1234\" if origin_pass == input_pass:     print(\"로그인 성공\")      origin_pass = input_pass : 비교연산자   : : if의 명령블록이 실행된다는 뜻   print(”로그인 성공\") : if문의 명령블록임을 나타내기 위해 들여쓰기.        4. 실습   1. if와 else   # 조건문 # : 조건에 따라 실행할 명령이 달라 지는 것  origin_pass = \"1234\" input_pass = input(\"패스워드를 입력하세요 &gt;&gt;&gt;\")  if input_pass == origin_pass: # 조건 A     # 조건 A가 참     print(\"로그인 성공!\")     print(\"반갑습니다.\") else:     # 조건 A가 거짓     print(\"로그인 실패!\")     print(\"비밀번호를 확인하세요.\")      else: 조건 A가 거짓일 때 하위 명령블록 실행          출력 결과   # input_pass == 1234 # 조건 A가 참 (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter5/01.조건문개념.py 패스워드를 입력하세요 &gt;&gt;&gt;1234 로그인 성공! 반갑습니다.  # input_pass == 123 # 조건 A가 거짓 (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter5/01.조건문개념.py 패스워드를 입력하세요 &gt;&gt;&gt;123 로그인 실패! 비밀번호를 확인하세요.       3. else if   origin_pass = \"1234\" input_pass = input(\"패스워드를 입력하세요 &gt;&gt;&gt;\")  if input_pass == origin_pass: # 조건 A     # 조건 A가 참     print(\"로그인 성공!\")     print(\"반갑습니다.\") elif input_pass == \"\":     # 조건 A 거짓, 조건 B 참     print(\"아무것도 입력하지 않았습니다.\") else:     # 조건 A가 거짓, 조건 B 거짓     print(\"로그인 실패!\")     print(\"비밀번호를 확인하세요.\")      elif = if 외의 조건을 새로 추가하고 싶을 때 사용   elif는 if 바로 뒤에 입력해야한다.          출력 결과   # 조건 A가 참 (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter5/01.조건문개념.py 패스워드를 입력하세요 &gt;&gt;&gt;1234 로그인 성공! 반갑습니다.  # 조건 A 거짓, 조건 B 참 (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter5/01.조건문개념.py 패스워드를 입력하세요 &gt;&gt;&gt; 아무것도 입력하지 않았습니다.  # 조건 A가 거짓, 조건 B 거짓 (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter5/01.조건문개념.py 패스워드를 입력하세요 &gt;&gt;&gt;123 로그인 실패! 비밀번호를 확인하세요.        오늘 강의에서는 조건문 if의 개념과 간단한 사용법을 알아보았다. 다음 시간부터는 조건문 실습문제를 풀어보도록 하자.        본 포스팅은 패스트캠퍼스 환급 챌린지 참여를 위해 작성되었습니다.          패스트캠퍼스 강의 등록하기: https://bit.ly/3L3avNW       #패스트캠퍼스 #패캠챌린지 #직장인인강 #직장인자기계발 #패스트캠퍼스후기 #캐시백챌린지 #캐시백 #환급챌린지 #한번에끝내는파이썬웹개발초격차패키지Online  ","categories": ["Programming"],
        "tags": ["패스트캠퍼스","패캠챌린지","직장인인강","직장인자기계발","패스트캠퍼스후기","캐시백챌린지","캐시백","환급챌린지","한번에끝내는파이썬웹개발초격차패키지Online"],
        "url": "/programming/Python-Day7/",
        "teaser": null
      },{
        "title": "[Python/VScode]MacOS zsh: no matches found 에러 해결",
        "excerpt":"     💡   zsh에서는 몇몇 특수문자를 문자열이 아닌 명령어로 인식한다.        1. 에러 상황   한 번에 끝내는 파이썬 웹 개발 초격차 패키지 Online 과정을 들으며 vscode에 코드를 작성하던 중, 아래와 같이 파이썬(Python) 코드가 실행이 되지 않는 현상이 발생했다.       (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter4/02.연산(2).py zsh: no matches found: /Users/usr/Documents/python_basic/myvenv/Chapter4/02.연산(2).py       zsh에서 파이썬 파일 경로를 찾지 못하고 있었는데, 구글링을 해보니 zsh에서 몇몇 특수문자를 문자열이 아닌 명령어로 인식해 발생한 현상이라고 한다.        2. 해결 방법   내 경우에는 괄호 () 가 명령어로 인식되어 발생한 문제라, 다음과 같이 파일명에 괄호를 제거하고 - 를 넣어주었더니 에러가 해결되었다.       (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter4/02.연산-2.py       참고로 zsh 에서 명령어로 예약된 특수문자는 다음과 같다. zsh: no matches found 에러가 발생할 경우 파일명이나 디렉토리명 등 파이썬 코드가 저장된 경로에 아래의 특수문자가 삽입되어있지 않은지 확인해보자.                      특수문자       의미                       ~       홈 디렉토리                 `       명령 대체                 #       Comment                 ()       하위 셸 시작 / 종료                 |       파이프                 {}       명령 블록                 ‘       강한 인용부호                 &lt;       입력 재지정                 /       경로명 분리                 $       변수                 &amp;       백그라운드 실행                 *?       와일드카드                 \\       문자 그대로                 []       문자 집합                 ;       명령 분리                 “       약한 인용부호                 &gt;       출력 재지정                 !       NOT          ","categories": ["Programming"],
        "tags": ["패스트캠퍼스","파이썬에러","zsh에러","nomatchesfound에러","파이썬특수문지","파이썬","Python","vscode에러","Python에러"],
        "url": "/programming/Python-zsh-nomatchesfound-error/",
        "teaser": null
      },{
        "title": "[Python]패스트캠퍼스 캐시백 챌린지 8일차",
        "excerpt":"     오늘도 어제에 이어서 “한 번에 끝내는 파이썬 웹 개발 초격차 패키지 Online” 의 챕터 5-2. 조건문 실습문제(1)을 듣고 정리해보았다. 참고로 이 포스팅은 공부용으로 강의 내용을 요약한 것으로 자세한 강의 내용은 위 링크를 참조 할 것.        아래는 공부 인증 사진.                  2. 조건문 실습문제(1)   1. 실습문제 5.1.1      회사를 그만두게 된 유진이는 유투브를 시작하게 되었다. 그리고 유투브를 통해 수익창출을 하려고 한다. 프로그램 사용자로부터 현재 구독자 수를 입력 받으면, 수익 창출이 가능한지 불가능한지 알려주는 프로그램을 작성해보자. (단, 수익창출은 구독자가 1000명 이상일 경우 가능하다)            표준 입력: 현재 구독자 수를 입력하세요 &gt;&gt;&gt; 1200       표준 출력: 수익 창출이 가능합니다!       표준 입력: 현재 구독자 수를 입력하세요 &gt;&gt;&gt; 800       표준 출력: 수익 창출이 불가능합니다!           [내 풀이]   subscriber = input(\"현재 구독자 수를 입력하세요 &gt;&gt;&gt;\")  if int(subscriber) &gt;= 1000:     print(\"수익 창출이 가능합니다!\") else:     print(\"수익 창출이 불가능합니다!\")   [강의 해설]      구독자 수 입력값을 받는 함수를 작성한다.   작성한 뒤 print 함수로 제대로 출력 되는지 확인한다.   Tip: 코드를 작성 시에는 단계적으로 동작 테스트를 하면서 작성하는 것이 좋다.   sub_count = input(\"현재 구독자 수를 입력하세요 &gt;&gt;&gt;\") print(sub_count)      input 값에 숫자를 넣으면 잘 출력되는 것을 확인할 수 있다.   (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter5/02-2.실습문제5.1.1-해설.p y 현재 구독자 수를 입력하세요 &gt;&gt;&gt;22 22      1000명 이상일 때 “수익창출이 가능합니다!”라는 문구가 출력되는 if문을 작성해보자.   sub_count = input(\"현재 구독자 수를 입력하세요 &gt;&gt;&gt;\")  if sub_count &gt;= 1000:     print(\"수익 창출이 가능합니다!\")      출력 결과: sub_count 가 string(str) 형식이기 때문에 다음과 같은 타입 에러가 발생한다.   (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter5/02-2.실습문제5.1.1-해설.p y 현재 구독자 수를 입력하세요 &gt;&gt;&gt;1200 Traceback (most recent call last):   File \"/Users/usr/Documents/python_basic/myvenv/Chapter5/02-2.실습문제5.1.1-해설.py\", line 5, in &lt;module&gt;     if sub_count &gt;= 1000: TypeError: '&gt;=' not supported between instances of 'str' and 'int'      sub_count 의 자료형을 int 형태로 바꿔준다.   sub_count = int(input(\"현재 구독자 수를 입력하세요 &gt;&gt;&gt;\"))  if sub_count &gt;= 1000:     print(\"수익 창출이 가능합니다!\")      1000명 이상이 아닐 경우 수익 창출이 불가능합니다! 라는 문장을 출력하는 else문 작성   sub_count = int(input(\"현재 구독자 수를 입력하세요 &gt;&gt;&gt;\"))  if sub_count &gt;= 1000:     print(\"수익 창출이 가능합니다!\") else:     print(\"수익 창출이 불가능합니다!\")   2. 실습문제5.1.2      윤행이는 평소 휴대폰을 너무 많이 사용해 공부시간을 다 빼앗기고 있었다. 이렇게 가면 얼마 남지 않는 기말고사를 망칠 게 뻔했다. 윤행이가 공부 시간을 다 채울 경우에만 휴대폰을 사용할 수 있도록 프로그램을 만들어주자.   조건            10시간 이상: 휴대폰 잠금 해제       5시간 이상: 휴대폰 30분 사용가능       나머지: 사용 불가능           표준입력 1: 공부시간을 입력하세요(시간) &gt;&gt;&gt; 10   표준출력 1: 휴대폰 잠금이 해제됩니다.   표준입력 2: 공부시간을 입력하세요(시간) &gt;&gt;&gt; 5   표준출력 2: 휴대폰을 30분간 사용 가능합니다.   표준입력 3: 공부시간을 입력하세요(시간) &gt;&gt;&gt; 2   표준출력 3: 휴대폰 사용이 불가능합니다.   [내 풀이]   study_hour = int(input(\"공부시간을 입력하세요(시간) &gt;&gt;&gt;\"))  if study_hour &gt;= 10:     print(\"휴대폰 잠금이 해제됩니다.\") elif study_hour &gt;= 5:     print(\"휴대폰을 30분간 사용 가능합니다.\") else:     print(\"휴대폰 사용이 불가능합니다.\")      결과 확인   (myvenv) ➜  python_basic /Users/jinipark/Documents/pyt hon_basic/myvenv/bin/python /Users/jinipark/Documents/ python_basic/myvenv/Chapter5/03-1.실습문제5.1.2.py 공부시간을 입력하세요(시간) &gt;&gt;&gt;10 휴대폰 잠금이 해제됩니다  (myvenv) ➜  python_basic /Users/jinipark/Documents/pyt hon_basic/myvenv/bin/python /Users/jinipark/Documents/ python_basic/myvenv/Chapter5/03-1.실습문제5.1.2.py 공부시간을 입력하세요(시간) &gt;&gt;&gt;5 휴대폰을 30분간 사용 가능합니다.  (myvenv) ➜  python_basic /Users/jinipark/Documents/pyt hon_basic/myvenv/bin/python /Users/jinipark/Documents/ python_basic/myvenv/Chapter5/03-1.실습문제5.1.2.py 공부시간을 입력하세요(시간) &gt;&gt;&gt;2 휴대폰 사용이 불가능합니다.   [강의 해설]   # 실습문제 5.1.2  study_time = int(input(\"공부시간을 입력하세요(시간) &gt;&gt;&gt;\"))  if study_time &gt;= 10:     print(\"휴대폰 잠금이 해제됩니다.\") elif study_time &gt;= 5:     print(\"휴대폰을 30분간 사용가능 합니다.\") else:     print(\"휴대폰 사용이 불가능합니다.\")      결과 확인   # 공부시간 = 10 (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter5/03-2.실습문제5.1.2-해설.p y 공부시간을 입력하세요(시간) &gt;&gt;&gt;10 휴대폰 잠금이 해제됩니다.  # 공부시간 = 5 (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/jinipark/Documents/ python_basic/myvenv/Chapter5/03-2.실습문제5.1.2-해설.p y 공부시간을 입력하세요(시간) &gt;&gt;&gt;5 휴대폰을 30분간 사용가능 합니다.  # 공부시간 = 2 (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/jinipark/Documents/ python_basic/myvenv/Chapter5/03-2.실습문제5.1.2-해설.p y 공부시간을 입력하세요(시간) &gt;&gt;&gt;2 휴대폰 사용이 불가능합니다.             위의 조건식을 도식화해서 표현하자면 아래와 같다.                   본 포스팅은 패스트캠퍼스 환급 챌린지 참여를 위해 작성되었습니다.      패스트캠퍼스 강의 등록하기: https://bit.ly/3L3avNW   #패스트캠퍼스 #패캠챌린지 #직장인인강 #직장인자기계발 #패스트캠퍼스후기 #캐시백챌린지 #캐시백 #환급챌린지 #한번에끝내는파이썬웹개발초격차패키지Online  ","categories": ["Programming"],
        "tags": ["패스트캠퍼스","패캠챌린지","직장인인강","직장인자기계발","패스트캠퍼스후기","캐시백챌린지","캐시백","환급챌린지","한번에끝내는파이썬웹개발초격차패키지Online"],
        "url": "/programming/Python-Day8/",
        "teaser": null
      },{
        "title": "[Python]패스트캠퍼스 캐시백 챌린지 9일차",
        "excerpt":"     오늘도 어제에 이어서 “한 번에 끝내는 파이썬 웹 개발 초격차 패키지 Online” 의 챕터 5-3. 조건문 실습문제(2)을 듣고 정리해보았다. 참고로 이 포스팅은 공부용으로 강의 내용을 요약한 것으로 자세한 강의 내용은 위 링크를 참조 할 것.        아래는 공부 인증 사진.                  3. 조건문 실습문제(2)   1. 실습문제 5.1.3      현동이는 강의를 8시간 동안 들으니, 배가 너무 고파 저녁을 먹기로 하였다. 현동이가 현재 가진 금액을 통해 최대로 먹을 수 있는 음식을 출력해 주는 프로그램을 작성해 보자.          [조건] 20000원 이상 = 치킨, 10000원 이상 = 떡볶이, 2000원 이상: 편의점 김밥   표준 입력 1: 현재 가진 금액을 입력 &gt;&gt;&gt;   표준 출력 1: 오늘 저녁은... 치킨!   표준 입력 2: 현재 가진 금액을 입력 &gt;&gt;&gt;   표준 출력 2: 오늘 저녁은... 떡볶이!   표준 입력 3: 현재 가진 금액을 입력 &gt;&gt;&gt;   표준 출력 3: 오늘 저녁은... 편의점 김밥!        [내 풀이]   cash = int(input(\"현재 가진 금액을 입력 &gt;&gt;&gt;\"))  if cash &gt;= 20000:     print(\"오늘 저녁은... 치킨!\") elif cash &gt;= 10000:     print(\"오늘 저녁은... 떡볶이!\") elif cash &gt;= 2000:     print(\"오늘 저녁은... 편의점 김밥!\")          결과 출력   # 현재 금액 = 20000 (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter5/04-1.실습문제5.1.3.py 현재 가진 금액을 입력 &gt;&gt;&gt;20000 오늘 저녁은... 치킨!  # 현재 금액 = 12000 (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter5/04-1.실습문제5.1.3.py 현재 가진 금액을 입력 &gt;&gt;&gt;12000 오늘 저녁은... 떡볶이!  # 현재 금액 = 2000 (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr /Documents/ python_basic/myvenv/Chapter5/04-1.실습문제5.1.3.py 현재 가진 금액을 입력 &gt;&gt;&gt;2000 오늘 저녁은... 편의점 김밥!       [강의 해설]   # 실습문제 5.1.3  money = int(input(\"현재 가진 금액을 입력 &gt;&gt;&gt;\"))  if money &gt;= 20000:     print(\"오늘 저녁은... 치킨!\") elif money &gt;= 12000:     print(\"오늘 저녁은... 떡볶이!\") elif money &gt;= 2000:     print(\"오늘 저녁은... 편의점 김밥!\")      if 문 사용예            if       if - else       if - elif (else로 끝내지 않아도 됨)       if - elif - else                2. 실습문제 5.1.4      프로그램 사용자로부터 국어, 수학, 영어 성적이 입력된다. 세 과목의 평균 점수가 80점 이상이면 합격이다. 그런데 점수에 따라 함격 또는 불합격이 정해지는 프로그램에 오류가 발생했다. 80점 이상일 경우 불합격이 표시되도록 프로그램을 작성해보자 (단, 0점에서 100점 사이의 숫자를 입력하지 않으면 “잘못 입력하였습니다.”를 출력하자)          표준 입력 1: 국어 &gt;&gt;&gt; 95 , 수학 &gt;&gt;&gt; 75 , 영어 &gt;&gt;&gt; 100   표준 출력 1: 불합격   표준 입력 2: 국어 &gt;&gt;&gt; 55 , 수학 &gt;&gt;&gt; 40 , 영어 &gt;&gt;&gt; 70   표준 출력 2: 불합격   표준 입력 3: 국어 &gt;&gt;&gt; 1 , 수학 &gt;&gt;&gt; 120 , 영어 &gt;&gt;&gt; 85   표준 출력 3: 잘못 입력하였습니다.        [내 풀이]   korean = int(input(\"국어 &gt;&gt;&gt;\")) math = int(input(\"수학 &gt;&gt;&gt;\")) english = int(input(\"영어 &gt;&gt;&gt;\"))  average = (korean + math + english)/3  if not (0 &lt; korean &lt;= 100 and 0 &lt; math &lt;= 100 and 0 &lt; english &lt;= 100):     print(\"잘못 입력하였습니다.\") elif average &gt;= 80:     print(\"불합격\") elif average &lt; 80:     print(\"합격\")         결과 출력   (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter5/05-1.실습문제5.1.4.py 국어 &gt;&gt;&gt;95 수학 &gt;&gt;&gt;75 영어 &gt;&gt;&gt;100 불합격  (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter5/05-1.실습문제5.1.4.py 국어 &gt;&gt;&gt;55 수학 &gt;&gt;&gt;40 영어 &gt;&gt;&gt;70 합격  (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter5/05-1.실습문제5.1.4.py 국어 &gt;&gt;&gt;1 수학 &gt;&gt;&gt;120 영어 &gt;&gt;&gt;85 잘못 입력하였습니다.        [강의 해설]      두 가지 방법 중 첫번째 방법을 살펴보자.   korean = int(input(\"국어 &gt;&gt;&gt;\")) math = int(input(\"수학 &gt;&gt;&gt;\")) english = int(input(\"영어 &gt;&gt;&gt;\"))  total = korean + match + english avg = total / 3  # 방법 1 if 0 &lt;= korean &lt;= 100 and 0 &lt;= math &lt;= 100 and 0 &lt;= english &lt;= 100:     print(\"입력이 정확함\") else:     print(\"잘못 입력하였습니다.\")         위 함수가 잘 작동하는지 테스트 해보자.   (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter5/05-2.실습문제5.1.4-해설.p y 국어 &gt;&gt;&gt;-1 수학 &gt;&gt;&gt;100 영어 &gt;&gt;&gt;100 잘못 입력하였습니다.  (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter5/05-2.실습문제5.1.4-해설.p y 국어 &gt;&gt;&gt;120 수학 &gt;&gt;&gt;100 영어 &gt;&gt;&gt;100 잘못 입력하였습니다.  (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter5/05-2.실습문제5.1.4-해설.p y 국어 &gt;&gt;&gt;50 수학 &gt;&gt;&gt;60 영어 &gt;&gt;&gt;70 입력이 정확함          if 문 안에 조건문을 넣어(중첩) 80점 이상/미만일 경우 불합격/합격을 출력하자.   korean = int(input(\"국어 &gt;&gt;&gt;\")) math = int(input(\"수학 &gt;&gt;&gt;\")) english = int(input(\"영어 &gt;&gt;&gt;\"))  total = korean + math + english avg = total / 3  # 방법 1 if 0 &lt;= korean &lt;= 100 and 0 &lt;= math &lt;= 100 and 0 &lt;= english &lt;= 100:     if avg &gt;= 80:         print(\"불합격\")     else:         print(\"합격\") else:     print(\"잘못 입력하였습니다.\")           이번에는 중첩문 없이 문제를 풀어보도록 하자.   # 방법 2 if korean &lt;0 or korean &gt; 100 or math &lt;0 or math &gt; 100 or english &lt;0 or english 100:     print(\"잘못 입력하였습니다.\") elif avg &gt;= 80:     print(\"불합격\") else:     print(\"합격\")       본 포스팅은 패스트캠퍼스 환급 챌린지 참여를 위해 작성되었습니다.          패스트캠퍼스 강의 등록하기: https://bit.ly/3L3avNW       #패스트캠퍼스 #패캠챌린지 #직장인인강 #직장인자기계발 #패스트캠퍼스후기 #캐시백챌린지 #캐시백 #환급챌린지 #한번에끝내는파이썬웹개발초격차패키지Online  ","categories": ["Programming"],
        "tags": ["패스트캠퍼스","패캠챌린지","직장인인강","직장인자기계발","패스트캠퍼스후기","캐시백챌린지","캐시백","환급챌린지","한번에끝내는파이썬웹개발초격차패키지Online"],
        "url": "/programming/Python-Day9/",
        "teaser": null
      },{
        "title": "[Linux/Ubuntu]리눅스(Linux) 시간을 한국 표준시(KST)로 변경하기",
        "excerpt":"     1. 리눅스(Linux) 시간을 한국 표준시(KST)로 변경   💡  리눅스의 기본 Timezone은 PDT/UST 이므로 KST로 재설정해주어야 한다.        깃허브 블로그(Github Pages)용으로 VMware Fusion에서 우분투(Ubuntu)를 설치하고 난 뒤, Jekyll과 Git으로 블로그에 포스팅을 진행했다. 하지만 Github에서 표시되는 commit 일시와 실제 commit 일시가 다른 현상이 발생했는데, 확인해보니 Timezone이 한국표준시가 아닌 다른 시간대로 설정되어 생긴 현상이었다.       구글링으로 찾아보니 리눅스를 설치할 때 Timezone을 설정하지 않으면 PDT/UST 등이 기본으로 설정된다고 한다.       시스템 자체에 문제가 생긴 부분은 아니지만 패스트캠퍼스에서 매일 포스팅 업로드 챌린지를 하고 있는데, 나중에 업로드 일자가 문제가 될까 싶어서 아래와 같은 방법으로 Timezone을 KST로 변경해주었다.       참고로 현재 내 환경은 아래와 같다.          MacOS Monterey 12.3.1   VMware Fusion 12.1.2   Ubuntu 20.04           date 명령어를 사용해 현재 시간을 확인한다.            나의 경우에는 PDT(태평양 표준시: Pacific Daylight Time)로 설정되어있었다.            canary@ubuntu:~/myblog/jinnypark9393.github.io$ date  Mon 18 Apr 2022 04:54:58 AM PDT                       현재 Timezone 을 확인한다.        canary@ubuntu:~/myblog/jinnypark9393.github.io$ ls -al /etc/localtime  lrwxrwxrwx 1 root root 39 Apr 13 06:29 /etc/localtime -&gt; /usr/share/zoneinfo/America/Los_Angeles                       Timezone을 한국표준시(KST)로 변경해준다.        canary@ubuntu:~/myblog/jinnypark9393.github.io$ sudo ln -sf /usr/share/zoneinfo/Asia/Seoul /etc/localtime  [sudo] password for canary:                        변경된 Timezone 을 확인한다.        canary@ubuntu:~/myblog/jinnypark9393.github.io$ ls -al /etc/localtime  lrwxrwxrwx 1 root root 30 Apr 18 20:56 /etc/localtime -&gt; /usr/share/zoneinfo/Asia/Seoul                       date로 현재 시간이 제대로 설정되었는지 확인한다.        canary@ubuntu:~/myblog/jinnypark9393.github.io$ date  Mon 18 Apr 2022 08:56:34 PM KST          ","categories": ["DevOps"],
        "tags": ["linux설정","linux","Ubuntu","Ubuntu설정","우분투시간변경","리눅스시간변경","데브옵스엔지니어","DevOps"],
        "url": "/devops/Linux-Ubuntu-Change-Timezone/",
        "teaser": null
      },{
        "title": "[Python]패스트캠퍼스 캐시백 챌린지 10일차",
        "excerpt":"     오늘도 어제에 이어서 “한 번에 끝내는 파이썬 웹 개발 초격차 패키지 Online” 의 챕터 5-4. 리스트 자료형 듣고 정리해보았다. 참고로 이 포스팅은 공부용으로 강의 내용을 요약한 것으로 자세한 강의 내용은 위 링크를 참조 할 것.        아래는 공부 인증 사진.                  4. 리스트 자료형   1. 리스트를 사용하는 이유      10개의 동물 이름 데이터를 저장해야 할 때            animal1 = “사자”       animal2 = “호랑이”       …       animal10 = “강아지”           리스트를 사용하면 한줄의 코드로 작성할 수 있다.            animal = [”사자”, “호랑이”, … “강아지”]                2. 리스트를 만드는 방법      리스트명 = [데이터, 데이터, … , 데이터]   빈 리스트도 만들 수 있다: 리스트명 = []        3. 데이터 접근하기      인덱스를 이용해 몇 번째 데이터인지 알려줄 수 있다.   인덱스는 0부터 시작한다.   animals[n] ⇒ animals[0] = “사자”, animals[1] = “호랑이”        4. 데이터 조작하기      데이터 추가: 리스트.append(데이터)   데이터 할당: 리스트[인덱스] = 데이터   데이터 삭제: del 리스트[인덱스]          예: a = [1, 2, 3]            추가: a.append(4) ⇒ a = [1, 2, 3, 4]       할당: a[0] = 0 ⇒ a = [0, 2, 3, 4]       삭제: del a[1] ⇒ [0, 3, 4]                  슬라이싱: 리스트[시작:끝+1]   리스트 길이: len(리스트)   리스트 정렬: 리스트.sort()          예: b = [3, 4, 2, 1]            슬라이싱: b[1:3] ⇒ [4,2]       길이: len(b) ⇒ 4       정렬: b.sort() ⇒ [1, 2, 3, 4]                5. 실습   # 1. 리스트 만들기 # - 데이터가 있는 리스트 from operator import le  animals = [\"가물치\", \"벼메뚜기\", \"비단뱀\", \"도룡뇽\"]  #  - 데이터가 없는 리스트 empty = []  # 2. 리스트 조작하기  # - 데이터 접근하기 # 인덱스는 0 부터 시작한다. print(animals[2]) print(animals[-1]) # 뒤에서부터 첫번째  # - 데이터 추가하기 animals.append(\"고라니\") print(animals)  # - 데이터 할당하기 # 기존 데이터를 대체 animals[1] = \"청개구리\" print(animals)  # - 데이터 삭제하기 del animals[0] print(animals)  # - 리스트 슬라이싱 print(animals[1:3]) print(animals[:]) # 전체 print(animals[:3]) # 시작 인덱스부터 print(animals[1:]) # 마지막까지  # - 리스트 길이 print(len(animals))  # 리스트 정렬 # 내림차순 정렬 시 animals.sort(reverse=True) animals.sort() print(animals)       본 포스팅은 패스트캠퍼스 환급 챌린지 참여를 위해 작성되었습니다.          패스트캠퍼스 강의 등록하기: https://bit.ly/3L3avNW       #패스트캠퍼스 #패캠챌린지 #직장인인강 #직장인자기계발 #패스트캠퍼스후기 #캐시백챌린지 #캐시백 #환급챌린지 #한번에끝내는파이썬웹개발초격차패키지Online  ","categories": ["Programming"],
        "tags": ["패스트캠퍼스","패캠챌린지","직장인인강","직장인자기계발","패스트캠퍼스후기","캐시백챌린지","캐시백","환급챌린지","한번에끝내는파이썬웹개발초격차패키지Online"],
        "url": "/programming/Python-Day10/",
        "teaser": null
      },{
        "title": "[AWS]AWS Cloud Practitioner 자격증 합격 후기 (비전공자, 독학)",
        "excerpt":"     [AWS]AWS Practitioner 자격증 합격 후기 (비전공자, 독학)   22년 1월 15일 CSPCloud Service Provider: 클라우드 사업자 중 가장 규모가 큰 AWS의 첫 단계 자격증인 Cloud Practitioner 자격증을 취득했다. 787점으로 높은 점수로 통과한 건 아니라 약간 머쓱하지만(ㅎㅎ) 공부방법과 시험 팁들을 공유해보려 한다.               1. AWS 시험 개요   AWS 자격증 시험 단계는 총 세가지로 크게 세 단계로 분류할 수 있다.              공식 사이트의 그림을 살펴보면 기초 &gt; 어소시에이트 &gt; 프로페셔널 세 단계로 분류되어있다. 이 세 단계의 자격증 외에도 각 전문 분야에 해당하는 자격증도 별도로 존재하는데, 내가 이번에 취득하게 된 건 가장 기초가 되는 Cloud Practitioner 자격증.       기본 개념을 망라하는 시험이고 시험 난이도가 크게 높지 않아 클라우드 엔지니어를 희망하는 사람 뿐만 아니라, 클라우드 관련 업계 종사자들도 충분히 볼만한 시험이라고 생각된다.        2. AWS Cloud Practitioner 시험 기본 정보           시험 비용: 100 USD       시험 응시 언어: 영어, 프랑스어, 독일어, 인도네시아어, 이탈리아어, 일본어, 한국어, 포르투갈어, 중국어, 스페인어            우리같은 비영어권 수험자들은 시험 응시언어를 선택하면 시험시간을 30분 추가로 받을 수 있다.       시험 응시언어를 한국어로 선택할 경우에는 30분 추가 시간을 할당받을 수 없다. 다만, 시험을 보는 도중에도 한국어 &amp; 영어 옵션 선택으로 문제를 두 개 언어로 볼 수 있다(하지만 나는 덤프를 영어로만 봤기 때문에 딱히 도움은 되지 않았다 ㅎㅎ).                Testing options: 테스팅 센터 혹은 온라인; Pearson VUE or PSI            문항 수: 65문제       시험 커트라인: 700점/1,000점        3. 시험 요구 수준      AWS 웹사이트에서는 AWS Cloud Pracitioner의 선수 지식으로 6개월간의 실무경험 을 들고 있는데, 이는 필요한 지식 수준을 얘기한 것이고, 증빙 제출 등이 필요한 필수 요건은 아니니 비경험자도 편하게 응시하시면 된다.          AWS Practitioner 시험은 클라우드의 기본 서비스 종류와 개념들을 이해하고 있는지 확인하는 시험으로, 시험 범위 및 출제 비중은 아래와 같다.            AWS 클라우드의 가치 설명       AWS 공동책임 모델 이해 및 설명       보안 모범사례 이해       AWS 클라우드 비용, 경제성 및 결제 관행 이해       컴퓨팅, 네트워크, 데이터베이스, 스토리지를 포함한 핵심 AWS 서비스 설명 및 포지셔닝       일반 사용 사례에 맞는 AWS서비스 식별                  시험 문제는 모두 객관식 으로, 4시선다형과 복수응답형이 혼합되어 출제된다.        4. 공부기간   나는 퇴근 후에 하루 1~2시간 내외로 공부해서 그런지 2주 가량 공부하고 시험을 쳤는데, 클라우드 서비스(특히 IaaS쪽)에 대한 기본 개념이 있는 사람이라면 덤프 위주로 빡세게 준비하면 3~4일이면 볼 듯 하다.        5. 공부 방법      Examtopics (https://www.examtopics.com)            웬만한 IT 시험이 으레 그렇듯 AWS 시험들도 모두 덤프(Dump: 기출문제라고 생각하면 편하다)가 존재한다. AWS 시험에서 가장 자주 쓰이는 덤프사이트는 Examtopics라는 웹사이트로 나는 이번 시험에서 거의 이걸로 공부했었다.       덤프사이트로 공부할 때 주의점은 사이트에 나와있는 답은 오답이 많으니 반드시 Discussion을 확인해야한다 라는 점.       참고로 해당 사이트는 페이지를 넘길때마다 캡차를 풀어줘야하는데, 일정 페이지 수가 넘어가면 로그인을 하라 거나 컨트리뷰션 권한으로 접속해야한다(유료) 라는 메시지가 뜨면서 페이지가 넘어가지 않게 된다. 이럴 때에는 구글 시크릿 모드로 접속하게 되면 페이지를 볼 수 있는데, 페이지 넘어갈 때마다 새 창을 띄우지 않으면 똑같은 메시지가 뜨니 문제를 여러 번 볼 사람은 문제를 카피해놓고 로컬에 저장해서 보는 걸 추천(나는 파일로 만들어서 저장해두고 풀었었다).       나는 덤프를 550번정도까지만 떠놓고 2~3번 정도 풀어보고 갔는데 처음 보는 문제가 25문제 이상 나왔었다(;;). 덤프로만 볼 사람들은 꼭 문제를 끝까지 보고 각 시험 메인 페이지에 떠있는 댓글들도 확인하고 갈 것. 최근 시험 본 사람들이 댓글로 후기를 남겨놓는데, 덤프 적중율은 물론이고 업데이트 된 새로운 문제들도 댓글에 남겨놓는 경우가 있어 도움이 된다.                  Youtube (https://youtu.be/3hLmDS179YE)            내가 공부했던 방법 두번째. 유데미나 다른 긴 강의는 듣고싶지 않아 대충 덤프만 보고 가려다 유투브 알고리즘에 걸려 보게 된 영상. 3시간 짜리 영상인데 간단한 실습과 함께 개념들이 정리되어있다.       물론 이 영상만으로는 시험통과하기는 어려우나 개념 잡기로는 꽤 괜찮았던 영상이라 추천. 실제로 처음 보는 문제들이 나왔을 때 이 강의에서 듣고 이해했던 개념 베이스로 많이 풀었었다(안들었으면 어쩔뻔).       영문 자막이 달려있고 발음이 꽤 깔끔해 영어에 큰 거부감이 없다면 문제가 없을 듯 하지만 영문이 너무 싫으신 분들은 아래 Udemy 강의를 보시는 게 나을 것.                  Udemy (https://www.udemy.com/ko/topic/aws-certified-cloud-practitioner/)            해외 벤더사에서 주관하는 IT 관련 자격증을 준비해본 분이라면 모를 수 없는 사이트인 유데미(Udemy). 이번에 웅진씽크빅과 전략적 파트너십을 맺게되어 한글 번역본이 꽤나 많이 나오고 있다.       Cloud Practitioner도 한국어 자막 버전이 출시되어 있으니 영어 자료를 보기 부담스러워 하시는 분들이시면 추천. 나는 Practitioner 시험인데 굳이 돈들이고 공부해야하나 라는 거만한 마음(반성합니다)으로 듣지 않았지만 들으신 분들은 도움 많이 받으신 듯 하다.       정가는 생각보다 가격대가 있는데 할인 받으면 커피 일주일 참는 정도로 너끈히 낼 수 있는 가격이다. (유데미 수강하시는 할인은 창을 켤 때마다 랜덤하게 갱신 되니 시크릿 창으로 띄워보다 할인이 적용될 때 사면 된다는 팁을 들었었던 기억이 있는데 확실하진 않음.)                  AWS 공인 교육 (https://aws.amazon.com/ko/training/digital/aws-cloud-practitioner-essentials/?cp=sec&amp;sec=prep)            AWS에서도 공인 교육 코스를 준비해놓고 있었는데 시험 후기에서 이 강의를 듣고 준비했다는 분들은 많이 않은 듯 해 나는 패스했었다.                6. 수험료 할인 방법   AWS는 제일 잘 팔리는 솔루션이라 그런지 GCP(Google Cloud Platform) 이나 Microsoft Azure 처럼 시험 할인 바우처를 호락호락하게(?) 주지는 않는 편. AWS 자격증 시험에 합격하게 되면 50% 할인 바우처가 나오게 되는데, Cloud Practitioner는 가장 초급 단계의 시험이기 때문에 이런 바우처를 거의 쓸 수 없다.       다만, 가끔 열리는 세미나에서 50% 할인 바우처를 나눠주기도 하니 잘 살펴보도록 하자. 나는 IT 자격증 AWS GCP Azure NCP 아무말 이라는 오픈카톡에서 AWS 클라우드 로드쇼 AWS 자격증 챌린지 두 개 이벤트를 알게 되어 이벤트 참여 시 나눠주는 Practitioner &amp; SAA 50% 바우처(시험 공부를 미루고 미루다 SAA 바우처는 결국 날렸다 ㅎ)를 활용해 이번 시험을 신청했었다.        7. 시험 신청과 결과 확인      시험 신청            AWS Training 웹사이트에서 (aws.training/Certification) 가능하다. 회원가입 필수.       시험 취소 &amp; 시험 일정변경은 시험 시간 24시간 전까지 가능. 기간 제한이 있는 바우처의 경우 바우처 유효기간 내에만 변경이 가능하니 참고하시길.       Pearson VUE / PSI 두 개 옵션이 있는데 나는 PSI로 봤었다. 별 이유는 없고 스케쥴이 나한테 맞는 걸로 열려있어서 선택했었음.                  시험 장소            시험은 테스팅 센터 혹은 온라인시험으로 볼 수 있는데, 내가 신청했을 때에는 테스팅 센터가 타임슬롯이 없어 온라인 시험으로 신청했었다.       온라인으로 봤을 때의 시험 준비물은 여권, 그리고 모니터가 없고 다른 사람이 들어오지 않는 조용한 방이 필요하다.                    수험 전 시험용 설치프로그램 및 시스템 호환성 체크를 진행해야하는데, 시험 당일 하려고 하면 갑작스럽게 문제가 생길 때 엄청 당황되니 시험 전날 쯤 미리 설치 및 체크를 완료해 두는 것이 좋다.           이어폰은 착용할 수 없으니 노트북 스피커를 이용해야한다.           시험 보기 전 감독관이 방 내부 및 책상 위를 체크하는데, 나는 미리 다 치워놔서 그런지 딴지를 걸거나 하지는 않고 바로 끝났다.                                  시험 결과            시험을 끝낸 뒤 설문조사를 마치면 바로 합격 여부를 확인할 수 있다.       합격 통지 메일은 당일 및 2~3일내 발송되며, 득점 내역(Score report) 및 자격증 PDF는 자격증 사이트에서 확인 및 다운로드 할 수 있다.           ","categories": ["Cloud"],
        "tags": ["AWS자격증","클라우드자격증","클라우드엔지니어","AWSCLF","AWSCloudPractitioner 데브옵스엔지니어","DevOps"],
        "url": "/cloud/AWS-Cloud-Practitioner/",
        "teaser": null
      },{
        "title": "[Python]패스트캠퍼스 캐시백 챌린지 11일차",
        "excerpt":"     오늘도 어제에 이어서 “한 번에 끝내는 파이썬 웹 개발 초격차 패키지 Online” 의 챕터 5-5. 리스트 자료형 실습문제를 듣고 정리해보았다. 참고로 이 포스팅은 공부용으로 강의 내용을 요약한 것으로 자세한 강의 내용은 위 링크를 참조 할 것.        아래는 공부 인증 사진.                  5. 리스트 자료형 실습문제   1. 실습문제 5.2.1      다음은 패스트 고등학교 2학년 3반 1번부터 5번까지의 1분간 팔굽혀펴기 개수이다. 데이터는 각 리스트에 저장되어있다. 각 문항을 실행한 결과를 출력해보자.            result = [33, 40, 12, 63, 52]               [내 풀이]   문항 1. 6번의 팔굽혀펴기 개수는 9개이다. 리스트의 마지막에 추가하자.   result = [33, 40, 12, 63, 52]  # 문항 1 result.append(9) print(result)          출력결과   (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter5/07-1.실습문제5.2.1.py [33, 40, 12, 63, 52, 9]       문항 2. 2번은 재측정하여 50개를 하였다. 2번의 데이터를 변경해보자.   result = [33, 40, 12, 63, 52]  result[1] = 50 print(result)          출력 결과   (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter5/07-1.실습문제5.2.1.py [33, 50, 12, 63, 52, 9]       문항 3. 3번부터 6번까지 데이터를 슬라이싱하자.   result = [33, 40, 12, 63, 52]  print(result[2:6])          출력 결과   (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter5/07-1.실습문제5.2.1.py [12, 63, 52, 9]       문항 4. 모든 데이터를 오름차순으로 정렬하자.   result = [33, 40, 12, 63, 52]  result.sort() print(result)          출력결과   (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter5/07-1.실습문제5.2.1.py [9, 12, 33, 50, 52, 63]        [강의 해설]   문항 1. 6번의 팔굽혀펴기 개수는 9개이다. 리스트의 마지막에 추가하자.   # 실습문제 5.2.1 result = [33, 40, 12, 63, 52]  # 문항 1 result.append(9) print(result)       문항 2. 2번은 재측정하여 50개를 하였다. 2번의 데이터를 변경해보자.   # 문항 2 result[1] = 50 print(result)       문항 3. 3번부터 6번까지 데이터를 슬라이싱하자.   # 문항 3 print(result[2:6])       문항 4. 모든 데이터를 오름차순으로 정렬하자.   # 문항 4 result.sort() print(result)        2. 실습문제 5.2.2      턱걸이 평균 측정 프로그램을 만들어보자. 먼저, 턱걸이 횟수를 저장할 빈 리스트를 만든다. 그리고 일주일간의 턱걸이 횟수를 입력 받아 리스트에 저장한다. 리스트에 저장된 데이터의 평균을 구해 출력한다.   표준입력            1일차 턱걸이 횟수 &gt;&gt;&gt; 20       2일차 턱걸이 횟수 &gt;&gt;&gt; 23       3일차 턱걸이 횟수 &gt;&gt;&gt; 16       4일차 턱걸이 횟수 &gt;&gt;&gt; 14       5일차 턱걸이 횟수 &gt;&gt;&gt; 24       6일차 턱걸이 횟수 &gt;&gt;&gt; 27       7일차 턱걸이 횟수 &gt;&gt;&gt; 30           표준 출력: 22        [내 풀이]   # 빈 리스트 만들기 week = []  # 반복문 사용해 1일차부터 7일차까지 값 입력받기 i = 0 for i in range(0,7):     i = i + 1     day = int(input(\"%d일차 턱걸이 횟수 &gt;&gt;&gt;\" % i))     week.append(day)     print(week)  # 리스트 요소를 모두 더한 값 구하기 total = sum(week)  # 평균값 = 리스트 요소를 모두 더한 값 / 리스트 요소 개수 # 계산된 평균값을 정수형으로 변경해준다(기본 출력 float). average = int(total/len(week)) print(int(average))          출력 결과   (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter5/08-1.실습문제5.2.2.py 1일차 턱걸이 횟수 &gt;&gt;&gt;20 [20] 2일차 턱걸이 횟수 &gt;&gt;&gt;23 [20, 23] 3일차 턱걸이 횟수 &gt;&gt;&gt;16 [20, 23, 16] 4일차 턱걸이 횟수 &gt;&gt;&gt;14 [20, 23, 16, 14] 5일차 턱걸이 횟수 &gt;&gt;&gt;24 [20, 23, 16, 14, 24] 6일차 턱걸이 횟수 &gt;&gt;&gt;27 [20, 23, 16, 14, 24, 27] 7일차 턱걸이 횟수 &gt;&gt;&gt;30 [20, 23, 16, 14, 24, 27, 30] 22        [강의 해설]   # 실습 5.2.2  data = [] # 빈 리스트 생성  x = int(input(\"1일차 턱걸이 횟수 &gt;&gt;&gt;\")) data.append(x) x = int(input(\"2일차 턱걸이 횟수 &gt;&gt;&gt;\")) data.append(x) x = int(input(\"3일차 턱걸이 횟수 &gt;&gt;&gt;\")) data.append(x) x = int(input(\"4일차 턱걸이 횟수 &gt;&gt;&gt;\")) data.append(x) x = int(input(\"5일차 턱걸이 횟수 &gt;&gt;&gt;\")) data.append(x) x = int(input(\"6일차 턱걸이 횟수 &gt;&gt;&gt;\")) data.append(x) x = int(input(\"7일차 턱걸이 횟수 &gt;&gt;&gt;\")) data.append(x)  total = data[0] + data[1] + data[2] + data[3] + data[4] + data[5] + data[6] + data[7] avg = total / 7  print(avg)          위의 코드를 실행하면 아래와 같이 인덱스 에러가 발생한다.   IndexError: list index out of range          인덱스 중 범위를 벗어난 경우 발생: data[7] 삭제해준다.   # 실습 5.2.2  data = [] # 빈 리스트 생성  x = int(input(\"1일차 턱걸이 횟수 &gt;&gt;&gt;\")) data.append(x) x = int(input(\"2일차 턱걸이 횟수 &gt;&gt;&gt;\")) data.append(x) x = int(input(\"3일차 턱걸이 횟수 &gt;&gt;&gt;\")) data.append(x) x = int(input(\"4일차 턱걸이 횟수 &gt;&gt;&gt;\")) data.append(x) x = int(input(\"5일차 턱걸이 횟수 &gt;&gt;&gt;\")) data.append(x) x = int(input(\"6일차 턱걸이 횟수 &gt;&gt;&gt;\")) data.append(x) x = int(input(\"7일차 턱걸이 횟수 &gt;&gt;&gt;\")) data.append(x)  total = data[0] + data[1] + data[2] + data[3] + data[4] + data[5] + data[6] avg = total / 7  print(int(avg))          출력된 평균값이 float형이기 때문에 int로 변경해준다.        본 포스팅은 패스트캠퍼스 환급 챌린지 참여를 위해 작성되었습니다.          패스트캠퍼스 강의 등록하기: https://bit.ly/3L3avNW       #패스트캠퍼스 #패캠챌린지 #직장인인강 #직장인자기계발 #패스트캠퍼스후기 #캐시백챌린지 #캐시백 #환급챌린지 #한번에끝내는파이썬웹개발초격차패키지Online  ","categories": ["Programming"],
        "tags": ["패스트캠퍼스","패캠챌린지","직장인인강","직장인자기계발","패스트캠퍼스후기","캐시백챌린지","캐시백","환급챌린지","한번에끝내는파이썬웹개발초격차패키지Online"],
        "url": "/programming/Python-Day11/",
        "teaser": null
      },{
        "title": "[Python]패스트캠퍼스 캐시백 챌린지 12일차",
        "excerpt":"     오늘도 어제에 이어서 “한 번에 끝내는 파이썬 웹 개발 초격차 패키지 Online” 의 챕터 5-6. 반복문 개념(1)을 듣고 정리해보았다. 참고로 이 포스팅은 공부용으로 강의 내용을 요약한 것으로 자세한 강의 내용은 위 링크를 참조 할 것.        아래는 공부 인증 사진.                  6. 반복문 개념(1)   1. 반복문을 사용하는 이유      반복적인 작업을 코드로 작성하기 위해 사용.       data = [] # 빈 리스트 생성  # 1 ~ 7일차까지 반복 작업 x = int(input(\"1일차 턱걸이 횟수 &gt;&gt;&gt;\")) data.append(x) x = int(input(\"2일차 턱걸이 횟수 &gt;&gt;&gt;\")) data.append(x) x = int(input(\"3일차 턱걸이 횟수 &gt;&gt;&gt;\")) data.append(x) x = int(input(\"4일차 턱걸이 횟수 &gt;&gt;&gt;\")) data.append(x) x = int(input(\"5일차 턱걸이 횟수 &gt;&gt;&gt;\")) data.append(x) x = int(input(\"6일차 턱걸이 횟수 &gt;&gt;&gt;\")) data.append(x) x = int(input(\"7일차 턱걸이 횟수 &gt;&gt;&gt;\")) data.append(x)  total = data[0] + data[1] + data[2] + data[3] + data[4] + data[5] + data[6] avg = total / 7  print(int(avg))          위의 코드를 반복문으로 축약해보자.   for i in range(1, 101):     x = int(input(i, \"일차 턱걸이 횟수 &gt;&gt;&gt;\"))     data.append(x)        2. 시퀀스 자료형(Sequence Data Type)      순서가 있는 자료형            리스트       문자열       range 객체       튜플, 딕셔너리                3. for 사용법   for 변수 in 시퀀스 자료:     명령문  # 예시 for a in [1, 2, 3, 4]:     print(a)          동작 방식            리스트 자료 안에 있는 첫번째 값인 1이 a에 저장       명령문을 실행: print(a) ⇒ print(1) ⇒ 1 이 출력       두번째 값인 2를 a에 저장       명령문을 실행: print(a) ⇒ print(2) ⇒ 2 가 출력       리스트에 더 이상 데이터가 없을 때까지 반복                4. range 명령어   range(10) # 0~9까지 숫자를 포함하는 range 객체를 만들어준다.        5. 실습   # 반복문 # : 반복해서 명령을 사용하고 싶을 때  # 시퀀스 자료형 # : 순서가 있는 자료형 # 1. 리스트 # 2. 문자열 # 3. range 객체 # 4. 튜플 # 5. 딕셔너리  # for 문 # - 리스트 사용 champions = [\"티모\", \"이즈리얼\", \"리신\"]  for champion in champions:     print(\"선택한 챔피언은\", champion, \"입니다.\")               리스트는 복수형태로 작성하고 변수는 단수형태로 많이 사용            출력 결과물       (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter5/09.반복문개념_for.py 선택한 챔피언은 티모 입니다. 선택한 챔피언은 이즈리얼 입니다. 선택한 챔피언은 리신 입니다.          문자열 사용   # - 문자열 사용 fighting_message = \"자신감을 가지자! 나에게 한계란 없다!\"  for word in fighting_message:     print(word)          결과 출력   (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter5/09.반복문개념_for.py 자 신 감 을   가 지 자 !   나 에 게   한 계 란   없 다 !          range 객체를 사용해보자.   # - range 객체 사용 # range(10) -&gt; 0~9까지 숫자를 포함하는 Range 객체가 나온다. 0,1,2,3,4,5,6,7,8,9 for i in range(10):     print(i)          결과 출력   # (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter5/09.반복문개념_for.py 0 1 2 3 4 5 6 7 8 9          range 응용   # - range 객체 사용 # range(10) -&gt; 0~9까지 숫자를 포함하는 Range 객체가 나온다. 0,1,2,3,4,5,6,7,8,9 # range(시작, 끝+1, 단계) for i in range(1,10, 2):     print(i)          결과 출력   # (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter5/09.반복문개념_for.py 1 3 5 7 9      이번 포스팅에서는 반복문 기초 개념에 대해서 알아보았다. 다음 포스팅에서도 이어서 반복문 개념에 대해 알아보자.        본 포스팅은 패스트캠퍼스 환급 챌린지 참여를 위해 작성되었습니다.          패스트캠퍼스 강의 등록하기: https://bit.ly/3L3avNW       #패스트캠퍼스 #패캠챌린지 #직장인인강 #직장인자기계발 #패스트캠퍼스후기 #캐시백챌린지 #캐시백 #환급챌린지 #한번에끝내는파이썬웹개발초격차패키지Online  ","categories": ["Programming"],
        "tags": ["패스트캠퍼스","패캠챌린지","직장인인강","직장인자기계발","패스트캠퍼스후기","캐시백챌린지","캐시백","환급챌린지","한번에끝내는파이썬웹개발초격차패키지Online"],
        "url": "/programming/Python-Day12/",
        "teaser": null
      },{
        "title": "[Python]패스트캠퍼스 캐시백 챌린지 13일차",
        "excerpt":"     오늘도 어제에 이어서 “한 번에 끝내는 파이썬 웹 개발 초격차 패키지 Online” 의 챕터 5-6. 반복문 개념(2)를 듣고 정리해보았다. 참고로 이 포스팅은 공부용으로 강의 내용을 요약한 것으로 자세한 강의 내용은 위 링크를 참조 할 것.        아래는 공부 인증 사진.                  7. 반복문 개념(2)   1. while 사용법      for와의 차이점은?            for문 : 반복할 횟수가 정해져 있을 때       while문: 반복할 횟수가 정해져있지 않을 때                  while 사용법   # 초기식 # while 조건식: #     반복할 명령 #     증감식  i = 0 while i &lt;10:     print(i, \"번째 다짐, 나는 할 수 있다!\")     i += 1 # 복합할당연산자 i + 1 = i      i = 0 : 반복문에 사용되는 변수의 값을 지정   while i &lt; 10: : 반복에 대한 조건 체크. 이 식이 false가 될 때까지 반복.   증감식 : 반복하는 작업을 위해 변수값 증가.        2. 무한루프와 break   # while True: #    반복할 명령 #    if 조건식: #        break  while True:     x = input(\"종료하려면 exit을 입력하세요 &gt;&gt;&gt;\")     if x == \"exit\":         break       조건식 대신 불리언(Boolean) 값을 불러온다.   참일 경우 break를 만나기 전까지 명령을 계속 반복한다. (가장 가까운 반복문만 빠져나오게 됨)        3. 실습   # while # : 보통 반복횟수가 정해지지 않았을 때 사용한다.  i = 5 # 초기식 while i &lt; 9: # 조건식     print(i, \"번째 다짐, 나는 할 수 있다!\")     i += 1 # 증감식          출력 결과   (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter5/10.반복문개념_while.py 5 번째 다짐, 나는 할 수 있다! 6 번째 다짐, 나는 할 수 있다! 7 번째 다짐, 나는 할 수 있다! 8 번째 다짐, 나는 할 수 있다!      # while # : 보통 반복횟수가 정해지지 않았을 때 사용한다.  i = 0 # 초기식 while i &lt; 10: # 조건식     print(i, \"번째 다짐, 나는 할 수 있다!\")     i += 2 # 증감식          결과 출력   (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter5/10.반복문개념_while.py 0 번째 다짐, 나는 할 수 있다! 2 번째 다짐, 나는 할 수 있다! 4 번째 다짐, 나는 할 수 있다! 6 번째 다짐, 나는 할 수 있다! 8 번째 다짐, 나는 할 수 있다!       # 무한루프 # : 조건식에 True를 넣어서 항상 반복되게 만든 것.  while True:     x = input(\"종료하려면 exit을 입력하세요 &gt;&gt;&gt;\")     if x == \"exit\":         break          출력 결과   (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter5/10.반복문개념_while.py 종료하려면 exit을 입력하세요 &gt;&gt;&gt;exid 종료하려면 exit을 입력하세요 &gt;&gt;&gt;a 종료하려면 exit을 입력하세요 &gt;&gt;&gt;b 종료하려면 exit을 입력하세요 &gt;&gt;&gt;c 종료하려면 exit을 입력하세요 &gt;&gt;&gt;d 종료하려면 exit을 입력하세요 &gt;&gt;&gt;e 종료하려면 exit을 입력하세요 &gt;&gt;&gt;f 종료하려면 exit을 입력하세요 &gt;&gt;&gt;exit       이번 포스팅에서는 반복문 개념에 대해서 알아보았다. 다음 포스팅에서는 반복문 실습문제를 풀어보도록 하자.        본 포스팅은 패스트캠퍼스 환급 챌린지 참여를 위해 작성되었습니다.          패스트캠퍼스 강의 등록하기: https://bit.ly/3L3avNW       #패스트캠퍼스 #패캠챌린지 #직장인인강 #직장인자기계발 #패스트캠퍼스후기 #캐시백챌린지 #캐시백 #환급챌린지 #한번에끝내는파이썬웹개발초격차패키지Online  ","categories": ["Programming"],
        "tags": ["패스트캠퍼스","패캠챌린지","직장인인강","직장인자기계발","패스트캠퍼스후기","캐시백챌린지","캐시백","환급챌린지","한번에끝내는파이썬웹개발초격차패키지Online"],
        "url": "/programming/Python-Day13/",
        "teaser": null
      },{
        "title": "[Github Pages/Blog]포스팅 게시 안됨 이슈 해결",
        "excerpt":"     1.[Github Pages/Blog]포스팅 게시 안됨 이슈 해결       💡  Github Pages에 포스팅이 게시가 안될 경우, 올바른 포스팅 파일 이름규칙, future=true, published=true 옵션을 적용해보자.        1. 에러 상황   패스트캠퍼스 챌린지 Day3 포스팅을 작성한 뒤, 깃헙 블로그 레파지토리에 push 를 했음에도 불구하고 github 블로그에 해당 페이지가 올라오지 않는 이슈가 있었다.       원래 Github에 코드를 push한 뒤, 실제 페이지에 반영되기까지 빠르면 1~2분, 길게는 30분까지도 걸린다고는 하지만 내 포스팅은 1시간이 넘도록 올라오지 않았다.       참고로 내 환경은 다음과 같다.      MacOS Monterey 12.3.1   VMware Fusion 12.1.2   Ubuntu 20.04   Git 2.25.1        2. 해결 방법   ‘깃허브 블로그 포스팅 안됨 에러’ 키워드로 구글링 하다가 세 가지 방법을 시도해봤는데, 나에게는 그 중 마지막 방법인 published: true 설정이 유효했다.       1. 포스팅의 Naming Convention 지키기   Github Pages의 경우, 포스트의 네이밍 컨벤션이 YYYY-MM-DD-포스팅-제목.md 로 정해져있고, 이를 어길 시에는 포스팅이 제대로 올라가지 않는다.       참고로 이 파일명을 가지고 Jekyll에서 페이지를 생성하게 되면, http://username.github.io/YYYY/MM/DD/category/포스팅-제목 형태로 url이 생성된다.       따라서 아래 두 가지를 반드시 유의해야한다.      포스팅 제목 맨 앞에 YYYY-MM-DD 형태로 날짜를 입력했는가   포스팅 파일명은 해당 깃허브 저장소의 _posts 디렉토리 내에서 반드시 유일해야한다.       나는 이 내용을 몰랐지만 post 폴더 내의 파일을 관리할 때 우연히 YYYY-MM-DD 형태로 파일 이름을 설정했던 터라 다행히도(?) 이 부분은 수정할 필요가 없었다.        2. _config.yaml 파일에 future: true 추가   구글링을 해보니 config.yaml 파일에 future: true 를 추가해보라는 글이 있어서 추가해보았으나 나에게는 효과가 없었다.       future: true 옵션은 현재 시스템 시간보다 더 뒤의 일자로 포스팅 발행일을 선택했을 때 (예를 들어 시스템 시간은 2022년 4월 28일이나 포스팅 발행일을 2022년 4월 29일로 입력) 포스팅이 올라가도록 허용해주는 옵션이다.       예상컨대 나와 같이 가상머신 환경에서 가상머신의 Timezone이 한국보다 늦은 경우, 시차때문에 일자에 오류가 생길 경우에는 유효할 듯 하지만, 나는 이미 가상머신과 실제 Timezone을 맞춰놨기 때문에 그러한 오류는 발생하지 않았다.        3. 포스팅 내에 published: true 옵션 추가 (유효)   마지막으로 내가 작성한 포스팅의 정보란에 published: true 로 설정해 발행 여부를 명시할 수 있는데, 나의 경우에는 이 옵션이 유효했다.       아래는 내가 수정했던 마크다운 파일 일부를 발췌한 것이다.   --- published: true title:  \"[Python]패스트캠퍼스 캐시백 챌린지 3일차\" excerpt: \"패스트캠퍼스 캐시백 챌린지 3일차: 한 번에 끝내는 파이썬 웹개발 초격차 패키지 Online\"  categories:   - Programming tags:   - [패스트캠퍼스, 패캠챌린지, 직장인인강, 직장인자기계발, 패스트캠퍼스후기, 캐시백챌린지, 캐시백, 환급챌린지, 한번에끝내는파이썬웹개발초격차패키지Online]  toc: true toc_sticky: true   date: 2022-04-20 last_modified_at: 2022-04-20 ---  (이하 포스팅 내용)       이후에는 같은 문제가 발생할까 걱정되어 미리 published: true 옵션을 기본으로 넣은 채로 포스팅 문서를 작성하고 있는데, 이 이후에는 같은 문제가 발생하지 않았다.  ","categories": ["Github Blog"],
        "tags": ["GithubBlog","GithubPages","깃허브블로그","깃헙블로그","깃허브블로그에러","깃허브블로그포스팅에러","깃허브블로그포스팅안됨","개발자블로그","엔지니어블로그"],
        "url": "/github%20blog/Github-Blog-cannot-upload-a-post/",
        "teaser": null
      },{
        "title": "[Kubernetes]쿠버네티스 네트워킹(1)스위칭 & 라우팅",
        "excerpt":"        💡  쿠버네티스 네트워킹을 알아보기에 앞서 리눅스 머신에서의 스위칭 &amp; 라우팅에 대해 알아보자. *       1. 스위칭         컴퓨터 A와 B가 통신하기 위해서는 각 컴퓨터(호스트)에 물리, 혹은 가상 인터페이스가 필요하다.               각 리눅스 머신(=컴퓨터), 스위치에  IP 주소를 할당하자.         # 스위치에 ip 주소 할당   ip addr add 192.168.1.0/24        # 컴퓨터 A   ip addr add 192.168.1.10/24 dev eth0        # 컴퓨터 B   ip addr add 192.168.1.11/24 dev eth0                  A, B는 같은 네트워크 안에 있으므로, 스위치를 통해 서로 통신할 수 있다.            컴퓨터 A(192.168.1.10)에서 컴퓨터 B(192.168.1.11)로 통신 가능       컴퓨터 B(192.168.1.11)에서 컴퓨터 A(192.168.1.10)로 통신 가능                2. 라우팅   1. 다른 네트워크에 존재하는 머신과 통신           컴퓨터 A &amp; B와 다른 네트워크에 컴퓨터 C &amp; D 가 존재할 때, 컴퓨터 A, B에서 어떻게 시스템 C, D로 도달하게 될까?              ⇒ 라우터가 필요!                   라우터(Router): 다른 네트워크를 연결하는 장치                     라우터가 각 네트워크와 연결 될 수 있도록 아래의 IP를 할당                    192.168.1.1 (A, B와 같은 네트워크)           192.168.2.1 (C, D와 같은 네트워크)                                       A, B와 C,D가 통신 할 수 있도록 각 컴퓨터에 게이트웨이(Gateway)를 설정                     각 컴퓨터(A, B, C, D)에서 route 커맨드를 실행해 게이트웨이를 설정                예시             # A, B의 설정   # 192.168.2.0 번대 네트워크로 가는 요청은 192.168.1.1 으로 보낸다.   ip route add 192.168.2.0/24 via 192.168.1.1            # C, D의 설정   # 192.168.1.0 번대 네트워크로 가는 요청은 192.168.2.1 으로 보낸다.   ip route add 192.168.1.0/24 via 192.168.2.1                       설정 완료 후, route 커맨드로 설정 내역을 확인할 수 있다.                 2. 인터넷과의 통신           시스템을 인터넷(172.217.194.0/24)에 연결하려면?                     A,B - C,D 네트워크를 연결했을 경우와 마찬가지로 Gateway를 통해 목적지에 연결하는 루트 추가       A, B 설정: ip route add 172.217.194.0/24 via 192.168.1.1       C, D 설정: ip route add 172.217.194.0/24 via 192.168.2.1                 3. 라우팅 테이블에 존재하지 않는 IP와의 통신           컴퓨터의 라우팅 테이블에 등록되지 않아 경로를 알 수 없는 IP와의 통신을 할 경우에는 어떻게 설정?       ⇒ 디폴트 게이트웨이(Default Gateway)              설정 방법은 아래 둘 중 하나            ip route add default via 192.168.2.1       ip route add 0.0.0.0 via 192.168.2.1                 3. 리눅스 머신을 라우터로 사용      라우터, 스위치 대신 리눅스 머신을 네트워크 장비처럼 사용할 수 있다.   라우터 설정과 동일하게 라우터가 되는 리눅스 머신에서 IP 설정   머신 A, B 에서 각각 Gateway IP 설정         A와 B가 통신이 가능할까?            불가능하다.       리눅스에서는 기본적으로 패킷을 한 인터페이스에서 다른 인터페이스로 전달하지 않으므로, 명시적으로 정의해야하기 때문.                  라우터 역할을 하는 머신에서 설정값을 확인해보자: cat /proc/sys/net/ipv4/ip_forward            기본 설정값은 0(포워딩하지 않음)       포워딩을 허용하는 설정값은 1                  네트워크 패킷을 전달하도록 수정:  echo 1 &gt; /proc/sys/net/ipv4/ip_forward            위의 설정은 재부팅시 초기화된다.                  재부팅 이후에도 설정값을 유지하도록 하려면 etc/sysctl.conf 파일의 net.ipv4..ip_forward = 1 설정값을 넣어주어야 한다.         3. 유용한 리눅스 명령어들      ip link : 호스트의 인터페이스를 나열 및 수정   ip addr : 해당 인터페이스에 할당된 IP 주소를 확인   ip addr add 192.168.1.10/24 dev eth0 : 인터페이스에 IP를 설정하는데에 사용   변경사항을 부팅 후에도 유지하려면 /etc/network/interfaces 파일을 수정해야한다.   ip route route : 라우팅 테이블 확인   ip route add 192.168.1.0/24 via 192.168.2.1: 라우팅 테이블에 항목 추가   cat /proc/sys/net/ipv4/ip_forward : 호스트에서 IP전달이 활성화 되어있는지 확인(0은 전달 불가. 1은 전달 가능)   이번 포스팅에서는 쿠버네티스 네트워킹의 기본이 되는 스위칭, 라우팅, 그리고 리눅스 머신에서의 라우팅에 대해서 알아보았다. 다음 포스팅에서는 DNS에 대해 알아보도록 하자.  ","categories": ["DevOps"],
        "tags": ["쿠버네티스","쿠버네티스네트워킹","라우팅기초","스위칭기초","kubernetes","kubernetesnetworking","k8s","DevOpsengineer","데브옵스","데브옵스엔지니어"],
        "url": "/devops/Kubernetes-Networking-Swtiching-Routing/",
        "teaser": null
      },{
        "title": "[Python]패스트캠퍼스 캐시백 챌린지 14일차",
        "excerpt":"     오늘도 어제에 이어서 “한 번에 끝내는 파이썬 웹 개발 초격차 패키지 Online” 의 챕터 5-6. 반복문 실습문제(1)을 듣고 정리해보았다. 참고로 이 포스팅은 공부용으로 강의 내용을 요약한 것으로 자세한 강의 내용은 위 링크를 참조 할 것.        아래는 공부 인증 사진.                  8. 반복문 실습문제(1)   1. 실습문제 5.3.1      구구단 출력 프로그램을 만들어보자. 프로그램 사용자로부터 출력할 단을 입력 받고, 해당 구구단을 출력하는 프로그램이다.   표준입력: 몇 단을 출력할까요? &gt;&gt;&gt; 5   표준출력            5 * 1 = 5       5 * 2 = 10       …       5 * 9 =45               [내 풀이]   # 단 입력 받기 # 입력값 * 1 ~ 9 까지 반복 곱셈  multiple = int(input(\"몇 단을 출력할까요? &gt;&gt;&gt; \"))  i = 1 while i &lt; 10:     print(multiple, \"*\", i, \"=\", multiple * i)     i += 1          출력 결과   (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter5/11.실습문제5.3.1.py 몇 단을 출력할까요? &gt;&gt;&gt; 5 5 * 1 = 5 5 * 2 = 10 5 * 3 = 15 5 * 4 = 20 5 * 5 = 25 5 * 6 = 30 5 * 7 = 35 5 * 8 = 40 5 * 9 = 45       [강의 해설]      for ~ in 구문과 range를 이용해 함수를 작성해보자.   # 바뀌는 부분을 잘 살펴보자. # 실습문제 5.3.1 # 구구단 출력하기  x = int(input(\"몇 단을 출력할까요? &gt;&gt;&gt;\"))  for i in range(10):     print(i)          출력 확인   (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter5/11.실습문제5.3.1-해설.py 몇 단을 출력할까요? &gt;&gt;&gt;1 0 1 2 3 4 5 6 7 8 9      0 ~ 9 까지가 출력된다.          Range의 시작값(=1) 을 넣어준다.   # 실습문제 5.3.1 # 구구단 출력하기  x = int(input(\"몇 단을 출력할까요? &gt;&gt;&gt;\"))  for i in range(1, 10):     print(i)          출력 확인   (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter5/11.실습문제5.3.1-해설.py 몇 단을 출력할까요? &gt;&gt;&gt;1 1 2 3 4 5 6 7 8 9      1 ~ 9 까지가 출력된다.          구구단 모양으로 출력해주자.   # 실습문제 5.3.1 # 구구단 출력하기  x = int(input(\"몇 단을 출력할까요? &gt;&gt;&gt;\"))  for i in range(1, 10):     print(x, \"*\", i, \"=\", x*i)          출력 확인   (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter5/11.실습문제5.3.1-해설.py 몇 단을 출력할까요? &gt;&gt;&gt;5 5 * 1 = 5 5 * 2 = 10 5 * 3 = 15 5 * 4 = 20 5 * 5 = 25 5 * 6 = 30 5 * 7 = 35 5 * 8 = 40 5 * 9 = 45        2. 실습문제 5.3.2      패스트게임즈에 인턴으로 근무하게 된 종현. 사수에게 과제로 게임 메뉴 만들기를 받았다. 과제 내용은 다음과 같았다.   과제            숫자 1 입력: “게임을 시작합니다” 출력       숫자 2 입력: “실시간 랭킹” 출력       숫자 3 입력: “게임을 종료합니다” 출력 후 프로그램 종료       단, 3을 입력할때까지 프로그램은 계속 실행된다. 1 ~ 3 외 다른 숫자를 입력한 경우 “다시 입력해주세요”를 출력               [내  풀이]   # while True 사용 # if elif else 사용  while True:     x = int(input(\"[메뉴를 입력하세요]\\n 1. 게임시작 2. 랭킹보기 3. 게임종료 &gt;&gt;&gt;\"))     if x == 1:         print(\"-&gt;게임을 시작합니다\")     elif x == 2:         print(\"-&gt;실시간 랭킹\")     elif x == 3:         print(\"-&gt;게임을 종료합니다\")         break     else:         print(\"-&gt;다시 입력해 주세요\")      파이썬 문자열 줄바꿈 ⇒ \\n 문자 삽입          출력 결과   (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter5/12-1.실습문제5.3.2.py [메뉴를 입력하세요]  1. 게임시작 2. 랭킹보기 3. 게임종료 &gt;&gt;&gt;1 -&gt;게임을 시작합니다 [메뉴를 입력하세요]  1. 게임시작 2. 랭킹보기 3. 게임종료 &gt;&gt;&gt;2 -&gt;실시간 랭킹 [메뉴를 입력하세요]  1. 게임시작 2. 랭킹보기 3. 게임종료 &gt;&gt;&gt;4 -&gt;다시 입력해 주세요 [메뉴를 입력하세요]  1. 게임시작 2. 랭킹보기 3. 게임종료 &gt;&gt;&gt;5 -&gt;다시 입력해 주세요 [메뉴를 입력하세요]  1. 게임시작 2. 랭킹보기 3. 게임종료 &gt;&gt;&gt;3 -&gt;게임을 종료합니다       [강의 해설]   # 몇 번 반복 될 지 모를 때 = while # 무한 반복 =&gt; while True: # 반복문 탈출 =&gt; break # 조건문 =&gt; while 문 안에 작성  # 실습문제 5.3.2 # 게임 메뉴 개발하기  while True:     print(\"[메뉴를 입력하세요]\")     select = int(input(\"1. 게임시작 2. 랭킹보기 3. 게임종료 &gt;&gt;&gt;\"))      if select == 1:         print(\"-&gt; 게임을 시작합니다\")     elif select == 2:         print(\"-&gt; 실시간 랭킹\")     elif select == 3:         print(\"-&gt; 게임을 종료합니다\")         break     else:         print(\"-&gt; 다시 입력해 주세요\")          출력 결과   (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter5/12-2.실습문제5.3.2-해설.p y [메뉴를 입력하세요] 1. 게임시작 2. 랭킹보기 3. 게임종료 &gt;&gt;&gt;1 -&gt; 게임을 시작합니다 [메뉴를 입력하세요] 1. 게임시작 2. 랭킹보기 3. 게임종료 &gt;&gt;&gt;2 -&gt; 실시간 랭킹 [메뉴를 입력하세요] 1. 게임시작 2. 랭킹보기 3. 게임종료 &gt;&gt;&gt;4 -&gt; 다시 입력해 주세요 [메뉴를 입력하세요] 1. 게임시작 2. 랭킹보기 3. 게임종료 &gt;&gt;&gt;5 -&gt; 다시 입력해 주세요 [메뉴를 입력하세요] 1. 게임시작 2. 랭킹보기 3. 게임종료 &gt;&gt;&gt;3 -&gt; 게임을 종료합니다       이번 포스팅에서는 반복문 실습문제를 풀어보았다. 다음 포스팅에서는 반복문 실습문제(2)를 풀어보도록 하자.        본 포스팅은 패스트캠퍼스 환급 챌린지 참여를 위해 작성되었습니다.          패스트캠퍼스 강의 등록하기: https://bit.ly/3L3avNW       #패스트캠퍼스 #패캠챌린지 #직장인인강 #직장인자기계발 #패스트캠퍼스후기 #캐시백챌린지 #캐시백 #환급챌린지 #한번에끝내는파이썬웹개발초격차패키지Online  ","categories": ["Programming"],
        "tags": ["패스트캠퍼스","패캠챌린지","직장인인강","직장인자기계발","패스트캠퍼스후기","캐시백챌린지","캐시백","환급챌린지","한번에끝내는파이썬웹개발초격차패키지Online"],
        "url": "/programming/Python-Day14/",
        "teaser": null
      },{
        "title": "[Kubernetes]쿠버네티스 네트워킹(2)DNS & CoreDNS",
        "excerpt":"     1. DNS(Domain Name System)   1. DNS란?   지난 포스팅에서 들었던 시스템 A, B의 예시를 다시 살펴보자.   만약 시스템 A에서 시스템 B에 접속할 때, 192.168.1.11 라는 IP 대신 DB 라는 이름/별칭을 사용하고 싶다면 어떻게 해야할까?         시스템 A /etc/hosts 에 192.168.1.11 db 를 등록하면 된다.   단 주의할 사항은, 시스템 B의 실제 호스팅명(시스템 B에서 hostname 명령어로 확인할 수 있다)이 실제로 db가 아니라 host-2와 같이 다른 이름일 경우에도 db 로 접속이 된다는 점이다.   이처럼 DNS는 IP주소를 사람이 읽을 수 있는 도메인명으로 바꿔주는 시스템을 뜻한다.   2. Name Resolution   위의 예와 같이, 호스트에서 /hosts 파일 내에 DNS명과 IP명을 읽고 변환하는 작업을 Name Resolution 이라고 한다.   오늘날에는 환경이 커지고 너무 많은 항목이 생겨서 파일을 관리하기가 어렵기 때문에, 해당 정보를 한개의 단일 서버로 관리하게 되는데, 이 서버를 DNS 서버이다.   그렇다면, 각 호스트(컴퓨터)가 DNS 서버를 가리키게 하려면 어떻게 해야할까?         모든 호스트에는 /etc/resolv.conf 라는 DNS resolution 구성 파일이 존재한다.   따라서, A 서버의 resolv.conf 파일에 nameserver 192.168.1.100 를 등록하면 네임서버(DNS서버)를 향하게 된다.   단, 테스트 목적 등으로 사용할 경우, 이전처럼 etc/hosts 에 등록하여 사용할 수 있다.   만약, A 서버의 hosts 파일에 192.168.1.115 IP 서버를 test 로 등록하고, DNS 서버에도 같은 호스트 이름으로 다른 IP를 등록한 경우에는 어떻게 될까?         호스트는 먼저 로컬의 hosts 파일에 등록된 내역을 찾은 뒤, DNS 서버에 쿼리하게 된다.   따라서, A 서버에서 test로 통신요청을 보낸 경우, hosts 파일에 등록된 192.168.1.115 서버가 응답하게 된다.   참고로, 파일을 읽는 순서는 /etc/nsswitch.conf 파일에서 정의된다.   만약 로컬 &amp; DNS 서버 모두 모르는 호스트명이 있을 경우, Ping이 실패하게 되는데, 그럴 경우에는 public nameserver를 DNS서버에 등록하면 된다(로컬 hosts 파일에 등록해도 적용되나 모든 호스트에 하나하나 적용을 해야하기 때문에 DNS 서버에 등록하는 것이 효율적).   3. Domain Names   인터넷을 하다보면, www.google.com , www.naver.com , www.kubernetes.io 등의 주소를 볼 수 있는데, 이 이름들이 바로 도메인명(Domain Name)이다.   1. Domain Name 구조         . 으로 구분 된 것은 비슷한 것들끼리 묶어서 보기 편하게 분류하려고 한 것.   최상위 도메인 종류(Top Level Domain Name)            .com: 상업적 / 일반 목적       .net : 네트워크       .edu : 교육기관       .org : 비영리기관       .io : 영국령 인도양식민지(British Indian Ocean Territory)의 국가 톱 레벨 도메인           Domain name 구조            . : root       .com : 탑 레벨 도메인 네임       google : 구글에 할당된 도메인 이름       www : 하위 도메인 (기타 예: drive, maps, apps, mail 등)           apps.google.com 에 접속            본인이 속한 조직의 DNS 서버에 도착       ⇒ 리스트에 없으니 Root DNS로 전송       ⇒ 요청을 확인하고 .com DNS 서버로 전송       ⇒ 요청을 확인하고 google DNS 서버로 전송: IP 제공           → 조직의 DNS 서버는 일정기간(일반적으로 몇 초)동안 해당 IP를 캐시       4. Search Domain      회사에서 mydomain.com이라는 도메인과 nfs, web, mail, drive 등의 서브도메인을 운영        외부에서 접속할 때에는 web.mydomain.com으로 접속       ⇒ 내부에서도 web이 아닌 web.mydomain.com       [mydomain.com](http://mydomain.com) 같은 서치 도메인을 조직 내에서 생략하고 싶을 경우       ⇒ /etc/resolv.conf 에 search [mycompany.com](http://mycompany.com) 을 등록하면 앞의 web만 검색해도 web.mycompany.com 으로 연결됨 (두 개이상 등록도 가능함: 두개 사이에 공백을 넣어주면 됨)       5. 레코드 타입   | A | web-server | 192.168.1.1 | | — | — | — | | AAAA | web-server | 2001:0db8:85a3:0000:0000:8a2e:0370:7334 | | CNAME | food.web-server | eat.web-server, hungry.web-server |     A record: 호스트 이름에 IP 저장   AAAA record: IPv6를 저장   CNAME: 호스트네임을 다른 호스트네임과 매핑   6. DNS 조회 도구들   1. nslookup      nslookup [www.google.com](http://www.google.com)   Nslookup은 로컬 hosts 파일을 조회하지 않고 DNS 서버만 조회하게 됨   2. Dig      dig www.google.com   Nslookup보다 더 많은 정보 제공   2. CoreDNS      Core DNS 설치방법            Github 릴리스 페이지 혹은 도커 이미지로 다운로드 할 수 있음.                    Wget 혹은 curl           압축 해제           ./coredns 로 실행           기본 포트(53 포트)에서 수신대기           CoreDNS는 Corefile에서 구성 로딩                            Corefile에 hosts /etc/hosts 구문을 넣어 hosts 파일을 가져오도록 지시                                                   CoreDNS는 플러그인을 통해 DNS항목을 구성할 수도 있다(쿠버네티스용 플러그인도 존재)  ","categories": ["DevOps"],
        "tags": ["쿠버네티스","쿠버네티스네트워킹","DNS","CoreDNS","kubernetes","kubernetesnetworking","k8s","DevOpsengineer","데브옵스","데브옵스엔지니어"],
        "url": "/devops/Kubernetes-Networking-DNS-CoreDNS/",
        "teaser": null
      },{
        "title": "[Python]패스트캠퍼스 캐시백 챌린지 15일차",
        "excerpt":"     오늘도 어제에 이어서 “한 번에 끝내는 파이썬 웹 개발 초격차 패키지 Online” 의 챕터 5-6. 반복문 실습문제(2)을 듣고 정리해보았다. 참고로 이 포스팅은 공부용으로 강의 내용을 요약한 것으로 자세한 강의 내용은 위 링크를 참조 할 것.        아래는 공부 인증 사진.                  9. 반복문 실습문제(2)   1. 실습문제 5.3.3      성민은 패스트대학교에 Lily 라는 이름의 교환학생과 친해지게 되었다. 영어를 잘 하지 못했던 성민은, Lily에게 한국어를 가르쳐주기 위해 한국어 연습 프로그램을 만들게 되었다.               Learning Korean -     1. 연습할 한국어가 담긴 리스트를 만든다.     2. 리스트에서 순서대로 단어를 가져와 화면에 출력한다.     3. 프로그램 사용자는 단어를 그대로 입력하고     4. 맞추면 다음 단어를 가져온다. 틀리면 프로그램 종료.                  결과 화면   Let's Learning Korean 사랑해 사랑해 귀엽다 귀엽다 고마워 고마워 행복해 행복해        [내 풀이] - 실패      리스트를 만들어 준 뒤, while 구문으로 리스트가 끝날 때까지 반복구문을 생성   input 값과 print 된 값이 일치하지 않을 때(틀릴때) 프로그램 종료   # 리스트 만들기 =&gt; [] # 리스트 순서대로 단어를 가져와 화면에 출력 =&gt; print # 사용자는 단어를 그대로 입력 =&gt; input # 맞추면 다음 단어를 가져온다. =&gt; if # 틀리면 프로그램 종료 =&gt; while True &amp; break  korean = [\"사랑해\", \"귀엽다\", \"고마워\", \"행복해\"]  print(\"Let's Learning Korean\")  i = 0 while i &lt; len(korean):     x = print(korean[i])     y = input(\"\")     if x == y:         i += 1     else:         break          출력 결과: print된 문자열과 동일하게 입력했으나 프로그램이 종료되는 현상이 발생했다.            for in 문으로 바꿀 경우에는 break가 되지 않는 현상이 발생함       for in 문 사용해야함       불필요한 변수를 사용해 조건문이 적용이 잘 되지 않아 발생한 오류           (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter5/14-1.실습문제5.3.4.py Let's Learning Korean 사랑해 사랑해 (myvenv) ➜  python_basic        [강의 해설]      리스트 생성   시퀀스 자료형 ⇒ for in 문 사용   print로 리스트에 담긴 word들을 출력해보자.   # 실습문제 5.3.3 # Learning Korean  # 한국어 리스트 word_list = [\"사랑해\", \"귀엽다\", \"고마워\", \"행복해\"]  print(\"Let's Learning Korean\")  for word in word_list:     print(word)          출력 결과   (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter5/14-2.실습문제5.3.4-해설.p y Let's Learning Korean 사랑해 귀엽다 고마워 행복해          입력값을 받아줄 수 있도록 input()을 생성한다.   # 실습문제 5.3.3 # Learning Korean  # 한국어 리스트 word_list = [\"사랑해\", \"귀엽다\", \"고마워\", \"행복해\"]  print(\"Let's Learning Korean\")  for word in word_list:     print(word)     data = input()          출력 결과            입력값을 받을 때까지 기다린다.       틀린 값을 받아도 실행이 된다.           (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter5/14-2.실습문제5.3.4-해설.p y Let's Learning Korean 사랑해 사랑해 귀엽다 ㅇㅇㅇ 고마워          화면에 출력된 값(word)와 입력된 값(data)가 일치하지 않을 경우 프로그램이 종료되도록 If 문과 break를 입력해준다.   # 실습문제 5.3.3 # Learning Korean  # 한국어 리스트 word_list = [\"사랑해\", \"귀엽다\", \"고마워\", \"행복해\"]  print(\"Let's Learning Korean\")  for word in word_list:     print(word)     data = input()     if data != word:         break               출력 결과         (myvenv) ➜  python_basic /Users/usr/Documents/pyt   hon_basic/myvenv/bin/python /Users/usr/Documents/   python_basic/myvenv/Chapter5/14-2.실습문제5.3.4-해설.p   y   Let's Learning Korean   사랑해   사랑해   귀엽다   귀여워                코드 업그레이드 과제      실습문제 5.3.4 에서 문제를 틀릴 경우 프로그램을 종료하지 않고 전체 문제 개수, 맞힌 문제 개수, 틀린 문제 개수를 출력하게 한다.            전체 문제 개수: 4 개       맞힌 문제 개수: 2 개       틀린 문제 개수: 2 개               [내 풀이]      점수를 담을 변수를 각각 선언해준 뒤,   정답일 경우 correct += 1, 오답일 경우 incorrect +=1 하도록 조건을 달아주었다.   # 실습문제 5.3.3 # Learning Korean  # 한국어 리스트 word_list = [\"사랑해\", \"귀엽다\", \"고마워\", \"행복해\"]  print(\"Let's Learning Korean\")  # 각 변수를 선언한 뒤, 초기값을 선언해준다. total = len(word_list) incorrect = 0 correct = 0  for word in word_list:     print(word)     data = input()     if data != word:         # 문제를 틀릴 경우 틀린 개수 +1         incorrect += 1     else:         # 문제를 맞출 경우 맞춘 개수 +1         correct += 1  # 전체 문제 개수: 4 개 # 맞힌 문제 개수: 2 개 # 틀린 문제 개수: 2 개 (break 하지 않음) print(\"전체 문제 개수:\", total, \" 개\") print(\"맞힌 문제 개수:\", correct, \" 개\") print(\"틀린 문제 개수:\", incorrect, \" 개\")          출력 결과   (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter5/14-2.실습문제5.3.4-해설.p y Let's Learning Korean 사랑해 사랑해 귀엽다 귀엽다 고마워 곰 아워 행복해 행볶해 전체 문제 개수: 4  개 맞힌 문제 개수: 2  개 틀린 문제 개수: 2  개        [강의 해설]   # 실습문제 5.3.4 # Learning Korean ver 2.0  # 한국어 리스트 word_list = [\"사랑해\", \"귀엽다\", \"고마워\", \"행복해\"]  # 점수 score = 0  print(\"Let's Learning Korean\")  for word in word_list:     print(word)     data = input()     if data == word: # 정답일 경우         score += 1 # 점수를 1 증가  print(\"전체 문제 개수 : \", len(word_list)) print(\"맞힌 개수 : \", score) print(\"틀린 개수 : \", len(word_list) - score)  # 전체 문제 개수: 4 개 # 맞힌 문제 개수: 2 개 # 틀린 문제 개수: 2 개      점수 변수를 하나만 선언해 활용했다.          출력 결과   (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter5/14-2.실습문제5.3.4-해설.p y Let's Learning Korean 사랑해 사랑해 귀엽다 귀엽다 고마워 고맙 행복해 행복 전체 문제 개수 :  4 맞힌 개수 :  2 틀린 개수 :  2       이번 포스팅에서는 반복문 실습문제를 풀어보았다. 다음 포스팅에서는 반복문 실습문제(2)를 풀어보도록 하자.        본 포스팅은 패스트캠퍼스 환급 챌린지 참여를 위해 작성되었습니다.      패스트캠퍼스 강의 등록하기: https://bit.ly/3L3avNW   #패스트캠퍼스 #패캠챌린지 #직장인인강 #직장인자기계발 #패스트캠퍼스후기 #캐시백챌린지 #캐시백 #환급챌린지 #한번에끝내는파이썬웹개발초격차패키지Online  ","categories": ["Programming"],
        "tags": ["패스트캠퍼스","패캠챌린지","직장인인강","직장인자기계발","패스트캠퍼스후기","캐시백챌린지","캐시백","환급챌린지","한번에끝내는파이썬웹개발초격차패키지Online"],
        "url": "/programming/Python-Day15/",
        "teaser": null
      },{
        "title": "[Kubernetes]쿠버네티스 네트워킹(3)Linux Namespaces",
        "excerpt":"     💡  쿠버네티스 네트워킹을 알아보기에 앞서 리눅스의 네임스페이스에 대해 알아보자.       1. Linux Namespaces   1. 네임스페이스      호스트 안의 격리된 공간(집 안에 방이 있는 것과 같음): 컨테이너를 생성할 때 컨테이너를 격리해 다른 컨테이너가 표시되지 않도록 하고 싶은 경우   네임스페이스 안의 컨테이너 ⇒ 자기자신만 볼 수 있음   Underlying (기본) 호스트: 모든 프로세스를 볼 수 있음            ps aux 로 확인할 수 있음 ⇒ 네임스페이스 내부/외부에서 같은 프로세스지만 PID가 상이하게 됨       호스트                    LAN에 연결하는 인터페이스 존재           라우팅 테이블           ARP 테이블: IP - MAC 주소 일대일 대응한 테이블                   ⇒ 컨테이너에서 위 세부사항을 보이지 않게 하고 싶다면?                          네임스페이스 내에 컨테이너 생성 시 호스트에 대한 네트워크 정보에 대한 가시성 없어짐            네임스페이스는 자체 가상 인터페이스(veth) 및 라우팅 테이블/ARP 테이블을 가질 수 있음                2. 네트워크 네임스페이스 생성      ip netns add red   ip netns add blue   ip netns   ip link : host 의 인터페이스 확인   ip netns exec red ip link : 네임스페이스의 인터페이스 확인 (= ip -n red link )        3. 네트워크 네임스페이스 안에서 실행      arp : 호스트에서의 항목들 출력        ip netns exec red arp : 컨테이너에서의 항목들 출력       route : 호스트에서의 라우팅 테이블 출력        ip netns exec red route : 컨테이너에서의 라우팅 테이블 출력       2개의 다른 네임스페이스간의 통신: 가상 이더넷 페어 혹은 가상 케이블(=파이프)            ip link add veth-red type veth peer name veth-blue       ip link set veth-red netns red &amp; ip link set veth-blue netns blue       IP 할당                    ip -n red addr add 192.168.15.1 dev veth-red           ip -n blue addr add 192.168.15.2 dev veth-blue                       IP 링크 업                    ip -n red link set veth-red up           ip -n blue link set veth-blue up                       테스트                    ip netns exec red ping 192.168.15.2           ip netns exec red arp           ip netns exec blue arp                            상대방의 mac/ip주소 표시                                   arp : host 의 arp 테이블                            네임스페이스 내의 정보 없음                                                          가상 스위치 생성            가상 스위치 생성하고 네임스페이스 연결                    Linux Bridge / Open vSwitch를 통해 생성 가능                                  Linux Bridge            ip link add v-net-0 type bridge : 호스트에 ip 인터페이스를 추가 ( ip link 로 확인할 수 있음)       ip link set dev v-net-0 up : 네트워크 링크 활성화       기존 직접연결 링크 삭제                    ip -n red link del veth-red: 한쪽 링크 삭제하면 다른쪽 링크 자동 삭제됨                       ip link add veth-red type veth peer name vth-red-br       ip link add veth-blue type veth peer name vth-blue-br       ip link set veth-red netns red                    ip link set veth-red-br master v-net-0 : v-net-0(스위치)에 veth-red-br 인터페이스 연결           ip -n red addr add 192.168.15.1 dev veth-red : IP 주소 연결           ip -n red link set veth-red up: 인터페이스 링크 활성화                       ip link set veth-blue netns blue                    ip link set veth-blue-br master v-net-0: v-net-0(스위치)에 veth-blue-br 인터페이스 연결           ip -n blue addr add 192.168.15.2 dev veth-blue : IP주소 연결           ip -n blue link set veth-blue up: 인터페이스 링크 활성화                                  호스트와 네임스페이스간 연결            브리지스위치: 호스틑의 네트워크 인터페이스 중 하나       ip addr add 192.168.15.5/24 dev v-net-0 : 호스트 IP 추가       로컬 호스트에서 네임스페이스 연결                  호스트 바깥과 통신            Blue namespace ⇒ 호스트 바깥 망(192.168.1.3)                    ip netns exec blue ping 192.168.1.3 ⇒ 도달하지 않음 ( ip netns exec blue route 확인해보면 등록되지 않았음)           라우팅 테이블에 항목을 추가해 외부에 대한 게이트웨이 제공해야함                            ip netns exec blue ip route add 192.168.1.0/24 via 192.168.15.5 등록                                    192.168.15.5 : v-net-0                   Ping이 가지만 돌아오지 않음                                                           ⇒ NAT 을 구성해야함                              iptables -t nat -A POSTROUTING -s 192.168.15.0/2 -j MASQUERADE                                                          인터넷에 연결            ip netns exec blue ip route add default via 192.168.15.5                    0.0.0.0 주소가 v-net-0를 통해 가도록 게이트웨이 구성                                  외부에서 네임스페이스로 통신            외부 호스트에 Namespace의 IP 라우팅 등록: 192.168.15.5(v-net-0) via 192.168.1.2(eth0)       iptables -t nat -A PREROUTING —dport 80 —to-destination 192.168.15.2:80 -j DNAT          ","categories": ["DevOps"],
        "tags": ["쿠버네티스","쿠버네티스네트워킹","리눅스네임스페이스","네트워크네임스페이스","네임스페이스","cka","kubernetes","kubernetesnetworking","k8s","DevOpsengineer","데브옵스","데브옵스엔지니어"],
        "url": "/devops/Kubernetes-Networking-3-Linux-Namespaces/",
        "teaser": null
      },{
        "title": "[Kubernetes]쿠버네티스 네트워킹(4)Container Networking",
        "excerpt":"     💡  쿠버네티스 네트워킹을 알아보기에 앞서 컨테이너 네트워킹에 대해 알아보자.       1. Container Networking      도커 컨테이너를 띄운 호스트            호스트 eth0: 192.168.1.10                  도커 컨테이너 네트워킹 옵션 3가지            None network: docker run —network none nginx                    컨테이너 외부 접속 불가 &amp; 외부에서 컨테이너 접속 불가                       Host network: docker run —network host nginx                    호스트와 컨테이너의 네트워크가 격리되지 않음           추가 포트 매핑 불필요                            포트 80에 어플리케이션을 배포 ⇒ http://192.168.1.10:80 에서 애플리케이션 접속 가능               단, 다른 컨테이너에서 동일 포트로 애플리케이션을 배포할 경우 작동하지 않음                                               Bridge network           1. Bridge network      내부 사설망이 형성됨 (Bridge network: 172.0.0 - container a 172.17.0.2, container b 172.12.0.3)   Docker가 호스트에 설치                     기본적으로 Bridge 라는 내부 사설 네트워크 생성 (docker network ls 커맨드를 통해 확인할 수 있음)              ⇒ 호스트에 docker0(=v-net-0)라는 이름으로 네트워크 생성( ip link로 확인 가능)               Docker0 ⇒ down state       Docker0: 172.17.0.1 할당 ( ip addr로 확인 가능)       네임스페이스 확인                    ip netns           docker inspect 942d70e5785b2           컨테이너(172.17.0.3) = 네트워크 네임스페이스           도커는 위에서 했던것과 같이 컨테이너에 eth@ifOO, bridge 네트워크에 veth@ifOO 인터페이스를 생성해 케이블로 연결(뒤에있는 ifOO가 서로 쌍이 된다)           브릿지 네트워크 밑에 있는 컨테이너들 ⇒ 같은 네트워크이기 때문에 통신 가능           예: http://172.17.0.3:80 ⇒ 애플리케이션 실행 가능           하지만 외부에서 같은 주소로 접속했을 경우 접속 불가                               2. 호스트 외부에서 도커 컨테이너를 접속          Docker: Port publishing / Port Mapping            docker run -p 8080:80 nginx 호스트의 8080 포트로 들어온 요청을 80포트로 전달 ⇒ 외부에서 http://172.17.0.3:8080 : 접속 가능            어떻게 8080 포트에서 80 포트로 트래픽 전달?             NAT 규칙 생성             iptables \\       -t nat \\       -A PREROUTING \\       -j DNAT \\       --dport 8080 \\       --to-destination 80             iptables \\   \t-t nat \\   \t-A DOCKER \\   \t-j DNAT \\   \t--dport 8080 \\   \t--to-destination 172.17.0.3:80           ⇒ iptables -nvL -t nat 으로 확인할 수 있음      ","categories": ["DevOps"],
        "tags": ["쿠버네티스","쿠버네티스네트워킹","dockernetworking","containernetworking","도커네트워킹","컨테이너네트워킹","cka","kubernetes","kubernetesnetworking","k8s","DevOpsengineer","데브옵스","데브옵스엔지니어"],
        "url": "/devops/Kubernetes-Networking-4-Container-Networking/",
        "teaser": null
      },{
        "title": "[Python]패스트캠퍼스 캐시백 챌린지 16일차",
        "excerpt":"     오늘도 어제에 이어서 “한 번에 끝내는 파이썬 웹 개발 초격차 패키지 Online” 의 챕터 6-1. 함수개념을 듣고 정리해보았다. 참고로 이 포스팅은 공부용으로 강의 내용을 요약한 것으로 자세한 강의 내용은 위 링크를 참조 할 것.        아래는 공부 인증 사진.                  1. 함수 개념      재사용성이 좋아지고   유지보수가 편리해지고   가독성이 좋아진다       1. 함수 개념      함수를 사용하지 않은 경우   # 함수를 사용하지 않은 경우 print(\"안녕하세요, 동준님\") print(\"현재 프리미엄서비스 사용기간이 30일 남았습니다.\")  print(\"안녕하세요. 현식님\") print(\"현재 프리미엄 서비스 사용기간이 15일 남았습니다.\")  print(\"안녕하세요. 원준님\") print(\"현재 프리미엄 서비스 사용기간이 7일 남았습니다.\")          함수를 사용한 경우: printMessage라는 함수를 정의   # 함수를 사용한 경우 def printMessage(name, date):     print(\"안녕하세요.\", name, \"님\")     print(\"현재 프리미엄 서비스 사용기간이 \", date, \"일 남았습니다.\")  printMessage(\"동준\", 30) printMessage(\"현식\", 15) printMessage(\"원준\", 7)       1. 재사용성: 코드를 다시 사용할 때 얼마나 간편한가           함수를 사용하지 않은 경우         # 함수를 사용하지 않은 경우   print(\"안녕하세요, 동준님\")   print(\"현재 프리미엄서비스 사용기간이 30일 남았습니다.\")        print(\"안녕하세요. 현식님\")   print(\"현재 프리미엄 서비스 사용기간이 15일 남았습니다.\")        print(\"안녕하세요. 원준님\")   print(\"현재 프리미엄 서비스 사용기간이 7일 남았습니다.\")        print(\"안녕하세요. 길동님\")   print(\"현재 프리미엄 서비스 사용기간이 7일 남았습니다.\")                  함수를 복사 붙여넣기 한 뒤       직접 타이핑해 이름과 남은 일자를 적어준다.                       함수를 사용한 경우         # 함수를 사용한 경우   def printMessage(name, date):       print(\"안녕하세요.\", name, \"님\")       print(\"현재 프리미엄 서비스 사용기간이 \", date, \"일 남았습니다.\")        printMessage(\"동준\", 30)   printMessage(\"현식\", 15)   printMessage(\"원준\", 7)   printMessage(\"길동\", 7)                  함수 호출 부분만 적어주고 이름과 남은 기간만 넘겨주면 된다.                2. 유지보수성: 코드를 수정할 때 얼마나 간편한가           함수를 사용하지 않은 경우         # 함수를 사용하지 않은 경우   print(\"안녕하세요, 동준님\")   print(\"현재 프리미엄서비스 사용기간이 30일 남았습니다.\")        print(\"안녕하세요. 현식님\")   print(\"현재 프리미엄 서비스 사용기간이 15일 남았습니다.\")        print(\"안녕하세요. 원준님\")   print(\"현재 프리미엄 서비스 사용기간이 7일 남았습니다.\")        print(\"안녕하세요. 길동님\")   print(\"현재 프리미엄 서비스 사용기간이 7일 남았습니다.\")                  모든 부분을 하나하나 찾아 직접 바꿔주어야 한다.                       함수를 사용한 경우         printMessage(\"동준\", 30)   printMessage(\"현식\", 15)   printMessage(\"원준\", 7)   printMessage(\"길동\", 7)                  함수는 그대로 두고 호출 부분만 바꿔주면 된다.       보기 쉽고, 찾기 쉽다.                3. 가독성: 코드를 읽고 이해하기 쉽다.           함수를 사용하지 않은 경우         # 함수를 사용하지 않은 경우   print(\"안녕하세요, 동준님\")   print(\"현재 프리미엄서비스 사용기간이 30일 남았습니다.\")        print(\"안녕하세요. 현식님\")   print(\"현재 프리미엄 서비스 사용기간이 15일 남았습니다.\")        print(\"안녕하세요. 원준님\")   print(\"현재 프리미엄 서비스 사용기간이 7일 남았습니다.\")        print(\"안녕하세요. 길동님\")   print(\"현재 프리미엄 서비스 사용기간이 7일 남았습니다.\")                  코드가 길어져 이해하기 쉽지 않다.                       함수를 사용한 경우         # 함수를 사용한 경우   def printMessage(name, date):       print(\"안녕하세요.\", name, \"님\")       print(\"현재 프리미엄 서비스 사용기간이 \", date, \"일 남았습니다.\")        printMessage(\"동준\", 30)   printMessage(\"현식\", 15)   printMessage(\"원준\", 7)   printMessage(\"길동\", 7)                  코드가 간결해 이해하기 쉽다.                2. 함수의 기본 형태   # 정의하기(define) def 함수이름():     명령블록  # 호출하기 함수이름()          예시   def printHello():     print(\"Hello\")  printHello()      Hello를 출력하는 함수를 생성한 뒤, 호출.        3. 매개변수가 있는 함수   # 정의하기 def 함수이름(매개변수1, 매개변수2):     명령블록  # 호출하기 함수이름(인자1, 인자2)      매개변수: 함수 안에서 쓰일 데이터를 받는 역할 ( , 로 구분된다)   인자: 매개변수 안에 들어갈 데이터          예시   # 정의하기  def sum(a, b):     print(a + b)  # 호출하기 sum(3, 4)      화면에 7이 출력된다.        4. 반환값이 있는 함수   # 정의하기 def 함수이름():     명령블록     return 반환값  # 호출하기 함수이름()          예시   # 정의하기 def getRandomNumber():     number = random.randint(1,10)     return number  # 호출하기 getRandomNumber()        5. 매개변수와 반환값이 있는 함수   # 정의하기 def 함수이름(매개변수1, 매개변수2):     명령블록     return 반환값  # 호출하기 함수이름(인자1, 인자2)          예시   # 정의하기 def sum(a, b):     result = a + b     return result  # 호출하기 sum(3, 4)      화면에 7이 출력되지 않고 sum에 7 값이 저장된다.        6. 실습   1. 기본형   # 기본형 # 1. 정의하기 def printHello():     print(\"Hello\")  # 2. 호출하기 printHello()          출력 결과   (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter6/02.함수실습.py Hello        2. 매개변수가 있는 함수   # 매개변수가 있는 함수 def sum(a, b):     print(a + b)  sum(3, 4)          출력 결과   (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter6/02.함수실습.py 7        3. 반환값이 있는 함수   # 반환값이 있는 함수 import random # random 모듈을 호출 def getRandomNumber():     number = random.randint(1, 10)     return number  print(getRandomNumber())          출력 결과   (myvenv) ➜  python_basic /Users/jinipark/Documents/pyt hon_basic/myvenv/bin/python /Users/jinipark/Documents/ python_basic/myvenv/Chapter6/02.함수실습.py 5        4. 매개변수와 반환값이 있는 함수   # 매개변수와 반환값이 있는 함수 def add(a, b):     result = a + b     return result  print(add(5, 6))          출력 결과   (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter6/02.함수실습.py 11       이번 포스팅에서는 함수 개념을 정리해보았다. 다음 포스팅에서는 함수 실습문제(1)를 풀어보도록 하자.        본 포스팅은 패스트캠퍼스 환급 챌린지 참여를 위해 작성되었습니다.          패스트캠퍼스 강의 등록하기: https://bit.ly/3L3avNW       #패스트캠퍼스 #패캠챌린지 #직장인인강 #직장인자기계발 #패스트캠퍼스후기 #캐시백챌린지 #캐시백 #환급챌린지 #한번에끝내는파이썬웹개발초격차패키지Online  ","categories": ["Programming"],
        "tags": ["패스트캠퍼스","패캠챌린지","직장인인강","직장인자기계발","패스트캠퍼스후기","캐시백챌린지","캐시백","환급챌린지","한번에끝내는파이썬웹개발초격차패키지Online"],
        "url": "/programming/Python-Day16/",
        "teaser": null
      },{
        "title": "[Python]패스트캠퍼스 캐시백 챌린지 17일차",
        "excerpt":"     오늘도 어제에 이어서 “한 번에 끝내는 파이썬 웹 개발 초격차 패키지 Online” 의 챕터 6-2. 함수 실습문제(1)를 듣고 정리해보았다. 참고로 이 포스팅은 공부용으로 강의 내용을 요약한 것으로 자세한 강의 내용은 위 링크를 참조 할 것.        아래는 공부 인증 사진.                  02. 함수실습문제(1)   1. 실습문제 6.1.1      다음은 두 수의 곱셈을 반환하는 multiply 함수이다. multiply 함수를 호출하는 방법으로 옳은 것을 고르세요.       ```python def multiply(x, y):     result = x * y     return result    ```  1. multiply() 2. multiply(3) 3. multiply(3, 4) 4. multiply(”a”, “b”)        [내 풀이]      정답은 3. multiply(3, 4)   def multiply(x, y):     result = x * y     return result  print(multiply(3, 4))          출력 결과   (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter6/03-1.실습문제6.1.1.py 12        [강의 해설]           1.multiply() 실행결과         multiply()   TypeError: multiply() missing 2 required positional arguments: 'x' and 'y'                  x, y 매개변수에 해당하는 인자가 필요하다는 에러 메시지 발생                       2.multiply(1) 실행결과         multiply(1)   TypeError: multiply() missing 1 required positional argument: 'y'                  1번과 동일한 에러 발생                       3.multiply(3, 4) 실행결과         (myvenv) ➜  python_basic /Users/usr/Documents/python_basic/myvenv/bin/python /Users/usr/Documents/   python_basic/myvenv/Chapter6/03-2.실습문제6.1.1-해설.py                  에러 발생하지 않음(Print를 입력하지 않아 연산 결과는 화면에 표시되지 않음)                       4.multiply(”3”, ”4”) 실행결과         result = x * y   TypeError: can't multiply sequence by non-int of type 'str'                문자열은 곱셈 연산이 불가능하다            Tip: docstring: 설명문             “”” 쌍따옴표 세개로 감싸진 문장. IDE에서 함수에 커서를 가져다 대면 docstring에서 기입한 설명문이 표시된다.             # docstring : 설명문        def multiply(x, y):       \"\"\"       두 수의 곱셈 결과를 반환하는 함수       매개변수 x : 숫자       매개변수 y : 숫자       \"\"\"       result = x * y       return result        multiply(\"3\", \"4\")                2. 실습문제 6.1.2      다음은 세개의 정수를 인자로 받아, 합계와 평균을 출력해주는 함수이다. 함수를 호출한 결과로 표준 출력이 나오도록 함수를 정의해보자.   def printSumAvg(x, y, z): # 이하 수강생 작성  # 함수호출 printSumAvg(10, 20, 30)  # 표준 출력 # 합계: 60 평균: 20        [내 풀이]   def printSumAvg(x, y, z):     sum = x + y + z     avg = int(sum / 3)     return print(\"합계:\", sum, \"평균:\", avg)  printSumAvg(10, 20, 30)      return은 불필요함          출력 결과   (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter6/04-2.실습문제6.1.2.p y 합계: 60 평균: 20        [강의 해설]   # 실습문제 6.1.2  # 문자열 포매팅 def printSumAvg(x, y, z):     \"\"\"     세개의 숫자를 받아 합계와 평균을 출력하는 함수     \"\"\"     sum = x + y + z     avg = sum / 3     print(f\"합계 : {sum}, 평균: {avg}\")  printSumAvg(10, 20, 30)      Tip: 문자열과 변수를 번갈아 입력하지 않고 f 스트링을 사용하면 편하게 변수와 문자열을 입력할 수 있다.            f”문자열 {변수}” 형태로 입력해주면 된다.               이번 포스팅에서는 함수 실습문제(1) 을 풀어보았다. 다음 포스팅에서는 함수 실습문제(2)를 풀어보도록 하자.        본 포스팅은 패스트캠퍼스 환급 챌린지 참여를 위해 작성되었습니다.          패스트캠퍼스 강의 등록하기: https://bit.ly/3L3avNW       #패스트캠퍼스 #패캠챌린지 #직장인인강 #직장인자기계발 #패스트캠퍼스후기 #캐시백챌린지 #캐시백 #환급챌린지 #한번에끝내는파이썬웹개발초격차패키지Online  ","categories": ["Programming"],
        "tags": ["패스트캠퍼스","패캠챌린지","직장인인강","직장인자기계발","패스트캠퍼스후기","캐시백챌린지","캐시백","환급챌린지","한번에끝내는파이썬웹개발초격차패키지Online"],
        "url": "/programming/Python-Day17/",
        "teaser": null
      },{
        "title": "[Python]패스트캠퍼스 캐시백 챌린지 18일차",
        "excerpt":"     오늘도 어제에 이어서 “한 번에 끝내는 파이썬 웹 개발 초격차 패키지 Online” 의 챕터 6-2. 함수 실습문제(2)를 듣고 정리해보았다. 참고로 이 포스팅은 공부용으로 강의 내용을 요약한 것으로 자세한 강의 내용은 위 링크를 참조 할 것.        아래는 공부 인증 사진.                  03. 함수실습문제(2)   1. 실습문제 6.1.3      로또에 당첨 되어 퇴사를 하고 싶었던 김로또는 로또 예상번호 추출 프로그램을 파이썬으로 작성하려고 한다. 다음 조건에 따라 김로또의 프로그램을 완성해보자.            로또 번호 6개를 생성한다.       로또 번호는 1 ~ 45까지의 랜덤한 번호다.       6개의 숫자 모두 달라야 한다.       getRandomNumber() 함수를 사용해서 구현한다. (random 모듈의 sample함수는 사용하지 않는다)             def getRandomNumber():       number = random.randint(1, 45)       return number        # 표준 출력   1 8 11 13 26 42           Hint: 반복문, 조건문, 리스트, 함수(getRandomNumber)를 이용        [내 풀이]   import random  def getRandomNumber():     number = random.randint(1, 45)     return number  result = [] for getNumber in range(6):     getNumber = getRandomNumber()     if getNumber not in result:         result.append(getNumber)  print(result)      로또 결과값을 담을 result 리스트 생성   getNumber 라는 변수로 getRandomNumber 함수를 호출해 랜덤한 숫자값을 담다.   중복값 제거: 받아온 getNumber 값이 결과값인 result 리스트에 들어있지 않은 경우에만 리스트에 값을 넣는다.   for in 문으로 위의 함수를 6번 실행해 리스트에 값을 총 6개 담는다.        [강의 해설]   # 실습문제 6.1.3 # 로또 번호 추출기 import random  def get_random_number():     number = random.randint(1, 45)     return number  lotto_num = [] # 로또 번호를 저장할 리스트  for i in range(6):     random_number = get_random_number()     lotto_num.append(random_number)  lotto_num.sort()      함수명을 정의할 때 보통 언더바로 단어를 나눔   중복을 허용하는 번호 추출 함수를 먼저 생성   sort 함수를 이용해 오름차 순으로 정렬          출력 결과   (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter6/05-2.실습문제6.1.3-해설.p y [2, 4, 5, 16, 20, 24]          문제의 표준출력과 맞게 줄바꿈 문자를 빼준다.   # 실습문제 6.1.3 # 로또 번호 추출기 import random  def get_random_number():     number = random.randint(1, 45)     return number  lotto_num = [] # 로또 번호를 저장할 리스트  for i in range(6):     random_number = get_random_number()     lotto_num.append(random_number)  lotto_num.sort()  # 줄바꿈 문자 빼기 for num in lotto_num:     print(num, end=\" \")          출력 결과   (myvenv) ➜  python_basic /Users/jinipark/Documents/pyt hon_basic/myvenv/bin/python /Users/jinipark/Documents/ python_basic/myvenv/Chapter6/05-2.실습문제6.1.3-해설.p y 26 27 30 31 39 40          중복을 허용하지 않는 조건문 생성하기   # 실습문제 6.1.3 # 로또 번호 추출기 import random  def get_random_number():     number = random.randint(1, 45)     return number  lotto_num = [] # 로또 번호를 저장할 리스트  for i in range(6):     random_number = get_random_number()     if random_number not in lotto_num:         lotto_num.append(random_number)  lotto_num.sort()  &lt;br/&gt;  # 줄바꿈 문자 빼기 for num in lotto_num:     print(num, end=\" \")      조건문을 몇 번 실행하게 될 지 알 수 없음 ⇒ 무한반복문(while True)으로 변경          while True 문으로 변경 리스트에 문자가 몇 번 들어갈 지 알 수 있는 count 변수 생성   # 실습문제 6.1.3 # 로또 번호 추출기 import random  def get_random_number():     number = random.randint(1, 45)     return number  lotto_num = [] # 로또 번호를 저장할 리스트  count = 0 # 현재 뽑은 숫자 개수  while True:     random_number = get_random_number()     if random_number not in lotto_num:         lotto_num.append(random_number)         count += 1  lotto_num.sort()  # 줄바꿈 문자 빼기 for num in lotto_num:     print(num, end=\" \")           숫자가 리스트에 추가될 때에만 count 숫자 1씩 증가            count 값이 6이 될 때(리스트에 들어간 값이 6개일 때) 프로그램이 종료하도록 break 문 정의           # 실습문제 6.1.3 # 로또 번호 추출기 import random  def get_random_number():     number = random.randint(1, 45)     return number  lotto_num = [] # 로또 번호를 저장할 리스트  count = 0 # 현재 뽑은 숫자 개수  while True:     if count &gt; 5:         break     random_number = get_random_number()     if random_number not in lotto_num:         lotto_num.append(random_number)         count += 1  lotto_num.sort()  # 줄바꿈 문자 빼기 for num in lotto_num:     print(num, end=\" \")      break문은 가장 가까운 반복문을 탈출하게 되니 while 문 밑에 위치시킬 것   break하는 조건은 count &gt; 5 이외에 count == 6 도 가능          출력 결과   (myvenv) ➜  python_basic /Users/jinipark/Documents/pyt hon_basic/myvenv/bin/python /Users/jinipark/Documents/ python_basic/myvenv/Chapter6/05-2.실습문제6.1.3-해설.p y 26 27 30 31 39 40          Tip: 전체 풀이 지우고 다시 한 번 풀어볼 것!        본 포스팅은 패스트캠퍼스 환급 챌린지 참여를 위해 작성되었습니다.          패스트캠퍼스 강의 등록하기: https://bit.ly/3L3avNW       #패스트캠퍼스 #패캠챌린지 #직장인인강 #직장인자기계발 #패스트캠퍼스후기 #캐시백챌린지 #캐시백 #환급챌린지 #한번에끝내는파이썬웹개발초격차패키지Online  ","categories": ["Programming"],
        "tags": ["패스트캠퍼스","패캠챌린지","직장인인강","직장인자기계발","패스트캠퍼스후기","캐시백챌린지","캐시백","환급챌린지","한번에끝내는파이썬웹개발초격차패키지Online"],
        "url": "/programming/Python-Day18/",
        "teaser": null
      },{
        "title": "[Network]루프백 주소(Loopback IP address)란?",
        "excerpt":"     업무 중 테스트를 위해 시스템 도메인주소에 nslookup 을 한 뒤, DNS 쿼리 결과를 공유해달라는 요청을 받았었는데, nslookup으로 나온 DNS 쿼리 결과값이 흔히 보는 127.0.0.1 이 아닌 127.0.0.11 로 리턴되어 문득 loopback 으로 사용할 수 있는 IP 주소 대역이 궁금해져 관련 내용을 찾아서 정리해보았다.        1. Loopback 주소란?       IPv4 혹은 IPv6 에서 자기자신을 가리키기 위한 목적으로 쓰기 위해 예약된 IP주소이다.        2. Loopback 주소로 사용하는 IP대역       루프백 주소로는 아래의 대역을 이용하게 된다.      IPv4: 127.0.0.0/24 (127.0.0.0 ~ 127.255.255.255 사이의 주소 사용)   IPv6: ::1/128 (단 1개 주소만 사용)        3. Localhost 주소 확인 및 수정       이 중 IPv4의 기본 localhost값은 127.0.0.1, IPv6의 기본 localhost값은 ::1/128 이다.       만일 Localhost의 설정값을 수정하려면 /etc/hosts/ (윈도우의 경우 C:\\WIndows\\System32\\drivers\\etc\\hosts 경로) 파일을 수정하면 된다.       이렇게 hosts 파일에서 지정한 localhost주소를 브라우저에 입력하면, DNS를 타지 않고 바로 로컬로 연결된다.       만약 현재 PC에 등록된 localhost 주소를 알고 싶은 경우, /etc/hosts 파일을 살펴보거나, terminal 에서 nslookup localhost 명령어를 입력하면 된다.       ","categories": ["DevOps"],
        "tags": ["DevOps","SRE","loopbackaddress","데브옵스엔지니어","루프백주소","로컬호스트","루프백주소대역","localhost"],
        "url": "/devops/Network-Loopback-IP-address/",
        "teaser": null
      },{
        "title": "[Python]패스트캠퍼스 캐시백 챌린지 19일차",
        "excerpt":"     오늘도 어제에 이어서 “한 번에 끝내는 파이썬 웹 개발 초격차 패키지 Online” 의 챕터 7-1. 튜플을 듣고 정리해보았다. 참고로 이 포스팅은 공부용으로 강의 내용을 요약한 것으로 자세한 강의 내용은 위 링크를 참조 할 것.        아래는 공부 인증 사진.                  01. 튜플   1. 튜플의 특징      시퀀스 자료형(순서가 있는 자료형)   수정, 추가, 삭제가 불가능한 리스트(읽기 전용 리스트)   메모리 사용이 효율적   읽기만 가능하기 때문에 데이터 손실 염려가 없다        2. 튜플 만들기   튜플 = (데이터, 데이터, 데이터)  # 튜플은 괄호를 생략할 수 있다. 튜플 = 데이터, 데이터, 데이터  # 예시: 튜플은 데이터의 자료형이 일치하지 않아도 된다. a = (3, 4, 5) a = \"패스트캠퍼스\", 3, True  # 예시 2: 데이터가 1개 들어간 튜플을 만들 때에는 콤마를 붙여야 한다. a = (30,) a = 30,      참고: 괄호의 용도(Python 문법)            () : 함수, 튜플       [] : 리스트       {} : fstring               3. 튜플을 리스트로 만들기   # 예시 1: 리스트 자료형을 튜플로 만들어준다. tuple([리스트]) a = tuple([5, 6, 7])  # 예시 2: range 객체를 list로 감싸면 list 자료형 &gt; tuple로 감싸면 튜플 x = list(range(10)) a = tuple(x)  # 예시 3: 튜플을 리스트로 만들 수 있다. x = 5, 6, 7 a = list(x)        4. 패킹과 언패킹(Python 특징)   numbers = 3, 4, 5 # 패킹: 3, 4, 5 라는 데이터를 numbers라는 변수에 패킹하는 것 a, b, c = numbers # 언패킹: a, b, c라는 변수에 하나하나 저장되게 됨  # 리스트도 마찬가지로 패킹과 언패킹이 가능 numbers = [3, 4, 5] a, b, c = numbers  # 활용예 a, b = b, a # a, b 들어가있던 값을 바꿔줄 수 있다.      패킹: 여러 개의 데이터를 하나의 변수에 할당하는 것   언패킹: 컬렉션(튜플, 딕셔너리, 리스트 등)의 각 데이터를 각각의 변수에 할당하는 것        5. 튜플 함수   a = 10, 20, 30, 40, 30      특정 값의 인덱스 구하기: a.index(20) = 1   특정 값의 개수: a.count(30) = 2   최대값, 최소값: max(a) = 40, min(a) = 10   합계: sum(a) = 130        6. 실습   # 튜플 # : 읽기 전용 리스트 a = (3, 4, 5) b = 3, 4, 5  c = (3,) d = 3  e = tuple([3, 4, 5]) f = list(range(10)) g = tuple(f)  h = 3, 4, 5 i = list(h)  # 튜플 관련 함수 x = 5, 6, 7, 8 print(max(x)) print(min(x)) print(sum(x)) print(x.count(6)) print(x.index(7))        이번 포스팅에서는 튜플에 대해 알아보았다. 다음 포스팅에서는 딕셔너리에 대해 알아보도록 하자.       본 포스팅은 패스트캠퍼스 환급 챌린지 참여를 위해 작성되었습니다.          패스트캠퍼스 강의 등록하기: https://bit.ly/3L3avNW       #패스트캠퍼스 #패캠챌린지 #직장인인강 #직장인자기계발 #패스트캠퍼스후기 #캐시백챌린지 #캐시백 #환급챌린지 #한번에끝내는파이썬웹개발초격차패키지Online  ","categories": ["Programming"],
        "tags": ["패스트캠퍼스","패캠챌린지","직장인인강","직장인자기계발","패스트캠퍼스후기","캐시백챌린지","캐시백","환급챌린지","한번에끝내는파이썬웹개발초격차패키지Online"],
        "url": "/programming/Python-Day19/",
        "teaser": null
      },{
        "title": "[Python]패스트캠퍼스 캐시백 챌린지 20일차",
        "excerpt":"     오늘도 어제에 이어서 “한 번에 끝내는 파이썬 웹 개발 초격차 패키지 Online” 의 챕터 7-2. 딕셔너리를 듣고 정리해보았다. 참고로 이 포스팅은 공부용으로 강의 내용을 요약한 것으로 자세한 강의 내용은 위 링크를 참조 할 것.        아래는 공부 인증 사진.                  02. 딕셔너리   1. 딕셔너리의 특징      시퀀스 자료형   키와 데이터를 가지고 있는 사전형 자료형   사전형태의 자료를 만들 때 편리        2. 딕셔너리 만들기      딕셔너리를 만들어보자.   딕셔너리 = {키1 : 데이터1, 키2 : 데이터2}  # 예시 stock = {\"삼성전자\" : 82000, \"LG전자\" : 150000}  # 예시2: 리스트와 튜플도 들어갈 수 있다. stock = {     \"삼성전자\" : [81000, 81500, 82000, 81500, 82000],     \"LG전자\" : (150000, 149000, 148000, 151000, 152000) }        3. 딕셔너리 접근하기   딕셔너리[\"키\"]  # 예시 stock[\"삼성전자\"]      결과로는 85000이 출력된다.        4. 딕셔너리 할당하기, 삭제하기      딕셔너리를 할당, 삭제해보자.   # 할당하기 딕셔너리[\"키\"] = 데이터  # 예시 stock[\"삼성전자\"] = 85000  # 삭제하기 del 딕셔너리[\"키\"]  # 예시 del stock[\"삼성전자\"]        5. 딕셔너리 함수      딕셔너리 함수를 사용해보자.   stock = {     \"삼성전자\" : 82000,     \"SK하이닉스\" : 123000,     \"NAVER\" : 370000,     \"카카오\" : 133000 }  # 키와 데이터 쌍을 가져오기 stock.items()  # 키 값을 가져오기 stock.keys()  # 데이터를 가져오기 stock.values()        6. 실습      위에서 배운 내용들을 vscode로 실습해보자.   # 딕셔너리 # : 사전형태의 자료형  stock_a = {\"삼성전자\" : 82000, \"LG전자\" : 150000}  stock_b = {     \"삼성전자\" : [81000, 81500, 82000, 81500, 82000],     \"LG전자\" : (150000, 149000, 148000, 151000, 152000) }  # 중첩 딕셔너리 stock_c = {     \"삼성전자\" : {         \"현재가\" : 82000,         \"보유수량\" : 5,         \"매수단가\" : 81000     } }  print(stock_a) print(stock_b) print(stock_c)      Tip: alt + shift + 방향키를 이용해 한 줄을 쉽게 복사할 수 있다.          출력 결과   (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter7/02.딕셔너리.py {'삼성전자': 82000, 'LG전자': 150000} {'삼성전자': [81000, 81500, 82000, 81500, 82000], 'LG전자': (150000, 149000, 148000, 151000, 152000)} {'삼성전자': {'현재가': 82000, '보유수량': 5, '매수단가': 81000}}           딕셔너리 접근/할당/삭제하기   # 딕셔너리 접근하기 print(stock_a[\"삼성전자\"]) print(stock_c[\"삼성전자\"][\"보유수량\"])  # 딕셔너리 할당하기 stock_a[\"삼성전자\"] = 85000 print(stock_a)  # 딕셔너리 삭제하기 del stock_a[\"LG전자\"] print(stock_a)          출력 결과   (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter7/02.딕셔너리.py 82000 5 {'삼성전자': 85000, 'LG전자': 150000} {'삼성전자': 85000}          딕셔너리 함수   # 딕셔너리 함수 stock_d = {     \"삼성전자\" : 82000,     \"SK하이닉스\" : 123000,     \"NAVER\" : 370000,     \"카카오\" : 133000 }  # items() : 키와 데이터 쌍 print(stock_d.items)  # 일반적 사용예 for item in stock_d.items():     print(item[0]) # 0: 키, 1: 데이터  # keys() : 키 for key in stock_d.keys():     print(key)  # values() : 데이터 for value in stock_d.values():     print(value)          출력 결과   (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter7/02.딕셔너리.py &lt;built-in method items of dict object at 0x10a44ef00&gt; 삼성전자 SK하이닉스 NAVER 카카오 삼성전자 SK하이닉스 NAVER 카카오 82000 123000 370000 133000        이번 포스팅에서는 딕셔너리에 대해 알아보았다. 다음 포스팅에서는 클래스와 객체에 대해 알아보도록 하자.       본 포스팅은 패스트캠퍼스 환급 챌린지 참여를 위해 작성되었습니다.          패스트캠퍼스 강의 등록하기: https://bit.ly/3L3avNW       #패스트캠퍼스 #패캠챌린지 #직장인인강 #직장인자기계발 #패스트캠퍼스후기 #캐시백챌린지 #캐시백 #환급챌린지 #한번에끝내는파이썬웹개발초격차패키지Online  ","categories": ["Programming"],
        "tags": ["패스트캠퍼스","패캠챌린지","직장인인강","직장인자기계발","패스트캠퍼스후기","캐시백챌린지","캐시백","환급챌린지","한번에끝내는파이썬웹개발초격차패키지Online"],
        "url": "/programming/Python-Day20/",
        "teaser": null
      },{
        "title": "[Python]Syntax Error : stdin 에러 해결",
        "excerpt":"     *💡  파이썬에서 Syntax Error : stdin 에러가 났을 경우, exit() 혹은 Ctrl + Z을 입력하여 해결할 수 있다. *       1. 에러 상황       패스트캠퍼스 챌린지 강의 실습 중, 파이썬 코드를 실행하니 아래와 같은 Syntax 에러가 발생했다.       /Users/usr/Documents/python_basic/myvenv/bin/python /Users/usr/Documents/python_basic/myvenv/Chapter8/04.상속.py     ^ SyntaxError: invalid syntax &gt;&gt;&gt;        2. 해결 방법       찾아보니 vscode를 껐다가 다시 켜면 해결된다는 얘기도 있는데, 구글링을 조금 더 해보니 해당 에러는 파이썬 코드를 파이썬 인터프리터 내에서 실행하고자 할 때 발생하는 에러였다.       따라서 파이썬 인터프리터 밖에서 코드를 실행할 수 있도록 에러 마지막 부분의 &gt;&gt;&gt; 다음 부분에          exit() 를 입력하고 엔터   ctrl + Z 를 누른 뒤 엔터       둘 중 하나를 해주면 파이썬 코드가 정상적으로 실행된다고 한다.       이 안내를 따라서 exit()을 입력하고 엔터를 누른 뒤, 파이썬 코드를 다시 실행해주니 아래와 같이 파이썬 코드가 정상적으로 실행되었다.       /Users/usr/Documents/python_basic/myvenv/bin/python /Users/usr/Documents/python_basic/myvenv/Chapter8/04.상속.py     ^ SyntaxError: invalid syntax &gt;&gt;&gt; exit()  (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter8/04.상속.py [울프] 지상에서 이동하기 [샤크] 헤엄치기 [드래곤] 날기       ","categories": ["Programming"],
        "tags": ["파이썬에러","파이썬초보","비전공출신개발자","Pythonsyntaxerror","Pythonerror","stdinerror","syntaxerrorstdin","파이썬공부","데브옵스엔지니어"],
        "url": "/programming/Python-Syntax-Error-Stdin/",
        "teaser": null
      },{
        "title": "[Python]패스트캠퍼스 캐시백 챌린지 21일차",
        "excerpt":"     오늘도 어제에 이어서 “한 번에 끝내는 파이썬 웹 개발 초격차 패키지 Online” 의 챕터 7-2. 딕셔너리를 듣고 정리해보았다. 참고로 이 포스팅은 공부용으로 강의 내용을 요약한 것으로 자세한 강의 내용은 위 링크를 참조 할 것.        아래는 공부 인증 사진.                  1. 클래스와 객체   1. 클래스와 객체의 개념      클래스: 객체를 만들기 위한 설계도   객체: 설계도로부터 만들어낸 제품          실습   # 클래스를 사용하는 이유 champion1_name = \"이즈리얼\" champion1_health = 700 champion1_attack = 90  print(f\"{champion1_name}님 소환사의 협곡에 오신것을 환영합니다.\")  champion2_name = \"리신\" champion2_health = 800 champion2_attack = 95  print(f\"{champion2_name}님 소환사의 협곡에 오신것을 환영합니다.\")  def basic_attack(name, attack):     print(f\"{name} 기본공격 {attack}\")  basic_attack(champion1_name, champion1_attack) basic_attack(champion2_name, champion2_attack)          출력 결과   (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter8/01.클래스개념.py 이즈리얼님 소환사의 협곡에 오신것을 환영합니다. 리신님 소환사의 협곡에 오신것을 환영합니다. 이즈리얼 기본공격 90 리신 기본공격 95          위의 프로그램을 클래스로 만들어보자   print(\"=============클래스를 사용한 경우=============\")  class Champion:     def __init__(self, name, health, attack):         self.name = name         self.health = health         self.attack = attack         print(f\"{name}님 소환사의 협곡에 오신것을 환영합니다.\")     def basic_attack(self):         print(f\"{self.name} 기본공격 {self.attack}\")  ezreal = Champion(\"이즈리얼\", 700, 90) leesin = Champion(\"리신\", 800, 95) ezreal.basic_attack() leesin.basic_attack()          챔피언을 하나 더 추가해야하는 경우: 클래스 미사용   # 클래스를 사용하는 이유 champion1_name = \"이즈리얼\" champion1_health = 700 champion1_attack = 90  print(f\"{champion1_name}님 소환사의 협곡에 오신것을 환영합니다.\")  champion2_name = \"리신\" champion2_health = 800 champion2_attack = 95  print(f\"{champion2_name}님 소환사의 협곡에 오신것을 환영합니다.\")  #### 추가 및 수정이 필요한 부분 #### champion3_name = \"야스오\" champion3_health = 750 champion3_attack = 92  print(f\"{champion3_name}님 소환사의 협곡에 오신것을 환영합니다.\") #### /추가 및 수정이 필요한 부분 ####  def basic_attack(name, attack):     print(f\"{name} 기본공격 {attack}\")  basic_attack(champion1_name, champion1_attack) basic_attack(champion2_name, champion2_attack) basic_attack(champion3_name, champion3_attack) #### 추가 및 수정이 필요한 부분          챔피언을 하나 더 추가해야하는 경우: 클래스 사용   print(\"=============클래스를 사용한 경우=============\")  class Champion:     def __init__(self, name, health, attack):         self.name = name         self.health = health         self.attack = attack         print(f\"{name}님 소환사의 협곡에 오신것을 환영합니다.\")     def basic_attack(self):         print(f\"{self.name} 기본공격 {self.attack}\")  ezreal = Champion(\"이즈리얼\", 700, 90) leesin = Champion(\"리신\", 800, 95) yasuo = Champion(\"야스오\", 750, 92) # 추가 및 수정이 필요한 부분  ezreal.basic_attack() leesin.basic_attack() yasuo.basic_attack() # 추가 및 수정이 필요한 부분               클래스를 사용하면 단 두줄만 수정하면 된다 ⇒ 객체를 많이 생산해내야 할 수 록 클래스 사용이 효율적            클래스 = 속성 + 메서드(method)                     속성: 특징들을 나타낸 것       메서드: 동작들을 나타낸 것                2. 클래스 만들기   class 클래스이름     def 메서드이름(self):        명령블록  # 예시 class Monster:     def say(self):         print(\"나는 몬스터다\")          만든 클래스를 호출하기   # 호출하기 인스턴스 = 클래스이름() 인스턴스.메서드()  # 예시 goblin = Monster() goblin.say()      인스턴스: 클래스와 연관지어 표현할 때 자주 사용하는 표현(객체와 유사)        3. 실습      파이썬에서는 자료형도 클래스다   class Monster:     def say(self):         print(\"나는 몬스터다!\")  goblin = Monster() goblin.say()  # 파이썬에서는 자료형도 클래스다 a = 10 b = \"문자열객체\" c = True          결과 출력   (myvenv) ➜  python_basic /Users/jinipark/Documents/pyt hon_basic/myvenv/bin/python /Users/jinipark/Documents/ python_basic/myvenv/Chapter8/02.클래스만들기.py 나는 몬스터다! &lt;class 'int'&gt; &lt;class 'str'&gt; &lt;class 'bool'&gt;          각 자료형이 class로 출력되는 것을 알 수 있다.   print(b.__dir__())      문자열 객체에 대해 생성할 수 있는 메서드 확인          출력 확인   (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ ['__new__', '__repr__', '__hash__', '__str__', '__getattribute__', '__lt__', '__le__', '__eq__', '__ne__', '__gt__', '__ge__', '__iter__', '__mod__', '__rmod__', '__len__', '__getitem__', '__add__', '__mul__', '__rmul__', '__contains__', 'encode', 'replace', 'split', 'rsplit', 'join', 'capitalize', 'casefold', 'title', 'center', 'count', 'expandtabs', 'find', 'partition', 'index', 'ljust', 'lower', 'lstrip', 'rfind', 'rindex', 'rjust', 'rstrip', 'rpartition', 'splitlines', 'strip', 'swapcase', 'translate', 'upper', 'startswith', 'endswith', 'removeprefix', 'removesuffix', 'isascii', 'islower', 'isupper', 'istitle', 'isspace', 'isdecimal', 'isdigit', 'isnumeric', 'isalpha', 'isalnum', 'isidentifier', 'isprintable', 'zfill', 'format', 'format_map', '__format__', 'maketrans', '__sizeof__', '__getnewargs__', '__doc__', '__setattr__', '__delattr__', '__init__', '__reduce_ex__', '__reduce__', '__subclasshook__', '__init_subclass__', '__dir__', '__class__']        이번 포스팅에서는 클래스와 객체의 개념에 대해 알아보았다. 다음 포스팅에서는 생성자에 대해 알아보도록 하자.       본 포스팅은 패스트캠퍼스 환급 챌린지 참여를 위해 작성되었습니다.          패스트캠퍼스 강의 등록하기: https://bit.ly/3L3avNW       #패스트캠퍼스 #패캠챌린지 #직장인인강 #직장인자기계발 #패스트캠퍼스후기 #캐시백챌린지 #캐시백 #환급챌린지 #한번에끝내는파이썬웹개발초격차패키지Online  ","categories": ["Programming"],
        "tags": ["패스트캠퍼스","패캠챌린지","직장인인강","직장인자기계발","패스트캠퍼스후기","캐시백챌린지","캐시백","환급챌린지","한번에끝내는파이썬웹개발초격차패키지Online"],
        "url": "/programming/Python-Day21/",
        "teaser": null
      },{
        "title": "[Python]패스트캠퍼스 캐시백 챌린지 22일차",
        "excerpt":"     오늘도 어제에 이어서 “한 번에 끝내는 파이썬 웹 개발 초격차 패키지 Online” 의 챕터 8-2. 생성자를 듣고 정리해보았다. 참고로 이 포스팅은 공부용으로 강의 내용을 요약한 것으로 자세한 강의 내용은 위 링크를 참조 할 것.        아래는 공부 인증 사진.                  1. 생성자   1. 클래스와 객체의 개념           클래스 = 속성 + 메서드(method)                     속성: 특징들을 나타낸 것       메서드: 동작들을 나타낸 것                   2. 속성 추가하기           Monster 클래스에 속성을 추가해보자.         class Monster:       def say(self):           print(\"나는 몬스터다\")               1. 체력 2. 공격력 3. 이동속도   class Monster:     def __init__(self, health, attack, speed):         self.health = health         self.attack = attack         self.speed = speed  goblin = Monster(800, 120, 300) #인스턴스 생성 시점 wolf = Monster(1500, 200, 350)      __init__ : 인스턴스를 만들 때 반드시, 가장먼저 호출되는 메서드   goblin 인스턴스를 생성할때, 800, 120, 300는 __init__ 메서드의 인자(argument)로 들어가게 된다.   self : 인스턴스 자기자신을 뜻함. 매개변수 아님.        3. 메서드 추가하기           Monster 클래스에 메서드를 추가해보자.         class Monster:       def __init__(self, health, attack, speed):           self.health = health           self.attack = attack           self.speed = speed        goblin = Monster(800, 120, 300)   wolf = Monster(1500, 200, 350)                  체력 감소하기       체력 가져오기                       추가 메서드를 적용하면 아래와 같다.         class Monster:       def __init__(self, health, attack, speed):           self.health = health           self.attack = attack           self.speed = speed       def decrease_health(self, num):           self.health -= num       def get_health(self):           return self.health        goblin = Monster(800, 120, 300)        goblin.decrease_health(100)   print(gobling.get_health())               4. 실습           위에서 배운 내용을 실제 vscode에 입력해보자.         # 생성자   # : 인스턴스를 만들 때 호출되는 메서드        class Monster:       def __init__(self, health, attack, speed):           self.health = health           self.attack = attack           self.speed = speed       def decrease_health(self, num):           self.health -= num       def get_health(self):           return self.health        # 고블린 인스턴스 생성   goblin = Monster(800, 120, 300)   goblin.decrease_health(100)   print(goblin.get_health())                       출력 결과       (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter8/03.생성자.py 700          늑대 인스턴스를 추가로 생성해보자.   # 생성자 # : 인스턴스를 만들 때 호출되는 메서드  class Monster:     def __init__(self, health, attack, speed):         self.health = health         self.attack = attack         self.speed = speed     def decrease_health(self, num):         self.health -= num     def get_health(self):         return self.health  # 고블린 인스턴스 생성 goblin = Monster(800, 120, 300) goblin.decrease_health(100) print(goblin.get_health())  # 늑대 인스턴스 생성 wolf = Monster(1500, 200, 350) wolf.decrease_health(1000) print(wolf.get_health())          출력 결과   (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter8/03.생성자.py 700 500      늑대 인스턴스에 health = 1500, attack = 200, speed = 350이 할당   decrease_health 함수로 health가 1000이 감소   get_health 함수로 현재 health값 저장 및 print로 출력        이번 포스팅에서는 생성자의 개념에 대해 알아보았다. 다음 포스팅에서는 상속에 대해 알아보도록 하자.       본 포스팅은 패스트캠퍼스 환급 챌린지 참여를 위해 작성되었습니다.          패스트캠퍼스 강의 등록하기: https://bit.ly/3L3avNW       #패스트캠퍼스 #패캠챌린지 #직장인인강 #직장인자기계발 #패스트캠퍼스후기 #캐시백챌린지 #캐시백 #환급챌린지 #한번에끝내는파이썬웹개발초격차패키지Online  ","categories": ["Programming"],
        "tags": ["패스트캠퍼스","패캠챌린지","직장인인강","직장인자기계발","패스트캠퍼스후기","캐시백챌린지","캐시백","환급챌린지","한번에끝내는파이썬웹개발초격차패키지Online"],
        "url": "/programming/Python-Day22/",
        "teaser": null
      },{
        "title": "[Python]패스트캠퍼스 캐시백 챌린지 23일차",
        "excerpt":"     오늘도 어제에 이어서 “한 번에 끝내는 파이썬 웹 개발 초격차 패키지 Online” 의 챕터 8-3. 상속을 듣고 정리해보았다. 참고로 이 포스팅은 공부용으로 강의 내용을 요약한 것으로 자세한 강의 내용은 위 링크를 참조 할 것.        아래는 공부 인증 사진.                  03. 상속   1. 상속의 개념      자식클래스는 부모클래스의 속성과 메서드를 그대로 가져올 수 있다.             상속이 필요한 이유: 클래스를 하나하나 설정하게 될 경우 관리포인트가 너무 많아진다.               예시                   ‘몬스터’ 관련코드가 중복으로 발생 ⇒ 중복을 없애 효율적으로 만드는 방법은?              세 클래스의 공통된 부분을 합쳐 ‘몬스터’라는 클래스를 생성한 뒤 상속하여 중복을 없애 코드를 간결하게 작성할 수 있다.           2. 상속 사용 방법      위 예시를 코드로 작성해보자.   먼저, 부모클래스를 정의해보자   class Monster:     def __init__(self, name, health, attack):         self.name = name         self.health = health         self.attack = attack     def move(self):         print(\"지상에서 이동하기\")      속성            이름       체력       공격력           메서드            이동하기                  자식클래스 정의(__init__ 는 생략 가능)   class Wolf(Monster):     pass # 상속 받은 메서드만 사용  class Shark(Monster):     def move(self):         print(\"헤엄치기\")  class Dragon(Monster):     def move(self):         print(\"날기\")      속성 (Monster 로부터 상속받은)            이름       체력       공격력           메서드 오버라이딩: 메서드 재 정의            헤엄치기       날기                3. 실습   # 상속 # : 클래스들에 중복된 코드를 제거하고 유지보수를 #    편하게 하기 위해 사용  class Monster:     def __init__(self, name, health, attack):         self.name = name         self.health = health         self.attack = attack     def move(self):         print(f\"[{self.name}] 지상에서 이동하기\")  class Wolf(Monster):     pass  class Shark(Monster):     def move(self): # 메서드 오버라이딩         print(f\"[{self.name}] 헤엄치기\")  class Dragon(Monster):     def move(self): # 메서드 오버라이딩         print(f\"[{self.name}] 날기\")  wolf = Wolf(\"울프\", 1500, 200) wolf.move()  shark = Shark(\"샤크\", 300, 400) shark.move()  dragon = Dragon(\"드래곤\", 8000,800) dragon.move()        이번 포스팅에서는 상속의 개념에 대해 알아보았다. 다음 포스팅에서는 오버라이딩, 클래스 변수에 대해 알아보도록 하자.       본 포스팅은 패스트캠퍼스 환급 챌린지 참여를 위해 작성되었습니다.          패스트캠퍼스 강의 등록하기: https://bit.ly/3L3avNW       #패스트캠퍼스 #패캠챌린지 #직장인인강 #직장인자기계발 #패스트캠퍼스후기 #캐시백챌린지 #캐시백 #환급챌린지 #한번에끝내는파이썬웹개발초격차패키지Online  ","categories": ["Programming"],
        "tags": ["패스트캠퍼스","패캠챌린지","직장인인강","직장인자기계발","패스트캠퍼스후기","캐시백챌린지","캐시백","환급챌린지","한번에끝내는파이썬웹개발초격차패키지Online"],
        "url": "/programming/Python-Day23/",
        "teaser": null
      },{
        "title": "[Kubernetes]Pod의 /etc/hosts 파일에 DNS 추가하는 방법(HostAlias)",
        "excerpt":"     💡  Pod의 /etc/hosts 파일에 DNS를 추가하기 위해서는 Deployment의 hostalias 옵션을 사용한다.       1. 배경 상황       프로젝트 진행 중 인프라팀에서 NAS의 연결 주소를 내부 private IP로 변경하기위해서 파드 내 컨테이너의 /etc/hosts 파일을 변경해달라는 요청을 받았다.        2. 설정 방법       Pod의 /etc/hosts 파일을 변경하기 위해서는 Pod(Pod가 Deployment에 의해 생성되었을 경우에는 Deployment) YAML 파일의 hostAlias 항목에 도메인, 그리고 도메인과 맵핑할 ip를 기입해주면 된다.       ※ 컨테이너 내부의 호스트 파일을 수동으로 변경하면 안된다. 컨테이너는 휘발성이기 때문에, 컨테이너 종료 시 변경사항이 손실된다.          Deployment에 등록할 경우   apiVersion: apps/v1 kind: Deployment metadata:  name: web-app  namespace: default spec:  replicas: 2  selector:   matchLabels:     app: web  template:    metadata:      labels:        app: web    spec:      restartPolicy: Always      hostAliases:      - ip: \"127.0.0.1\"        hostnames:        - \"foo.local\"      containers:      - name: cat-hosts        image: busybox        command:        - cat        args:        - \"/etc/hosts\"      spec.template.hostAliases.ip ⇒ /etc/hosts 파일에 등록할 ip   spec.template.hostAliases.hostnames ⇒ /etc/hosts 파일에 등록할 호스트명          Pod에 등록할 경우   apiVersion: v1 kind: Pod metadata:  name: web-app  namespace: default  labels:    app: web spec:   restartPolicy: Always   hostAliases:   - ip: \"127.0.0.1\"     hostnames:     - \"foo.local\"   containers:   - name: cat-hosts     image: busybox     command:     - cat     args:     - \"/etc/hosts\"      spec.hostAliases.ip ⇒ /etc/hosts 파일에 등록할 ip   spec.hostAliases.hostnames ⇒ /etc/hosts 파일에 등록할 호스트명        3. 참고 자료      Kubernetes 공식문서: kubernetes.io/ko/docs/tasks/network/customize-hosts-file-for-pods      ","categories": ["DevOps"],
        "tags": ["쿠버네티스","쿠버네티스네트워킹","hostalias","kuberneteshostalias","cka","kubernetes","kubernetesnetworking","k8s","DevOpsengineer","데브옵스","데브옵스엔지니어"],
        "url": "/devops/Kubernetes-Pod-Etc-Hosts-Hostalias/",
        "teaser": null
      },{
        "title": "[Python]패스트캠퍼스 캐시백 챌린지 24일차",
        "excerpt":"     오늘도 어제에 이어서 “한 번에 끝내는 파이썬 웹 개발 초격차 패키지 Online” 의 챕터 8-4. 오버라이딩, 클래스변수를 듣고 정리해보았다. 참고로 이 포스팅은 공부용으로 강의 내용을 요약한 것으로 자세한 강의 내용은 위 링크를 참조 할 것.        아래는 공부 인증 사진.                  01. 오버라이딩, 클래스 변수   1. RPG 게임 업데이트(예시)   1. 생성자 오버라이딩      요건            드래곤 클래스에 인스턴스 속성으로 3개의 스킬을 추가       드래곤이 스킬을 사용하면 속성 중 하나가 무작위로 사용                  어떻게 속성을 추가할까?            Monster class에 속성 추가 ⇒ 다른 자식클래스에도 해당 속성이 추가됨 (X)       생성자 자체를 오버라이딩하자!           class Monster:     def __init__(self, name, health, attack):         self.name = name         self.health = health         self.attack = attack     def move(self):         print(f\"[{self.name}] 지상에서 이동하기\")  class Dragon(Monster):     # 생성자 오버라이딩     def __init__(self, name, health, attack, skill):         self.name = name         self.health = health         self.attack = attack         def move(self): # 메서드 오버라이딩         print(f\"[{self.name}] 날기\")      부모 클래스의 함수를 그대로 복사 붙여넣기 해도 되지만, 매번 붙여넣기 하기는 너무 번거롭다          super 함수를 사용하자.            super().init(): 부모클래스의 __init__ 함수를 불러온다.           class Monster:     def __init__(self, name, health, attack):         self.name = name         self.health = health         self.attack = attack     def move(self):         print(f\"[{self.name}] 지상에서 이동하기\")  class Dragon(Monster):     # 생성자 오버라이딩     def __init__(self, name, health, attack, skill):         super().__init__(name, health, attack)     def move(self): # 메서드 오버라이딩         print(f\"[{self.name}] 날기\")          추가 매개변수인 skill의 함수를 선언해준다.   class Dragon(Monster):     # 생성자 오버라이딩     def __init__(self, name, health, attack, skill):         super().__init__(name, health, attack)         self.skill = skill              def move(self): # 메서드 오버라이딩         print(f\"[{self.name}] 날기\")      Dragon을 호출할 때, 스킬을 추가해서 호출한다.            스킬은 불변하므로, 리스트가 아닌 튜플이 적절           class Dragon(Monster):     # 생성자 오버라이딩     def __init__(self, name, health, attack, skill):         super().__init__(name, health, attack)         self.skill = skill              def move(self): # 메서드 오버라이딩         print(f\"[{self.name}] 날기\")  dragon = Dragon(\"드래곤\", 8000, 800, (\"불뿜기\", \"꼬리치기\", \"날개치기\")) dragon.move()          스킬은 불변한데, 호출할 때 매번 넣어주면 중복이 발생한다.   class Dragon(Monster):     # 생성자 오버라이딩     def __init__(self, name, health, attack, skill):         super().__init__(name, health, attack)         self.skill = skill              def move(self): # 메서드 오버라이딩         print(f\"[{self.name}] 날기\")  dragon1 = Dragon(\"드래곤\", 8000, 800, (\"불뿜기\", \"꼬리치기\", \"날개치기\")) dragon2 = Dragon(\"드래곤\", 7000, 700, (\"불뿜기\", \"꼬리치기\", \"날개치기\")) dragon3 = Dragon(\"드래곤\", 6000, 600, (\"불뿜기\", \"꼬리치기\", \"날개치기\"))  dragon.move()          튜플을 속성 자체에 직접 대입   class Dragon(Monster):     # 생성자 오버라이딩     def __init__(self, name, health, attack):         super().__init__(name, health, attack)         self.skill = (\"불뿜기\", \"꼬리치기\", \"날개치기\")      def move(self): # 메서드 오버라이딩         print(f\"[{self.name}] 날기\")  dragon = Dragon(\"드래곤\", 8000, 800)           skill ⇒ skills 로 바꾸고 skill 메서드를 생성   random.randint를 사용해 스킬을 랜덤으로 불러오기 (import random)   dragon.skill()로 스킬을 사용해준다.   # 상속 # : 클래스들에 중복된 코드를 제거하고 유지보수를 #    편하게 하기 위해 사용  import random  class Monster:     def __init__(self, name, health, attack):         self.name = name         self.health = health         self.attack = attack     def move(self):         print(f\"[{self.name}] 지상에서 이동하기\")  class Wolf(Monster):     pass  class Shark(Monster):     def move(self): # 메서드 오버라이딩         print(f\"[{self.name}] 헤엄치기\")  class Dragon(Monster):     # 생성자 오버라이딩     def __init__(self, name, health, attack):         super().__init__(name, health, attack)         self.skills = (\"불뿜기\", \"꼬리치기\", \"날개치기\")      def move(self): # 메서드 오버라이딩         print(f\"[{self.name}] 날기\")          def skill(self):         print(f\"[{self.name}] 스킬 사용 {self.skills[random.randint(0,2)]}\")  wolf = Wolf(\"울프\", 1500, 200) wolf.move()  shark = Shark(\"샤크\", 300, 400) shark.move()  dragon = Dragon(\"드래곤\", 8000, 800) dragon.move() dragon.skill()          출력 결과: 코드를 실행할 때마다 다른 스킬을 사용하는 것을 확인할 수 있다.   (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter8/05.오버라이딩클래스변수.p y [울프] 지상에서 이동하기 [샤크] 헤엄치기 [드래곤] 날기 [드래곤] 스킬 사용 날개치기 (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter8/05.오버라이딩클래스변수.p y [울프] 지상에서 이동하기 [샤크] 헤엄치기 [드래곤] 날기 [드래곤] 스킬 사용 불뿜기        2. 클래스 변수      전체 Monster의 개수를 최대 1000 마리로 제한 ⇒ 클래스 변수 사용해야함   Monster 하위에 max_num = 1000을 정의   Monster 를 생성(__init__ ) 할때마다 1000에서 1씩 빼주기 ⇒ Monster.max_num -= 1            self 가 아님에 주의!           # 상속 # : 클래스들에 중복된 코드를 제거하고 유지보수를 #    편하게 하기 위해 사용  # 클래스 변수 # : 인스턴스들이 모두 공유하는 변수  import random  class Monster:     max_num = 1000     def __init__(self, name, health, attack):         self.name = name         self.health = health         self.attack = attack         Monster.max_num -= 1     def move(self):         print(f\"[{self.name}] 지상에서 이동하기\")  class Wolf(Monster):     pass  class Shark(Monster):     def move(self): # 메서드 오버라이딩         print(f\"[{self.name}] 헤엄치기\")  class Dragon(Monster):     # 생성자 오버라이딩     def __init__(self, name, health, attack):         super().__init__(name, health, attack)         self.skills = (\"불뿜기\", \"꼬리치기\", \"날개치기\")      def move(self): # 메서드 오버라이딩         print(f\"[{self.name}] 날기\")          def skill(self):         print(f\"[{self.name}] 스킬 사용 {self.skills[random.randint(0,2)]}\")  wolf = Wolf(\"울프\", 1500, 200) wolf.move() print(wolf.max_num)  shark = Shark(\"샤크\", 300, 400) shark.move() print(shark.max_num)  dragon = Dragon(\"드래곤\", 8000, 800) dragon.move() dragon.skill() print(dragon.max_num)          출력 결과: max_num 을 모든 클래스에서 공유하는 것을 확인할 수 있다.   (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter8/05.오버라이딩클래스변수.p y [울프] 지상에서 이동하기 999 [샤크] 헤엄치기 998 [드래곤] 날기 [드래곤] 스킬 사용 꼬리치기 997        이번 포스팅에서는 오버라이딩, 클래스 변수의 개념에 대해 알아보았다. 다음 포스팅에서는 실습문제를 풀어보도록 하자.       본 포스팅은 패스트캠퍼스 환급 챌린지 참여를 위해 작성되었습니다.          패스트캠퍼스 강의 등록하기: https://bit.ly/3L3avNW       #패스트캠퍼스 #패캠챌린지 #직장인인강 #직장인자기계발 #패스트캠퍼스후기 #캐시백챌린지 #캐시백 #환급챌린지 #한번에끝내는파이썬웹개발초격차패키지Online  ","categories": ["Programming"],
        "tags": ["패스트캠퍼스","패캠챌린지","직장인인강","직장인자기계발","패스트캠퍼스후기","캐시백챌린지","캐시백","환급챌린지","한번에끝내는파이썬웹개발초격차패키지Online"],
        "url": "/programming/Python-Day24/",
        "teaser": null
      },{
        "title": "[Python]패스트캠퍼스 캐시백 챌린지 25일차",
        "excerpt":"     오늘도 어제에 이어서 “한 번에 끝내는 파이썬 웹 개발 초격차 패키지 Online” 의 챕터 8-5. 클래스 실습문제를 듣고 정리해보았다. 참고로 이 포스팅은 공부용으로 강의 내용을 요약한 것으로 자세한 강의 내용은 위 링크를 참조 할 것.        아래는 공부 인증 사진.                  05. 클래스 실습문제   1. 실습문제 8.1.1      영철은 스타트게임즈 회사에 개발자로 취직을 하게 되었다. 지난 주 회의 결과로 신작 MMORPG 게임의 아이템 구성안을 만들었다.            아이템 공통: 이름, 가격, 무게, 판매하기, 버리기       장비 아이템: 착용효과, 착용하기       소모품 아이템: 사용효과, 사용하기       (단, 버리기는 버릴 수 있는 아이템만 가능하가)                구성안을 토대로 클래스 다이어그램을 설계하였다.                   구성안과 설계도를 보고 클래스를 코드로 완성해보자.       (메서드 구현은 자유롭게 한다)            [내 풀이]   # 부모: Item #  - 속성: 이름(name), 가격(price), 무게(weight) #  - 메서드: 판매하기(sale), 버리기(discard) # 자식 1: WearableItem #  - 속성: 착용효과(effect) #  - 메서드: 착용하기(wear) # 자식 2: Usable item #  - 속성: 사용효과(effect) #  - 메서드: 사용하기(use)  class Item:     def __init__(self, name, price, weight, isdropable):         self.name = name         self.price = price         self.weight = weight         self.isdropable = isdropable         print(f\"{self.name} 아이템을 얻었습니다. 아이템 가격은 {self.price}원, 무게는 {self.weight} 입니다.\")     def sell(self):         print(f\"{self.name} 아이템을 {self.price}원에 판매했습니다.\")         self.isdropable = False     def discard(self):         if self.isdropable == True:             print(f\"{self.name} 아이템을 버렸습니다.\")         elif self.isdropable == False:             print(f\"{self.name} 아이템을 버릴 수 없습니다.\")  class WearableItem(Item):     def __init__(self, name, price, weight, isdropable):         super().__init__(name, price, weight, isdropable)      def wear(self):         print(f\"[{self.name}] 아이템을 착용했습니다.\")         self.effect = (\"공격력이 +200 상승했습니다.\", \"속도가 +100 상승했습니다.\")  class UsableItem(Item):     def __init__(self, name, price, weight, isdropable):         super().__init__(name, price, weight, isdropable)      def use(self):         print(f\"[{self.name}] 아이템을 사용했습니다.\")         self.effect = (\"체력이 +100 상승했습니다.\")  sword = WearableItem(\"검\", 10000, 10, True) sword.sell() sword.discard()  medicine = UsableItem(\"medicine\", 1000, 0.5, True) medicine.use()      착용, 사용효과는 아이템마다 상이하므로 변수로 빼주어야한다.          실행결과   (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter8/06-1.실습문제8.1.1.py 검 아이템을 얻었습니다. 아이템 가격은 10000원, 무게는 10 입니다. 검 아이템을 10000원에 판매했습니다. 검 아이템을 버릴 수 없습니다. medicine 아이템을 얻었습니다. 아이템 가격은 1000원, 무게는 0.5 입니다. [medicine] 아이템을 사용했습니다.        [강의 해설]   # 클래스 생성  class Item:     def __init__(self, name, price, weight, isdropable):         self.name = name         self.price = price         self.weight = weight         self.isdropable = isdropable          def sale(self):         print(f\"[{self.name} 판매가격은 [{self.price}]입니다.]\")          def discard(self):         if self.isdropable:             print(f\"[{self.name} 버렸습니다.]\")         else:             print(f\"[{self.name}] 버릴 수 없습니다.\")      class WearbleItem(Item):     def __init__(self, name, price, weight, isdropable, effect):         super().__init__(name, price, weight, isdropable)         self.effect = effect     def wear(self):         print(f\"[{self.name}] 착용했습니다. {self.effect}\")  class UsableItem(Item):     def __init__(self, name, price, weight, isdropable, effect):         super().__init__(name, price, weight, isdropable):         self.effect = effect          def use(self):         print(f\"[{self.name}]. {self.effect}\")  # 인스턴스 생성 sword = WearbleItem(\"이가닌자의검\", 30000, 3.5, True, \"체력 5000 증가, 마력 5000 증가\") sword.wear()          실행 결과   (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter8/06-2.실습문제8.1.1-해설.p y [이가닌자의검] 착용했습니다. 체력 5000 증가, 마력 5000 증가          부모클래스의 메서드도 잘 상속받아왔는지 확인해보자.   # 클래스 생성  class Item:     def __init__(self, name, price, weight, isdropable):         self.name = name         self.price = price         self.weight = weight         self.isdropable = isdropable          def sale(self):         print(f\"[{self.name} 판매가격은 [{self.price}]입니다.]\")          def discard(self):         if self.isdropable:             print(f\"[{self.name} 버렸습니다.]\")         else:             print(f\"[{self.name}] 버릴 수 없습니다.\")      class WearbleItem(Item):     def __init__(self, name, price, weight, isdropable, effect):         super().__init__(name, price, weight, isdropable)         self.effect = effect     def wear(self):         print(f\"[{self.name}] 착용했습니다. {self.effect}\")  class UsableItem(Item):     def __init__(self, name, price, weight, isdropable, effect):         super().__init__(name, price, weight, isdropable)         self.effect = effect          def use(self):         print(f\"[{self.name}]. {self.effect}\")  # 인스턴스 생성 sword = WearbleItem(\"이가닌자의검\", 30000, 3.5, True, \"체력 5000 증가, 마력 5000 증가\") sword.wear() sword.sale() sword.discard()          실행결과   (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter8/06-2.실습문제8.1.1-해설.p y [이가닌자의검] 착용했습니다. 체력 5000 증가, 마력 5000 증가 [이가닌자의검 판매가격은 [30000]입니다.] [이가닌자의검 버렸습니다.]      부모클래스의 메서드인 sale, discard 모두 실행 가능함을 알 수 있다.          UsableItem &amp; 버릴 수 없는 아이템을 생성해보자.   # 클래스 생성  class Item:     def __init__(self, name, price, weight, isdropable):         self.name = name         self.price = price         self.weight = weight         self.isdropable = isdropable          def sale(self):         print(f\"[{self.name} 판매가격은 [{self.price}]입니다.]\")          def discard(self):         if self.isdropable:             print(f\"[{self.name} 버렸습니다.]\")         else:             print(f\"[{self.name}] 버릴 수 없습니다.\")      class WearbleItem(Item):     def __init__(self, name, price, weight, isdropable, effect):         super().__init__(name, price, weight, isdropable)         self.effect = effect     def wear(self):         print(f\"[{self.name}] 착용했습니다. {self.effect}\")  class UsableItem(Item):     def __init__(self, name, price, weight, isdropable, effect):         super().__init__(name, price, weight, isdropable)         self.effect = effect          def use(self):         print(f\"[{self.name}]. {self.effect}\")  # 인스턴스 생성 potion = UsableItem(\"신비한투명물약\", 150000, 0.1, False, \"투명효과 300초 지속\") potion.discard() potion.sale() potion.use()          실행 결과   (myvenv) ➜  python_basic /Users/usr/Documents/pyt hon_basic/myvenv/bin/python /Users/usr/Documents/ python_basic/myvenv/Chapter8/06-2.실습문제8.1.1-해설.p y [신비한투명물약] 버릴 수 없습니다. [신비한투명물약 판매가격은 [150000]입니다.] [신비한투명물약]. 투명효과 300초 지속        이번 포스팅에서는 실습문제를 풀어보았다. 다음 포스팅에서는 모듈에 대해서 알아보도록 하자.       본 포스팅은 패스트캠퍼스 환급 챌린지 참여를 위해 작성되었습니다.          패스트캠퍼스 강의 등록하기: https://bit.ly/3L3avNW       #패스트캠퍼스 #패캠챌린지 #직장인인강 #직장인자기계발 #패스트캠퍼스후기 #캐시백챌린지 #캐시백 #환급챌린지 #한번에끝내는파이썬웹개발초격차패키지Online  ","categories": ["Programming"],
        "tags": ["패스트캠퍼스","패캠챌린지","직장인인강","직장인자기계발","패스트캠퍼스후기","캐시백챌린지","캐시백","환급챌린지","한번에끝내는파이썬웹개발초격차패키지Online"],
        "url": "/programming/Python-Day25/",
        "teaser": null
      },{
        "title": "[Algorithm]그림으로 배우는 알고리즘 제 1장: 알고리즘이란",
        "excerpt":"     최근 파이썬 공부를 하면서 개발자 유투브 영상 등을 틈날때마다 보고있는데 다들 입을모아 알고리즘을 꼭 공부해야한다, 코딩테스트를 위해서 뿐만 아니라 개발자로써 커리어를 쌓기 위해 꼭 필요하다라는 얘기를 들어 매일 조금씩이라도 공부하기 위해 책을 읽으며 기록하려고 한다.       내가 아직 프로그래밍 언어에 대한 이해도가 깊지 않기 때문에, 특정 언어에 얽매이지 않고, 또한 아침 출근 직후 시간에 짬내서 읽기 괜찮은 분량의 책을 찾았는데 이 책이 딱 그 조건에 부합해서 선택해보았다.       앞으로 평일에는 하루에 4페이지 정도 읽고 내용을 간단하게 요약해서 블로그에 올리려고 한다.        제 1장. 알고리즘이란   1. 음식 요리법은 알고리즘      알고리즘(Algorithm); 컴퓨터를 이용해 주어진 과제를 해결하기 위한 처리 절차            과제의 예                    최대 공약수를 구한다           정보의 순서를 정해 나열           원하는 정보 검색                                       현실세게의 다양한 과제의 해결에도 알고리즘의 개념이 사용된다            예: 음식 요리법             치킨카레 만들기 ⇒ 과제       알고리즘                    요리 재료 종류와 양을 정의           시간별로 요리 절차가 적혀있다                                2. 알고리즘은 선인들의 지혜      음식 요리법 중 나쁜 요리법은 사용하는 사람이 적어질 것이고, 음식을 맛있게, 쉽게, 빠르게 만들 수 있는 좋은 요리법은 사용하는 사람이 많아질 것 ⇒ 알고리즘도 마찬가지          알고리즘의 경우에도 보다 효율적으로, 보다 범용적으로, 보다 빠르게 처리를 할 수 있도록 알고리즘을 개선하게 된다.        3. 알고리즘을 이해하는 것은 게임을 잘 하게 되는 것      알고리즘의 학습은 게임의 공략법과 같이 더 나은 프로그램을 만들기 위한 방법            알고리즘은 효율적인 프로그래밍을 위해 반드시 학습해야한다.                4. 알고리즘에는 ‘정당성’과 ‘정지성’이 있어야한다   알고리즘은 다음의 두 가지 조건을 충족해야 한다.       1. 정당성      주어진 과제에 대해 올바른 결과를 반환해야 한다(입력값이 지정된 조건과 일치한다면 ).   정당성을 증명하는 방법: 단정문(Assertion)            알고리즘의 실행순서 중 임의의 위치에서 충족해야하는 조건이 성립하는지(올바르게 동작하는지) 체크       단계별 동작을 확인해 알고리즘 전체의 정당성을 체크할 수 있다.               2. 정지성      어떠한 조건의 입력값이 주어지더라도 정해진 시간 내 반드시 정상적인 종료를 보장   영원히 처리를 반복해 답을 내지 않는 처리(무한 루프)는 알고리즘이 아님   정지성을 증명하는 방법: 반복 처리의 종료조건 체크에 사용되는 변수를 관찰해 정해진 횟수만큼 반복하면 반드시 정지하는 것을 증명       5. 알고리즘에는 다양한 종류가 있다      중요한 알고리즘의 종류            기술 계산       정렬       검색       문자열 패턴 매칭               1. 기술계산      기술계산을 위한 알고리즘   기술계산의 예            유클리드 호제법(최대공약수)       가우스 소거법(방정식)       사다리꼴의 법칙(정적분)       데이크스트라 알고리즘(최적 경로)       에라토스테네스의 체(소수)               2. 정렬(Sort)      1줄로 늘어선 데이터를 작은순서(오름차순) 또는 큰 순서(내림차순)로 정렬하는 알고리즘   정렬의 예            단순 선택 정렬       단순 교환 정렬 (버블 정렬)       단순 삽입 정렬       셸 정렬       병합 정렬       퀵 정렬               3. 검색(Search)      많은 양의 데이터 중 원하는 데이터를 찾는 알고리즘   검색의 예            선형검색 (리니어 서치: Linear Search)       이진 검색 (바이너리 서치: Binary Search)               4. 문자열 패턴 매칭      문자열 중 지정 문자열의 패턴(부분 문자열)과 일치하는 부분을 찾는 알고리즘   문자열 패턴 매칭의 예            단순 문자열 일치       KMP 알고리즘       BM 알고리즘               5. 구조적 프로그래밍      프로그램을 효율적으로 작성, 설계상 오류 최소화하기위한 방법론   구조적 프로그래밍에서 사용하는 프로세스 흐름            순차구조: 작성 순서대로 순차 실행       선택구조: 조건에 따라. 수행할 작업의 흐름 변경       반복구조: 조건이 일치하는동안 일정과정 반복 실행          ","categories": ["Algorithm"],
        "tags": ["알고리즘공부","그림으로배우는알고리즘","비전공자개발자공부","데브옵스엔지니어","파이썬알고리즘","알고리즘책추천"],
        "url": "/algorithm/Algorithm-Book-with-Pic-Day1/",
        "teaser": null
      },{
        "title": "[Python]패스트캠퍼스 캐시백 챌린지 26일차",
        "excerpt":"     오늘도 어제에 이어서 “한 번에 끝내는 파이썬 웹 개발 초격차 패키지 Online” 의 챕터 9-1. 모듈을 듣고 정리해보았다. 참고로 이 포스팅은 공부용으로 강의 내용을 요약한 것으로 자세한 강의 내용은 위 링크를 참조 할 것.        아래는 공부 인증 사진.                  01. 모듈   1. 모듈을 사용하는 이유      프로그램을 기능별로 파일을 나누어 유지보수 등 관리를 편하게 할 수 있기 때문        2. 모듈의 개념      한 개의 완성된 프로그램 파일        3. 파이썬 기본 모듈 사용방법      파이썬의 기본 모듈을 사용해보자.   import 모듈이름 모듈이름.변수 모듈이름.함수()  # 예시 1 import math print(math.pi) print(math.ceil(5.7)) # 올림 함수  # 예시 2: 뒤의 메소드, 변수 이름으로 그대로 작성할 수 있게 하는 방법 from math import pi, ceil print(pi) print(ceil(5.7))        4. 파이썬 외부 모듈 사용방법      파이썬 외부의 모듈을 사용해보자.   pip install 모듈이름  pip install pyautogui        5. 모듈 만들기 실습   1. 내장모듈      내장모듈: 파이썬 설치 시 자동으로 설치되는 모듈   파이썬 내장 모듈을 사용해보자.   # 내장 모듈 # : 파이썬 설치 시 자동으로 설치되는 모듈  from math import pi, ceil as c print(pi) print(c(5.7))      from math import pi를 쓰면 math.pi라고 쓰지 않고 pi만 써도 모듈이 실행된다.   모듈을 간단한 이름으로 변경하여 사용하고 싶은 경우 as 뒤에 사용하고 싶은 이름을 작성하면 적용된다.        2. 외부 모듈      pyautogui 공식 홈페이지 Documentation 페이지에 접속한다.            홈페이지에 나와있는대로 pip install pyautogui 명령어를 터미널 창에 입력한다.           (myvenv) ➜  python_basic pip install pyautogui Collecting pyautogui   Downloading PyAutoGUI-0.9.53.tar.gz (59 kB)      ━━━━━━━━━━━━━ 59.0/59.0 KB 987.7 kB/s eta 0:00:00   Preparing metadata (setup.py) ... done Collecting pymsgbox   Downloading PyMsgBox-1.0.9.tar.gz (18 kB) ... (생략) ...          설치가 완료되면 import 로 pyautogui를 불러온다(별칭 pg로 설정).   # 외부 모듈 # : 다른 사람이 만든 파이썬 파일을 pipfh 설치해서 사용 # pyautogui (공식 홈페이지: https://pyautogui.readthedocs.io/en/latest/) import pyautogui as pg          pyautogui 홈페이지(https://pyautogui.readthedocs.io/en/latest/)에서 Example 중 하나를 실행해보자            **&gt;&gt;&gt;** pyautogui.moveTo(500, 500, duration=2, tween=pyautogui.easeInOutQuad)  *# Use tweening/easing function to move mouse over 2 seconds.*           pg.moveTo(500, 500, duration=2) # 화면의 500 * 500 위치에 마우스를 2초간 이동하라는 명령어      실행결과: 마우스를 건드리지 않아도 자동으로 500*500 위치로 이동한다.   MacOS의 경우 vscode가 컴퓨터 시스템을 제어할 수 있도록 권한을 부여해야 실행이 가능하다.        이번 포스팅에서는 모듈에 대해 알아보았다. 다음 포스팅에서는 파이썬 모듈을 만들어보도록 하자.       본 포스팅은 패스트캠퍼스 환급 챌린지 참여를 위해 작성되었습니다.          패스트캠퍼스 강의 등록하기: https://bit.ly/3L3avNW       #패스트캠퍼스 #패캠챌린지 #직장인인강 #직장인자기계발 #패스트캠퍼스후기 #캐시백챌린지 #캐시백 #환급챌린지 #한번에끝내는파이썬웹개발초격차패키지Online  ","categories": ["Programming"],
        "tags": ["패스트캠퍼스","패캠챌린지","직장인인강","직장인자기계발","패스트캠퍼스후기","캐시백챌린지","캐시백","환급챌린지","한번에끝내는파이썬웹개발초격차패키지Online"],
        "url": "/programming/Python-Day26/",
        "teaser": null
      },{
        "title": "[Algorithm]그림으로 배우는 알고리즘 제 2장: 변수와 배열",
        "excerpt":"     6. 데이터는 다양한 정보이다      알고리즘 = 데이터 + 처리   데이터: 다양한 정보          예시 1: 고기감자 요리            데이터: 고기감자 재료       처리: 요리 방법                  예시 2: 최대공약수 구하기            데이터(필요한 정보)                    최대 공약수를 구하는 2개의 정수 값           구한 최대 공약수(정수 값)                       처리: 최대공약수를 구하는 방법 순서                  예시 3: 정보의 순서 정하기            데이터(필요한 정보)                    정렬할 값이 담긴 열           정렬 값의 개수           정렬된 결과가 담긴 열                       처리: 정보의 순서를 정하는 방법/순서                7. 모든 데이터에는 타입이 있다      데이터 타입: 다양한 정보(데이터)를 그룹화한 것   많이 사용되는 기본 데이터 타입(5가지)            정수 타입(int): 정수(소수점이 없는 값)를 처리하기 위한 데이터 타입       실수 타입(float): 실수(소수점을 포함한 값)를 처리하기 위한 데이터 타입       문자 타입: 문자를 처리하기 위한 데이터 타입       문자열 타입(string): 문자열을 처리하기 위한 데이터 타입       논리 타입(boolean): ‘참’, ‘거짓’을 다루기 위한 데이터 타입               ","categories": ["Algorithm"],
        "tags": ["알고리즘공부","그림으로배우는알고리즘","비전공자개발자공부","데브옵스엔지니어","파이썬알고리즘","알고리즘책추천","데이터타입"],
        "url": "/algorithm/Algorithm-Book-with-Pic-Day2/",
        "teaser": null
      },{
        "title": "[Python]패스트캠퍼스 캐시백 챌린지 27일차",
        "excerpt":"     오늘도 어제에 이어서 “한 번에 끝내는 파이썬 웹 개발 초격차 패키지 Online” 의 챕터 9-2. 모듈 만들기를 듣고 정리해보았다. 참고로 이 포스팅은 공부용으로 강의 내용을 요약한 것으로 자세한 강의 내용은 위 링크를 참조 할 것.        아래는 공부 인증 사진.                  02. 모듈 만들기      pay_module이라는 모듈을 생성해보자.          pay_module.py라는 파일을 생성한 뒤, 아래를 입력 후 저장한다.   # 결제 정보, 관리 모듈 # 변수 version = 2.0  # 함수 def printAuthor():     print(\"스타트코딩\")  # 클래스 class Pay:     def __init__(self, id, price, time):         self.id = id         self.price = price         self.time = time     def get_pay_info(self):         return f\"{self.time} {self.id} {self.price}\"          02.모듈만들기.py라는 파일을 생성한 뒤, pay_module을 import한다.   import pay_module      Import “pay_module” could not be resolved Pylance(reportMissingImports) 라는 에러가 발생한다. 해당 모듈이 root 폴더에 있을 경우에만 찾을 수 있기 때문.          File &gt; Preferences &gt; Settings(MacOS의 경우: VSCode &gt; Preferences &gt; Settings)로 이동 후 붉은 색 네모로 표시한 버튼 클릭             settings.json 파일에서 \"python.analysis.extraPaths\": [\"./myvenv/Chapter9\"], 문구를 넣어준다.   {     \"python.pythonPath\": \"/anaconda3/bin/python\",     \"editor.unicodeHighlight.allowedCharacters\": {         \" \": true     },     \"python.analysis.extraPaths\": [\"./myvenv/Chapter9\"],     \"liveSassCompile.settings.formats\": [         {             \"format\": \"expanded\",             \"extensionName\": \".css\",             \"savePath\": \"/assets/css/\"         }     ],     \"pasteImage.basePath\": \"${currentFileDir}/images/\",     \"pasteImage.prefix\": \"./\",     \"liveServer.settings.donotShowInfoMsg\": true,     \"editor.fontSize\": 15,     \"window.zoomLevel\": 1 }          다시 pay_module 변수 및 함수를 사용하면 에러가 발생하지 않는다.   import pay_module  # 변수 사용 print(pay_module.version)  # 함수 사용 pay_module.printAuthor()          실행결과   (myvenv) ➜  python_basic /Users/usr/Documents/pyth on_basic/myvenv/bin/python /Users/usr/Documents/py thon_basic/myvenv/Chapter9/02.모듈만들기.py 2.0 스타트코딩      코드 실행 후 Chapter 9 디렉토리에 __pycache__ 라는 디렉토리가 자동으로 생성되며, 폴더 하위에는 pay_module.cpython-310.pyc 라는 파일이 생성되는데, 이는 실행속도 향상을 위해 생성된 컴파일된 파이썬 코드.          클래스도 사용할 수 있는지 알아보자.   import pay_module  # 변수 사용 print(pay_module.version)  # 함수 사용 pay_module.printAuthor()  # 클래스 사용 pay_info = pay_module.Pay(\"A102030\", 13000, \"2021-06-13\") print(pay_info.get_pay_info())          실행 결과   (myvenv) ➜  python_basic /Users/usr/Documents/pyth on_basic/myvenv/bin/python /Users/usr/Documents/py thon_basic/myvenv/Chapter9/02.모듈만들기.py 2.0 스타트코딩 2021-06-13 A102030 13000      다시 pay_module.py 파일로 돌아가서, 함수를 추가해준다.   # 해당 파일을 직접 실행했을 때만 실행된다. if __name__ == \"__main__\":     print(\"pay module 실행\")  print(__name__)          출력 결과   (myvenv) ➜  python_basic /Users/usr/Documents/pyth on_basic/myvenv/bin/python /Users/usr/Documents/py thon_basic/myvenv/Chapter9/pay_module.py pay module 실행 __main__          02.모듈만들기.py 에서도 print(pay_module.__name__) 로 되는지 확인해보자.   (myvenv) ➜  python_basic /Users/usr/Documents/pyth on_basic/myvenv/bin/python /Users/usr/Documents/py thon_basic/myvenv/Chapter9/02.모듈만들기.py pay_module      pay_module 이 출력된다. 자기자신의 파일을 직접 실행 했을 때에만 할당된다.        이번 포스팅에서는 모듈을 만들어보았다. 다음 포스팅에서는 패키지에 대해 알아보도록 하자.       본 포스팅은 패스트캠퍼스 환급 챌린지 참여를 위해 작성되었습니다.          패스트캠퍼스 강의 등록하기: https://bit.ly/3L3avNW       #패스트캠퍼스 #패캠챌린지 #직장인인강 #직장인자기계발 #패스트캠퍼스후기 #캐시백챌린지 #캐시백 #환급챌린지 #한번에끝내는파이썬웹개발초격차패키지Online  ","categories": ["Programming"],
        "tags": ["패스트캠퍼스","패캠챌린지","직장인인강","직장인자기계발","패스트캠퍼스후기","캐시백챌린지","캐시백","환급챌린지","한번에끝내는파이썬웹개발초격차패키지Online"],
        "url": "/programming/Python-Day27/",
        "teaser": null
      },{
        "title": "[Kubernetes/CKA]Lightning Lab 1 - kubeadm으로 클러스터 업그레이드",
        "excerpt":"     유데미(Udemy) 에서 구입한 CKA 강의 수강을 완료하고 마지막 연습문제를 풀고 있는데, 챕터별 연습문제와는 다르게 답안이 제공되지 않아 기록을 위해 문제 풀이 과정을 블로그에 올려두려 한다.       참고로 아래의 문제 요건은 편의를 위해 한국어로 번역한 것이고, 강의에서 제공하는 시험 및 실제 시험은 100% 영어로 출제된다.        1. Kubeadm 으로 클러스터 업그레이드 하기   [문제 요건]      쿠버네티스 버전을 현재 1.19 버전에서 1.20.0 로 업그레이드(kubeadm 툴을 이용)   업그레이드는 마스터 노드부터 한번에 한 노드씩 이루어져야 한다.   다운타임(downtime)을 최소화하기위해, 각 노드를 업그레이드 하기 전 gold-nginx 디플로이먼트가 대체 노드로 스케줄링 되어야한다.   controlplane 노드를 먼저 업그레이드   node01 노드를 업그레이드 전 드레인(drain)   gold-nginx 디플로이먼트들의 파드는 controlplane 에 스케줄링 되어야한다.   채점 포인트            클러스터가 업그레이드 되었는가?       ‘gold-nginx’의 파드들이 컨트롤플레인에 스케줄링 되었는가?               [내 풀이]      쿠버네티스 공식문서에서 ‘클러스터 업그레이드’를 검색 &gt; kubeadm 클러스터 업그레이드 공식문서 접속   문제 요건대로 쿠버네티스 1.19버전에서 1.20.0 버전으로 업그레이드 하는 문서로 이동   문서에 나와있는 대로 apt update로 패키지 관리자 업데이트   root@controlplane:~# apt update Hit:1 https://packages.cloud.google.com/apt kubernetes-xenial InRelease          Hit:2 https://download.docker.com/linux/ubuntu bionic InRelease                  Hit:3 http://security.ubuntu.com/ubuntu bionic-security InRelease                Hit:4 http://archive.ubuntu.com/ubuntu bionic InRelease                          Hit:5 http://archive.ubuntu.com/ubuntu bionic-updates InRelease Hit:6 http://archive.ubuntu.com/ubuntu bionic-backports InRelease Reading package lists... Done Building dependency tree        Reading state information... Done 74 packages can be upgraded. Run 'apt list --upgradable' to see them.          apt-cache madison kubeadm으로 kubeadm으로 업그레이드 버전정보를 확인 (문제에서는 1.20.0으로 지정되어있어 생략 가능)   root@controlplane:~# apt-cache madison kubeadm    kubeadm |  1.24.0-00 | http://apt.kubernetes.io kubernetes-xenial/main amd64 Packages    kubeadm |  1.23.6-00 | http://apt.kubernetes.io kubernetes-xenial/main amd64 Packages    kubeadm |  1.23.5-00 | http://apt.kubernetes.io kubernetes-xenial/main amd64 Packages    kubeadm |  1.23.4-00 | http://apt.kubernetes.io kubernetes-xenial/main amd64 Packages    kubeadm |  1.23.3-00 | http://apt.kubernetes.io kubernetes-xenial/main amd64 Packages    kubeadm |  1.23.2-00 | http://apt.kubernetes.io kubernetes-xenial/main amd64 Packages    kubeadm |  1.23.1-00 | http://apt.kubernetes.io kubernetes-xenial/main amd64 Packages    kubeadm |  1.23.0-00 | http://apt.kubernetes.io kubernetes-xenial/main amd64 Packages    kubeadm |  1.22.9-00 | http://apt.kubernetes.io kubernetes-xenial/main amd64 Packages    kubeadm |  1.22.8-00 | http://apt.kubernetes.io kubernetes-xenial/main amd64 Packages    kubeadm |  1.22.7-00 | http://apt.kubernetes.io kubernetes-xenial/main amd64 Packages    kubeadm |  1.22.6-00 | http://apt.kubernetes.io kubernetes-xenial/main amd64 Packages    kubeadm |  1.22.5-00 | http://apt.kubernetes.io kubernetes-xenial/main amd64 Packages    kubeadm |  1.22.4-00 | http://apt.kubernetes.io kubernetes-xenial/main amd64 Packages    kubeadm |  1.22.3-00 | http://apt.kubernetes.io kubernetes-xenial/main amd64 Packages    kubeadm |  1.22.2-00 | http://apt.kubernetes.io kubernetes-xenial/main amd64 Packages    kubeadm |  1.22.1-00 | http://apt.kubernetes.io kubernetes-xenial/main amd64 Packages    kubeadm |  1.22.0-00 | http://apt.kubernetes.io kubernetes-xenial/main amd64 Packages    kubeadm | 1.21.12-00 | http://apt.kubernetes.io kubernetes-xenial/main amd64 Packages    kubeadm | 1.21.11-00 | http://apt.kubernetes.io kubernetes-xenial/main amd64 Packages    kubeadm | 1.21.10-00 | http://apt.kubernetes.io kubernetes-xenial/main amd64 Packages    kubeadm |  1.21.9-00 | http://apt.kubernetes.io kubernetes-xenial/main amd64 Packages    kubeadm |  1.21.8-00 | http://apt.kubernetes.io kubernetes-xenial/main amd64 Packages    kubeadm |  1.21.7-00 | http://apt.kubernetes.io kubernetes-xenial/main amd64 Packages    kubeadm |  1.21.6-00 | http://apt.kubernetes.io kubernetes-xenial/main amd64 Packages    kubeadm |  1.21.5-00 | http://apt.kubernetes.io kubernetes-xenial/main amd64 Packages    kubeadm |  1.21.4-00 | http://apt.kubernetes.io kubernetes-xenial/main amd64 Packages    kubeadm |  1.21.3-00 | http://apt.kubernetes.io kubernetes-xenial/main amd64 Packages    kubeadm |  1.21.2-00 | http://apt.kubernetes.io kubernetes-xenial/main amd64 Packages    kubeadm |  1.21.1-00 | http://apt.kubernetes.io kubernetes-xenial/main amd64 Packages    kubeadm |  1.21.0-00 | http://apt.kubernetes.io kubernetes-xenial/main amd64 Packages    kubeadm | 1.20.15-00 | http://apt.kubernetes.io kubernetes-xenial/main amd64 Packages    kubeadm | 1.20.14-00 | http://apt.kubernetes.io kubernetes-xenial/main amd64 Packages    kubeadm | 1.20.13-00 | http://apt.kubernetes.io kubernetes-xenial/main amd64 Packages    kubeadm | 1.20.12-00 | http://apt.kubernetes.io kubernetes-xenial/main amd64 Packages    kubeadm | 1.20.11-00 | http://apt.kubernetes.io kubernetes-xenial/main amd64 Packages    kubeadm | 1.20.10-00 | http://apt.kubernetes.io kubernetes-xenial/main amd64 Packages    kubeadm |  1.20.9-00 | http://apt.kubernetes.io kubernetes-xenial/main amd64 Packages    kubeadm |  1.20.8-00 | http://apt.kubernetes.io kubernetes-xenial/main amd64 Packages    kubeadm |  1.20.7-00 | http://apt.kubernetes.io kubernetes-xenial/main amd64 Packages (이하 생략)       1. 마스터 노드(컨트롤 플레인) 업그레이드      쿠버네티스 공식문서에서 업그레이드 명령어를 복사하고, kubeadm의 전체 버전명을 정확하게 수정한뒤 붙여넣기 한다(kubeadm=1.20.x-00 ⇒ kubeadm=1.20.0-00).   apt-mark unhold kubeadm &amp;&amp; \\ apt-get update &amp;&amp; apt-get install -y kubeadm=1.20.0-00 &amp;&amp; \\ apt-mark hold kubeadm      Tip: 현재 controlplane에서 작업하고있는지 반드시 확인 후 업그레이드 작업을 시작한다.          다운로드 하려는 버전이 잘 다운로드 되었는지 확인한다.   root@controlplane:~# kubeadm version kubeadm version: &amp;version.Info{Major:\"1\", Minor:\"20\", GitVersion:\"v1.20.0\", GitCommit:\"af46c47ce925f4c4ad5cc8d1fca46c7b77d13b38\", GitTreeState:\"clean\", BuildDate:\"2020-12-08T17:57:36Z\", GoVersion:\"go1.15.5\", Compiler:\"gc\", Platform:\"linux/amd64\"}          업그레이드 계획을 확인한다.   root@controlplane:~# kubeadm upgrade plan [upgrade/config] Making sure the configuration is correct: [upgrade/config] Reading configuration from the cluster... [upgrade/config] FYI: You can look at this config file with 'kubectl -n kube-system get cm kubeadm-config -o yaml' [preflight] Running pre-flight checks. [upgrade] Running cluster health checks [upgrade] Fetching available versions to upgrade to [upgrade/versions] Cluster version: v1.19.0 [upgrade/versions] kubeadm version: v1.20.0 I0515 01:44:55.808176   12296 version.go:251] remote version is much newer: v1.24.0; falling back to: stable-1.20 [upgrade/versions] Latest stable version: v1.20.15 [upgrade/versions] Latest stable version: v1.20.15 [upgrade/versions] Latest version in the v1.19 series: v1.19.16 [upgrade/versions] Latest version in the v1.19 series: v1.19.16  Components that must be upgraded manually after you have upgraded the control plane with 'kubeadm upgrade apply': COMPONENT   CURRENT       AVAILABLE kubelet     2 x v1.19.0   v1.19.16  Upgrade to the latest version in the v1.19 series:  COMPONENT                 CURRENT   AVAILABLE kube-apiserver            v1.19.0   v1.19.16 kube-controller-manager   v1.19.0   v1.19.16 kube-scheduler            v1.19.0   v1.19.16 kube-proxy                v1.19.0   v1.19.16 CoreDNS                   1.7.0     1.7.0 etcd                      3.4.9-1   3.4.9-1  You can now apply the upgrade by executing the following command:          kubeadm upgrade apply v1.19.16  _____________________________________________________________________  Components that must be upgraded manually after you have upgraded the control plane with 'kubeadm upgrade apply': COMPONENT   CURRENT       AVAILABLE kubelet     2 x v1.19.0   v1.20.15  Upgrade to the latest stable version:  COMPONENT                 CURRENT   AVAILABLE kube-apiserver            v1.19.0   v1.20.15 kube-controller-manager   v1.19.0   v1.20.15 kube-scheduler            v1.19.0   v1.20.15 kube-proxy                v1.19.0   v1.20.15 CoreDNS                   1.7.0     1.7.0 etcd                      3.4.9-1   3.4.13-0  You can now apply the upgrade by executing the following command:          kubeadm upgrade apply v1.20.15  Note: Before you can perform this upgrade, you have to update kubeadm to v1.20.15.  _____________________________________________________________________  The table below shows the current state of component configs as understood by this version of kubeadm. Configs that have a \"yes\" mark in the \"MANUAL UPGRADE REQUIRED\" column require manual config upgrade or resetting to kubeadm defaults before a successful upgrade can be performed. The version to manually upgrade to is denoted in the \"PREFERRED VERSION\" column.  API GROUP                 CURRENT VERSION   PREFERRED VERSION   MANUAL UPGRADE REQUIRED kubeproxy.config.k8s.io   v1alpha1          v1alpha1            no kubelet.config.k8s.io     v1beta1           v1beta1             no _____________________________________________________________________          kubeadm 업그레이드 명령어(sudo kubeadm upgrade apply v1.20.x )를 복사한 뒤 올바른 버전(sudo kubeadm upgrade apply v1.20.0)으로 변경한 후 붙여넣기한다.   sudo kubeadm upgrade apply v1.20.0 -y      Tip: 업그레이드 명령어 뒤에 -y옵션을 주어 추가 다운로드에 대해 모두 Yes로 반응하도록 설정하면 편리   Tipe: 업그레이드 완료 후 반드시 아래와 같이 SUCCESS 메시지가 출력되었는지 확인 한다.   [upgrade/successful] SUCCESS! Your cluster was upgraded to \"v1.20.0\". Enjoy!  [upgrade/kubelet] Now that your control plane is upgraded, please proceed with upgrading your kubelets if you haven't already done so.          컨트롤 플레인 노드를 drain(모든 pod를 해당 노드에서 unscheduling)한다.            명령어 복사(kubectl drain &lt;node-to-drain&gt; --ignore-daemonsets) 후 대상 노드를 수정한 뒤 붙여넣기 한다.           root@controlplane:~# kubectl drain controlplane --ignore-daemonsets node/controlplane cordoned WARNING: ignoring DaemonSet-managed Pods: kube-system/kube-proxy-hpgrg, kube-system/weave-net-mp6bh evicting pod admin2406/deploy3-5b6cff588b-5kxdh evicting pod admin2406/deploy1-5799f5869d-jpgfz evicting pod admin2406/deploy2-64885b458-jmvd5 evicting pod kube-system/coredns-74ff55c5b-j7k25 evicting pod admin2406/deploy5-78b86b74f-9rxj7 evicting pod default/gold-nginx-847f89b5b-cfrr8 evicting pod kube-system/coredns-74ff55c5b-58v24 evicting pod admin2406/deploy4-7869d88d64-xdcx9 I0515 01:54:52.043205   22973 request.go:645] Throttling request took 1.005358262s, request: GET:https://controlplane:6443/api/v1/namespaces/kube-system/pods/coredns-74ff55c5b-j7k25 pod/deploy2-64885b458-jmvd5 evicted pod/deploy1-5799f5869d-jpgfz evicted pod/deploy4-7869d88d64-xdcx9 evicted pod/gold-nginx-847f89b5b-cfrr8 evicted pod/coredns-74ff55c5b-58v24 evicted pod/deploy5-78b86b74f-9rxj7 evicted pod/coredns-74ff55c5b-j7k25 evicted pod/deploy3-5b6cff588b-5kxdh evicted node/controlplane evicted          쿠버네티스 공식문서에서 kubelet과 kubectl 업그레이드 명령어를 복사한 뒤, 각각 올바른 버전으로 수정 후 명령어를 실행한다.   apt-mark unhold kubelet kubectl &amp;&amp; \\ apt-get update &amp;&amp; apt-get install -y kubelet=1.20.0-00 kubectl=1.20.0-00 &amp;&amp; \\ apt-mark hold kubelet kubectl          아래 명령어를 사용해 kubelet을 다시 시작한다.   sudo systemctl daemon-reload sudo systemctl restart kubelet          uncordon 명령어(대상 노드이름으로 수정)를 이용해 노드에 파드를 다시 스케줄링한다.   root@controlplane:~# kubectl uncordon controlplane node/controlplane uncordoned       2. 워커 노드 업그레이드      kubectl get nodes 명령어(아래 예시에서는 축약어 사용)로 대상 노드를 확인한다.   root@controlplane:~# k get nodes  NAME           STATUS   ROLES                  AGE    VERSION controlplane   Ready    control-plane,master   104m   v1.20.0 node01         Ready    &lt;none&gt;                 103m   v1.19.0          ssh를 이용해 node01로 접속한다.   root@controlplane:~# ssh node01 Welcome to Ubuntu 18.04.5 LTS (GNU/Linux 5.4.0-1072-gcp x86_64)   * Documentation:  https://help.ubuntu.com  * Management:     https://landscape.canonical.com  * Support:        https://ubuntu.com/advantage This system has been minimized by removing packages and content that are not required on a system that users do not log into.  To restore this content, you can run the 'unminimize' command. root@node01:~#      controlplane에서 node01로 잘 접속되었는지 확인한다.          마스터노드 업그레이드와 같은 요령으로 kubeadm 버전을 업데이트한다.   apt-mark unhold kubeadm &amp;&amp; \\ apt-get update &amp;&amp; apt-get install -y kubeadm=1.20.0-00 &amp;&amp; \\ apt-mark hold kubeadm          kubeadm 업그레이드 명령어를 호출해 로컬 kubelet 구성을 업그레이드한다.   root@node01:~# sudo kubeadm upgrade node [upgrade] Reading configuration from the cluster... [upgrade] FYI: You can look at this config file with 'kubectl -n kube-system get cm kubeadm-config -o yaml' [preflight] Running pre-flight checks [preflight] Skipping prepull. Not a control plane node. [upgrade] Skipping phase. Not a control plane node. [kubelet-start] Writing kubelet configuration to file \"/var/lib/kubelet/config.yaml\" [upgrade] The configuration for this node was successfully updated! [upgrade] Now you should go ahead and upgrade the kubelet package using your package manager.          exit 명령어로 마스터 노드로 돌아간 뒤, 워커노드를 drain한다.   root@node01:~# exit logout Connection to node01 closed. root@controlplane:~# kubectl drain node01 --ignore-daemonsets node/node01 cordoned WARNING: ignoring DaemonSet-managed Pods: kube-system/kube-proxy-rp74d, kube-system/weave-net-n5989 node/node01 drained          ssh로 워커노드(node01)로 재접속해 kubelet, kubectl을 업그레이드한다.   apt-mark unhold kubelet kubectl &amp;&amp; \\ apt-get update &amp;&amp; apt-get install -y kubelet=1.20.0-00 kubectl=1.20.0-00 &amp;&amp; \\ apt-mark hold kubelet kubectl          kubelet을 재시작한다.   root@node01:~# sudo systemctl daemon-reload root@node01:~# sudo systemctl restart kubelet          exit 명령어로 마스터노드로 돌아가 워커노드(node01)에 uncordon 명령어를 실행해준다.   kubectl uncordon node01          kubectl get nodes (예시에서는 축약어 사용)명령어를 사용해 v1.20.0버전으로 업데이트가 잘 수행되었는지 확인한다.   root@controlplane:~# k get nodes  NAME           STATUS   ROLES                  AGE    VERSION controlplane   Ready    control-plane,master   112m   v1.20.0 node01         Ready    &lt;none&gt;                 111m   v1.20.0      문제에서 제시되었던 파드(POD)가 controlplane에 스케줄링 되어있는지 확인한다.   root@controlplane:~# k get pod gold-nginx-847f89b5b-dcdkr -o wide NAME                         READY   STATUS    RESTARTS   AGE   IP          NODE           NOMINATED NODE   READINESS GATES gold-nginx-847f89b5b-dcdkr   1/1     Running   0          17m   10.50.0.3   controlplane   &lt;none&gt;           &lt;none&gt;       [참고 URL]      kubeadm 클러스터 업그레이드: https://kubernetes.io/ko/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/            https://v1-20.docs.kubernetes.io/ko/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/          ","categories": ["DevOps"],
        "tags": ["쿠버네티스","쿠버네티스자격증","유데미강의추천","유데미쿠버네티스","cka연습문제풀이","cka덤프","cka기출문제","cka","kubernetes","kubernetesnetworking","k8s","DevOpsengineer","데브옵스","데브옵스엔지니어"],
        "url": "/devops/Kubernetes-CKA-Lightning-Lab-1/",
        "teaser": null
      },{
        "title": "[Kubernetes/CKA]Lightning Lab 2 - JSON PATH 사용하기",
        "excerpt":"     2. JSON PATH 사용하기   [문제 요건]      다음 포맷에 맞춰 admin2406 네임스페이스의 모든 디플로이먼트를 출력   DEPLOYMENT CONTAINER_IMAGE READY_REPLICAS NAMESPACE&lt;deployment name&gt; &lt;container image used&gt; &lt;ready replica count&gt; &lt;Namespace&gt;.   예시: DEPLOYMENT CONTAINER_IMAGE READY_REPLICAS NAMESPACEdeploy0 nginx:alpine 1 admin2406   데이터들은 deployment name을 기준으로 오름차순으로 정렬   채점 기준: 제시된 작업이 완료되었는가?       [내 풀이]      kubectl get deployment -n admin2406 으로 대상 디플로이먼트들을 확인한다.   root@controlplane:~# k get deployments.apps -n admin2406         NAME      READY   UP-TO-DATE   AVAILABLE   AGE deploy1   1/1     1            1           48m deploy2   1/1     1            1           48m deploy3   1/1     1            1           48m deploy4   1/1     1            1           48m deploy5   1/1     1            1           48m          kubectl get deployment -n admin2406 deploy1 -o json 으로 JSON 파일 구조를 확인한다.   root@controlplane:~# k get deployments.apps -n admin2406 deploy1 -o json {     \"apiVersion\": \"apps/v1\",     \"kind\": \"Deployment\",     \"metadata\": {         \"annotations\": {             \"deployment.kubernetes.io/revision\": \"1\"         },         \"creationTimestamp\": \"2022-05-15T01:28:00Z\",         \"generation\": 1,         \"labels\": {             \"app\": \"deploy1\"         },         \"managedFields\": [             {                 \"apiVersion\": \"apps/v1\",                 \"fieldsType\": \"FieldsV1\",                 \"fieldsV1\": {                     \"f:metadata\": {                         \"f:labels\": {                             \".\": {},                             \"f:app\": {}                         }                     },                     \"f:spec\": {                         \"f:progressDeadlineSeconds\": {},                         \"f:replicas\": {},                         \"f:revisionHistoryLimit\": {},                         \"f:selector\": {},                         \"f:strategy\": {                             \"f:rollingUpdate\": {                                 \".\": {},                                 \"f:maxSurge\": {},                                 \"f:maxUnavailable\": {}                             },                             \"f:type\": {}                         },                         \"f:template\": {                             \"f:metadata\": {                                 \"f:labels\": {                                     \".\": {},                                     \"f:app\": {}                                 }                             },                             \"f:spec\": {                                 \"f:containers\": {                                     \"k:{\\\"name\\\":\\\"nginx\\\"}\": {                                         \".\": {},                                         \"f:image\": {},                                         \"f:imagePullPolicy\": {},                                         \"f:name\": {},                                         \"f:resources\": {},                                         \"f:terminationMessagePath\": {},                                         \"f:terminationMessagePolicy\": {}                                     }                                 },                                 \"f:dnsPolicy\": {},                                 \"f:restartPolicy\": {},                                 \"f:schedulerName\": {},                                 \"f:securityContext\": {},                                 \"f:terminationGracePeriodSeconds\": {}                             }                         }                     }                 },                 \"manager\": \"kubectl-create\",                 \"operation\": \"Update\",                 \"time\": \"2022-05-15T01:28:00Z\"             },             {                 \"apiVersion\": \"apps/v1\",                 \"fieldsType\": \"FieldsV1\",                 \"fieldsV1\": {                     \"f:metadata\": {                         \"f:annotations\": {                             \".\": {},                             \"f:deployment.kubernetes.io/revision\": {}                         }                     },                     \"f:status\": {                         \"f:availableReplicas\": {},                         \"f:conditions\": {                             \".\": {},                             \"k:{\\\"type\\\":\\\"Available\\\"}\": {                                 \".\": {},                                 \"f:lastTransitionTime\": {},                                 \"f:lastUpdateTime\": {},                                 \"f:message\": {},                                 \"f:reason\": {},                                 \"f:status\": {},                                 \"f:type\": {}                             },                             \"k:{\\\"type\\\":\\\"Progressing\\\"}\": {                                 \".\": {},                                 \"f:lastTransitionTime\": {},                                 \"f:lastUpdateTime\": {},                                 \"f:message\": {},                                 \"f:reason\": {},                                 \"f:status\": {},                                 \"f:type\": {}                             }                         },                         \"f:observedGeneration\": {},                         \"f:readyReplicas\": {},                         \"f:replicas\": {},                         \"f:updatedReplicas\": {}                     }                 },                 \"manager\": \"kube-controller-manager\",                 \"operation\": \"Update\",                 \"time\": \"2022-05-15T01:59:02Z\"             }         ],         \"name\": \"deploy1\",         \"namespace\": \"admin2406\",         \"resourceVersion\": \"15003\",         \"uid\": \"09e6b6df-f757-4558-a6a9-1ce8bd1138b7\"     },     \"spec\": {         \"progressDeadlineSeconds\": 600,         \"replicas\": 1,         \"revisionHistoryLimit\": 10,         \"selector\": {             \"matchLabels\": {                 \"app\": \"deploy1\"             }         },         \"strategy\": {             \"rollingUpdate\": {                 \"maxSurge\": \"25%\",                 \"maxUnavailable\": \"25%\"             },             \"type\": \"RollingUpdate\"         },         \"template\": {             \"metadata\": {                 \"creationTimestamp\": null,                 \"labels\": {                     \"app\": \"deploy1\"                 }             },             \"spec\": {                 \"containers\": [                     {                         \"image\": \"nginx\",                         \"imagePullPolicy\": \"Always\",                         \"name\": \"nginx\",                         \"resources\": {},                         \"terminationMessagePath\": \"/dev/termination-log\",                         \"terminationMessagePolicy\": \"File\"                     }                 ],                 \"dnsPolicy\": \"ClusterFirst\",                 \"restartPolicy\": \"Always\",                 \"schedulerName\": \"default-scheduler\",                 \"securityContext\": {},                 \"terminationGracePeriodSeconds\": 30             }         }     },     \"status\": {         \"availableReplicas\": 1,         \"conditions\": [             {                 \"lastTransitionTime\": \"2022-05-15T01:28:00Z\",                 \"lastUpdateTime\": \"2022-05-15T01:28:18Z\",                 \"message\": \"ReplicaSet \\\"deploy1-5799f5869d\\\" has successfully progressed.\",                 \"reason\": \"NewReplicaSetAvailable\",                 \"status\": \"True\",                 \"type\": \"Progressing\"             },             {                 \"lastTransitionTime\": \"2022-05-15T01:59:02Z\",                 \"lastUpdateTime\": \"2022-05-15T01:59:02Z\",                 \"message\": \"Deployment has minimum availability.\",                 \"reason\": \"MinimumReplicasAvailable\",                 \"status\": \"True\",                 \"type\": \"Available\"             }         ],         \"observedGeneration\": 1,         \"readyReplicas\": 1,         \"replicas\": 1,         \"updatedReplicas\": 1     } }          custom-column을 이용한 간단한 쿼리문을 작성한 뒤 잘 작동하는지 테스트해본다.   root@controlplane:~# k get deployments.apps -n admin2406 -o=custom-columns=DEPLOYMENT:.metadata.name DEPLOYMENT deploy1 deploy2 deploy3 deploy4 deploy5          위에서 출력했던 json 포맷을 잘 참고하여 나머지 열에 대한 쿼리도 작성해준다.            Tip: 열과 열을 구분하기 위해서는 , (콤마)를 사용한다.       Tip: 각 항목이 잘 출력되었는지 확인하기 위해 kubectl get deployment 명령어를 잘 활용한다(예: CONTAINER_IMAGE가 잘 출력되었는지 확인 kubectl get deployments -n admin2406)       Tip: 요소가 딕셔너리가 아닌 리스트 형태일 경우(예: containers) 반드시 출력할 리스트 요소를 지정해주어야한다(예: containers ⇒ (X), containers[0] ⇒ (O), containers[*] ⇒ (O)           root@controlplane:~# kubectl get deployments.apps -n admin2406 -o=custom-columns=DEPLOYMENT:.metadata.name,CONTAINER_IMAGE:.spec.template.spec.containers[*].image,READY_REPLICAS:.status.readyReplicas,NAMESPACE:.metadata.namespace DEPLOYMENT   CONTAINER_IMAGE   READY_REPLICAS   NAMESPACE deploy1      nginx             1                admin2406 deploy2      nginx:alpine      1                admin2406 deploy3      nginx:1.16        1                admin2406 deploy4      nginx:1.17        1                admin2406 deploy5      nginx:latest      1                admin2406      --sort-by= 옵션으로 리스트를 문제 요건대로 정렬한다.   root@controlplane:~# kubectl get deployments.apps -n admin2406 -o=custom-columns=DEPLOYMENT:.metadata.name,CONTAINER_IMAGE:.spec.template.spec.containers[*].image,READY_REPLICAS:.status.readyReplicas,NAMESPACE:.metadata.namespace --sort-by=.metadata.name DEPLOYMENT   CONTAINER_IMAGE   READY_REPLICAS   NAMESPACE deploy1      nginx             1                admin2406 deploy2      nginx:alpine      1                admin2406 deploy3      nginx:1.16        1                admin2406 deploy4      nginx:1.17        1                admin2406 deploy5      nginx:latest      1                admin2406          문제 요건대로 /opt/admin2406_data 에 쿼리 결과를 저장한다.   root@controlplane:~# kubectl get deployments.apps -n admin2406 -o=custom-columns=DEPLOYMENT:.metadata.name,CONTAINER_IMAGE:.spec.template.spec.containers[*].image,READY_REPLICAS:.status.readyReplicas,NAMESPACE:.metadata.namespace --sort-by=.metadata.name &gt; /opt/admin2406_data          데이터가 잘 저장되었는지 확인한다.   root@controlplane:~# cat /opt/admin2406_data DEPLOYMENT   CONTAINER_IMAGE   READY_REPLICAS   NAMESPACE deploy1      nginx             1                admin2406 deploy2      nginx:alpine      1                admin2406 deploy3      nginx:1.16        1                admin2406 deploy4      nginx:1.17        1                admin2406 deploy5      nginx:latest      1                admin2406        [참고 URL]      kubectl 치트 시트 - custom-column: https://kubernetes.io/ko/docs/reference/kubectl/cheatsheet/  ","categories": ["DevOps"],
        "tags": ["쿠버네티스","쿠버네티스자격증","유데미강의추천","유데미쿠버네티스","cka연습문제풀이","cka덤프","cka기출문제","cka","kubernetes","kubernetesnetworking","k8s","DevOpsengineer","데브옵스","데브옵스엔지니어"],
        "url": "/devops/Kubernetes-CKA-Lightning-Lab-2/",
        "teaser": null
      },{
        "title": "[Kubernetes/CKA]Lightning Lab 3 - KubeConfig 관련 이슈 트러블 슈팅",
        "excerpt":"     3. KubeConfig 트러블 슈팅   [문제 요건]      /root/CKA 경로에 admin.kubeconfig kubeconfig 파일이 생성되었으나 무언가 잘못되었다. 트러블 슈팅 후 고칠 것   채점 기준            /root/CKA/admin.kubeconfig 고치기                [내 풀이]      kubeconfig 파일을 살펴보자.   root@controlplane:~# cd /root/CKA root@controlplane:~/CKA# ls -al total 16 drwxr-xr-x 2 root root 4096 May 15 04:49 . drwx------ 1 root root 4096 May 15 04:44 .. -rw------- 1 root root 5564 May 15 04:49 admin.kubeconfig root@controlplane:~/CKA# cat admin.kubeconfig  apiVersion: v1 clusters: - cluster:     certificate-authority-data: [encrypted ca]     server: https://controlplane:4380   name: kubernetes contexts: - context:     cluster: kubernetes     user: kubernetes-admin   name: kubernetes-admin@kubernetes current-context: kubernetes-admin@kubernetes kind: Config preferences: {} users: - name: kubernetes-admin   user:     client-certificate-data: [encrypted-certification]     client-key-data: [encrypted-key]       root@controlplane:~/CKA# k config view apiVersion: v1 clusters: - cluster:     certificate-authority-data: DATA+OMITTED     server: https://controlplane:6443   name: kubernetes contexts: - context:     cluster: kubernetes     user: kubernetes-admin   name: kubernetes-admin@kubernetes current-context: kubernetes-admin@kubernetes kind: Config preferences: {} users: - name: kubernetes-admin   user:     client-certificate-data: REDACTED     client-key-data: REDACTED   [참고 URL]  ","categories": ["DevOps"],
        "tags": ["쿠버네티스","쿠버네티스자격증","유데미강의추천","유데미쿠버네티스","cka연습문제풀이","cka덤프","cka기출문제","cka","kubernetes","kubernetesnetworking","k8s","DevOpsengineer","데브옵스","데브옵스엔지니어"],
        "url": "/devops/Kubernetes-CKA-Lightning-Lab-3/",
        "teaser": null
      },{
        "title": "[Kubernetes/CKA]Lightning Lab 4 - 디플로이먼트(Deployment) 생성 및 이미지 업데이트",
        "excerpt":"     4. 디플로이먼트(Deployment) 생성 및 이미지 업데이트   [문제 요건]      default 네임스페이스에 nginx:1.16 이미지를 사용하는 신규 디플로이먼트 nginx-deploy를 생성해야한다. 레플리카 수는 1.   그 뒤, 디플로이먼트의 버전을 롤링 업데이트(Rolling Update)로 1.17로 업데이트   채점기준            이미지: nginx:1.16       작업: 디플로이먼트의 버전을 1.17로 업그레이드                [내 풀이]      쿠버네티스 공식 문서의 kubectl cheatsheet 페이지 참조해 디플로이먼트 리소스 생성   root@controlplane:~# kubectl create deployment nginx-deploy --image=nginx:1.16 --replicas=1 deployment.apps/nginx-deploy created NAME           READY   UP-TO-DATE   AVAILABLE   AGE   CONTAINERS   IMAGES         SELECTOR gold-nginx     1/1     1            1           20m   nginx        nginx:latest   app=gold-nginx nginx-deploy   1/1     1            1           37s   nginx        nginx:1.16     app=nginx-deploy          같은 페이지의 리소스 업데이트 탭을 참조해 이미지 업데이트            Tip: 이미지를 업데이트할 때에는 kubectl set image &lt;리소스종류&gt;/&lt;리소스 이름&gt; &lt;컨테이너명&gt;=&lt;이미지:버전&gt; 명령어를 사용하면 이미지가 롤링업데이트 된다.           root@controlplane:~# kubectl set image deployment/nginx-deploy nginx=nginx:1.17 deployment.apps/nginx-deploy image updated root@controlplane:~# k get deployments.apps -o wide NAME           READY   UP-TO-DATE   AVAILABLE   AGE     CONTAINERS   IMAGES         SELECTOR gold-nginx     1/1     1            1           24m     nginx        nginx:latest   app=gold-nginx nginx-deploy   1/1     1            1           4m10s   nginx        nginx:1.17     app=nginx-deploy        [참고 URL]      이미지 업데이트: https://kubernetes.io/ko/docs/reference/kubectl/cheatsheet/#리소스-업데이트  ","categories": ["DevOps"],
        "tags": ["쿠버네티스","쿠버네티스자격증","유데미강의추천","유데미쿠버네티스","cka연습문제풀이","cka덤프","cka기출문제","cka","kubernetes","kubernetesnetworking","k8s","DevOpsengineer","데브옵스","데브옵스엔지니어"],
        "url": "/devops/Kubernetes-CKA-Lightning-Lab-4/",
        "teaser": null
      },{
        "title": "[Kubernetes/CKA]Lightning Lab 5 - 디플로이먼트 관련 이슈 트러블슈팅",
        "excerpt":"     5. 디플로이먼트 관련 이슈 트러블슈팅   [문제 요건]      alpha 네임스페이스의 alpha-mysql 디플로이먼트(Deployment)가 배포되었으나, 파드(POD)가 동작하지 않는 이슈를 해결해야 한다.   해당 디플로이먼트는 /var/lib/mysql 경로에 마운트 된 alpha-pv 퍼시스턴트 볼륨(Persistent Volume)을 사용해야하며, root 비밀번호를 공백으로 만들기 위해 MYSQL_ALLOW_EMPTY_PASSWORD=1 환경변수를 설정해야한다.   중요: 퍼시스턴트 볼륨을 교체하지 말 것   채점 기준: 트러블 슈팅하여 이슈 해결        [내 풀이]   root@controlplane:~# k describe deployments.apps -n alpha alpha-mysql  Name:                   alpha-mysql Namespace:              alpha CreationTimestamp:      Sun, 15 May 2022 04:44:26 +0000 Labels:                 app=alpha-mysql Annotations:            deployment.kubernetes.io/revision: 1 Selector:               app=alpha-mysql Replicas:               1 desired | 1 updated | 1 total | 0 available | 1 unavailable StrategyType:           RollingUpdate MinReadySeconds:        0 RollingUpdateStrategy:  25% max unavailable, 25% max surge Pod Template:   Labels:  app=alpha-mysql   Containers:    mysql:     Image:      mysql:5.6     Port:       3306/TCP     Host Port:  0/TCP     Environment:       MYSQL_ALLOW_EMPTY_PASSWORD:  1     Mounts:       /var/lib/mysql from mysql-data (rw)   Volumes:    mysql-data:     Type:       PersistentVolumeClaim (a reference to a PersistentVolumeClaim in the same namespace)     ClaimName:  mysql-alpha-pvc     ReadOnly:   false Conditions:   Type           Status  Reason   ----           ------  ------   Available      False   MinimumReplicasUnavailable   Progressing    False   ProgressDeadlineExceeded OldReplicaSets:  &lt;none&gt; NewReplicaSet:   alpha-mysql-6cc9f6bb7c (1/1 replicas created) Events:   Type    Reason             Age   From                   Message   ----    ------             ----  ----                   -------   Normal  ScalingReplicaSet  27m   deployment-controller  Scaled up replica set alpha-mysql-6cc9f6bb7c to 1        [참고 URL]  ","categories": ["DevOps"],
        "tags": ["쿠버네티스","쿠버네티스자격증","유데미강의추천","유데미쿠버네티스","cka연습문제풀이","cka덤프","cka기출문제","cka","kubernetes","kubernetesnetworking","k8s","DevOpsengineer","데브옵스","데브옵스엔지니어"],
        "url": "/devops/Kubernetes-CKA-Lightning-Lab-5/",
        "teaser": null
      },{
        "title": "[Kubernetes/CKA]Lightning Lab 6 - ETCD 백업파일 생성하기",
        "excerpt":"     6. ETCD 백업파일 생성하기   [문제 요건]      ETCD 백업을 controlplane 의 /opt/etcd-backup.db에 생성한다.   채점기준: 트러블 슈팅으로 이슈 해결        [내 풀이]      kubectl describe pod etcd -n kube-system 명령어를 사용해 etcd 파드 정보를 확인한다.   root@controlplane:/opt# k describe pod etcd -n kube-system  Name:                 etcd-controlplane Namespace:            kube-system Priority:             2000001000 Priority Class Name:  system-node-critical Node:                 controlplane/10.4.57.3 Start Time:           Sun, 15 May 2022 04:14:46 +0000 Labels:               component=etcd                       tier=control-plane Annotations:          kubeadm.kubernetes.io/etcd.advertise-client-urls: https://10.4.57.3:2379                       kubernetes.io/config.hash: 722e84fe51d881b86833db89a526d572                       kubernetes.io/config.mirror: 722e84fe51d881b86833db89a526d572                       kubernetes.io/config.seen: 2022-05-15T04:14:44.965341411Z                       kubernetes.io/config.source: file Status:               Running IP:                   10.4.57.3 IPs:   IP:           10.4.57.3 Controlled By:  Node/controlplane Containers:   etcd:     Container ID:  docker://08595528da5102b7b25f6498f97630b6b0bcef22c4f5e2ad93156112cffa63dd     Image:         k8s.gcr.io/etcd:3.4.9-1     Image ID:      docker-pullable://k8s.gcr.io/etcd@sha256:735f090b15d5efc576da1602d8c678bf39a7605c0718ed915daec8f2297db2ff     Port:          &lt;none&gt;     Host Port:     &lt;none&gt;     Command:       etcd       --advertise-client-urls=https://10.4.57.3:2379       --cert-file=/etc/kubernetes/pki/etcd/server.crt       --client-cert-auth=true       --data-dir=/var/lib/etcd       --initial-advertise-peer-urls=https://10.4.57.3:2380       --initial-cluster=controlplane=https://10.4.57.3:2380       --key-file=/etc/kubernetes/pki/etcd/server.key       --listen-client-urls=https://127.0.0.1:2379,https://10.4.57.3:2379       --listen-metrics-urls=http://127.0.0.1:2381       --listen-peer-urls=https://10.4.57.3:2380       --name=controlplane       --peer-cert-file=/etc/kubernetes/pki/etcd/peer.crt       --peer-client-cert-auth=true       --peer-key-file=/etc/kubernetes/pki/etcd/peer.key       --peer-trusted-ca-file=/etc/kubernetes/pki/etcd/ca.crt       --snapshot-count=10000       --trusted-ca-file=/etc/kubernetes/pki/etcd/ca.crt     State:          Running       Started:      Sun, 15 May 2022 04:14:31 +0000     Ready:          True     Restart Count:  0     Liveness:       http-get http://127.0.0.1:2381/health delay=10s timeout=15s period=10s #success=1 #failure=8     Startup:        http-get http://127.0.0.1:2381/health delay=10s timeout=15s period=10s #success=1 #failure=24     Environment:    &lt;none&gt;     Mounts:       /etc/kubernetes/pki/etcd from etcd-certs (rw)       /var/lib/etcd from etcd-data (rw) Conditions:   Type              Status   Initialized       True    Ready             True    ContainersReady   True    PodScheduled      True  Volumes:   etcd-certs:     Type:          HostPath (bare host directory volume)     Path:          /etc/kubernetes/pki/etcd     HostPathType:  DirectoryOrCreate   etcd-data:     Type:          HostPath (bare host directory volume)     Path:          /var/lib/etcd     HostPathType:  DirectoryOrCreate QoS Class:         BestEffort Node-Selectors:    &lt;none&gt; Tolerations:       :NoExecuteop=Exists Events:            &lt;none&gt;      위의 etcd 파드(POD)의 정보를 참조하여 백업 명령어를 작성한다.   root@controlplane:/opt# ETCDCTL_API=3 etcdctl --endpoints=https://127.0.0.1:2379 \\ &gt;   --cacert=/etc/kubernetes/pki/etcd/ca.crt --cert=/etc/kubernetes/pki/etcd/server.crt --key=/etc/kubernetes/pki/etcd/server.key \\ &gt;   snapshot save /opt/etcd-backup.db Snapshot saved at /opt/etcd-backup.db      --endpoints : listen-client-urls 참조   --cacert : trusted-ca-file 참조   --cert : cert-file 참조   --key : key-file 참조          백업파일이 잘 생성되었는지 확인한다.   root@controlplane:/opt# ETCDCTL_API=3 etcdctl --write-out=table snapshot status /opt/etcd-backup.db +----------+----------+------------+------------+ |   HASH   | REVISION | TOTAL KEYS | TOTAL SIZE | +----------+----------+------------+------------+ | aca19208 |    10592 |       1317 |     2.8 MB | +----------+----------+------------+------------+   [참고 URL]      etcd backup: https://kubernetes.io/docs/tasks/administer-cluster/configure-upgrade-etcd/#backing-up-an-etcd-cluster  ","categories": ["DevOps"],
        "tags": ["쿠버네티스","쿠버네티스자격증","유데미강의추천","유데미쿠버네티스","cka연습문제풀이","cka덤프","cka기출문제","cka","kubernetes","kubernetesnetworking","k8s","DevOpsengineer","데브옵스","데브옵스엔지니어"],
        "url": "/devops/Kubernetes-CKA-Lightning-Lab-6/",
        "teaser": null
      },{
        "title": "[Kubernetes/CKA]Lightning Lab 7 - Secret이 마운트된 Pod 생성하기",
        "excerpt":"     7. Secret이 마운트된 Pod 생성하기   [문제 요건]      admin1401 네임스페이스에 busybox이미지를 가지고 secret-1401라는 파드를 생성   파드 내 컨테이너명은 반드시 secret-admin 여야함   4800초동안 sleep하는 명령어 실행   컨테이너에 마운트 되는 시크릿 볼륨은 read-only 여야 하며,   컨테이너는 /etc/secret-volume 경로에 시크릿 볼륨을 마운트해야한다.   시크릿 이름은 dotfile-secret   채점 기준: 파드가 올바르게 생성되었는가?        [내 풀이]      kubectl 명령어로 pod의 yaml 파일을 생성해준다.            Tip:  --dry-run 옵션을 사용해 파드를 생성하지 않고 매니페스트 파일만 생성한다.           root@controlplane:~# k run -n admin1401 --image=busybox secret-1401 --dry-run=client -o yaml --command -- sleep 4800 &gt; pod.yaml          생성한 매니페스트 파일(yaml)을 편집한다.   root@controlplane:~# vi pod.yaml   apiVersion: v1 kind: Pod metadata:   creationTimestamp: null   labels:     run: secret-1401   name: secret-1401   namespace: admin1401 spec:   containers:   - command:     - sleep     - \"4800\"     image: busybox     name: secret-1401   dnsPolicy: ClusterFirst   restartPolicy: Always          문제 요건에 맞게 pod의 yaml 파일을 수정한다.   apiVersion: v1 kind: Pod metadata:   creationTimestamp: null   labels:     run: secret-1401   name: secret-1401   namespace: admin1401 spec:   containers:   - command:     - sleep     - \"4800\"     image: busybox     name: secret-admin     volumeMounts:     - name: secret-volume       readOnly: true       mountPath: \"/etc/secret-volume\"   dnsPolicy: ClusterFirst   restartPolicy: Always   volumes:   - name: secret-volume     secret:       secretName: dotfile-secret      파드의 컨테이너명을 secret-admin 으로 수정한다.   쿠버네티스 공식 문서의 Secret 문서를 참고하여 Secret Volume과 VolumeMounts 구문을 추가한다.          kubectl create -f &lt;yaml파일명&gt; 명령어를 사용해 파드를 생성한 뒤, 잘 생성되었는지 확인한다.   root@controlplane:~# kubectl create -f pod.yaml  pod/secret-1401 created root@controlplane:~# kubectl get pods -n admin1401 NAME          READY   STATUS    RESTARTS   AGE secret-1401   1/1     Running   0          12s       [참고 URL]      kubectl reference: https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#run   Secret: https://kubernetes.io/ko/docs/concepts/configuration/secret/#사용-사례-ssh-키가-있는-파드  ","categories": ["DevOps"],
        "tags": ["쿠버네티스","쿠버네티스자격증","유데미강의추천","유데미쿠버네티스","cka연습문제풀이","cka덤프","cka기출문제","cka","kubernetes","kubernetesnetworking","k8s","DevOpsengineer","데브옵스","데브옵스엔지니어"],
        "url": "/devops/Kubernetes-CKA-Lightning-Lab-7/",
        "teaser": null
      },{
        "title": "[Python]패스트캠퍼스 캐시백 챌린지 28일차",
        "excerpt":"     오늘도 어제에 이어서 “한 번에 끝내는 파이썬 웹 개발 초격차 패키지 Online” 의 챕터 9-3. 패키지를 듣고 정리해보았다. 참고로 이 포스팅은 공부용으로 강의 내용을 요약한 것으로 자세한 강의 내용은 위 링크를 참조 할 것.        아래는 공부 인증 사진.                  03. 패키지   1. 패키지의 개념      관련있는 모듈을 하나의 폴더로 구성해 놓은 것.        2. 패키지 만들고, 사용하기      디렉토리(=폴더) 구조   - startcoding /      unit /         __init__.py         character.py         item.py         monster.py     main.py          VScode로 이동해 Chapter9 폴더 밑에 startcoding, startcoding 하위에 unit 폴더를 생성 및 위 디렉토리 구조대로 파일생성            Tip: unit 폴더 생성 시 startcoding/unit 이라는 컴팩트폴더 형식으로 폴더가 표시되는데, 이를 해제하려면 File &gt; Preference &gt; Settings (MacOS의 경우 Code &gt; Preference &gt; Settings ) 에 들어가 compact 라고 검색한 뒤, Explorer: Compact Folders 라는 항목의 체크박스를 해제해주면 폴더가 트리형식으로 표시된다.                       디렉토리 및 파일 생성이 완료되면 이런 형태가 된다.                     unit 패키지 안의 모듈부터 작성해보자. 먼저 character.py를 아주 간단하게 Print 문으로만 구성해 작성해보자.   def test():     print(\"this is a character module\")          item, monster 모듈도 동일 요령으로 작성하자.   def test():     print(\"this is a item module\")   def test():     print(\"this is a monster module\")          이렇게 작성한 위 모듈들을 main.py에서 불러오자.   # 1. import 패키지.모듈 import unit.character          “unit.character” is not accessed: Import “unit.character” could not be resolved Pylance(reportMissingImports) 라는 에러메시지가 발생            startcoding이라는 새로운 폴더를 만들었기 때문                File &gt; Preference &gt; Settings (MacOS의 경우 Code &gt; Preference &gt; Settings ) 에서 아래 빨간색 박스로 표시한 아이콘을 클릭                                             settings.json 파일에서 “python.analysis.extraPaths” 에 startcoding으로 향하는 경로를 추가한다.             {       \"python.pythonPath\": \"/anaconda3/bin/python\",       \"editor.unicodeHighlight.allowedCharacters\": {           \" \": true       },       \"python.analysis.extraPaths\": [\"./myvenv/Chapter9\", \"./myvenv/Chapter9/startcoding\"],       \"liveSassCompile.settings.formats\": [           {               \"format\": \"expanded\",               \"extensionName\": \".css\",               \"savePath\": \"/assets/css/\"           }       ],       \"pasteImage.basePath\": \"${currentFileDir}/images/\",       \"pasteImage.prefix\": \"./\",       \"liveServer.settings.donotShowInfoMsg\": true,       \"editor.fontSize\": 15,       \"window.zoomLevel\": 1,       \"explorer.compactFolders\": false   }                1. import 패키지.모듈 방식      이어서 main.py 에서 import 를 이용해 character 모듈을 호출해보자.   # 1. import 패키지.모듈 import unit.character unit.character.test()          실행 결과: unit.character의 test 함수가 잘 실행되는 것을 알 수 있다.   (myvenv) ➜  python_basic /Users/usr/Documents/pyth on_basic/myvenv/bin/python /Users/usr/Documents/py thon_basic/myvenv/Chapter9/startcoding/main.py this is a character module        2. from 패키지 import 모듈 방식 (사용빈도 높음)      이번에는 from 패키지 import 모듈 구문을 이용해 모듈을 불러와보자.   # 2. from 패키지 import 모듈 from unit import item item.test()          실행 결과   (myvenv) ➜  python_basic /Users/usr/Documents/pyth on_basic/myvenv/bin/python /Users/usr/Documents/py thon_basic/myvenv/Chapter9/startcoding/main.py this is a item module        3. from 패키지 import * 방식      from 패키지 import * 방식을 이용해 패키지의 모든 모듈을 불러올 수 있다.   # 3. import 패키지 import * # : 패키지 안의 모든 모듈 가져오기 from unit import * character.test()      * (Asterisk): ‘모든’ 이라는 뜻   character 모듈을 불러올 수 없음 ⇒ __init__ 파일을 수정해야한다.          init 모듈을 수정해주자.   from . import character, item, monster      . : 현재 위치를 뜻한다.   현재위치의 character, item, monster 모듈을 init 모듈에 import 한다 라는 뜻.          다시 main.py 로 돌아가 character, item, monster 모듈의 함수들을 불러와보자.   # 3. import 패키지 import * # : 패키지 안의 모든 모듈 가져오기 from unit import * character.test() item.test() monster.test()          실행결과: 각 모듈의 test 함수가 잘 실행됨을 알 수 있다.   (myvenv) ➜  python_basic /Users/usr/Documents/pyth on_basic/myvenv/bin/python /Users/usr/Documents/py thon_basic/myvenv/Chapter9/startcoding/main.py this is a character module this is a item module this is a monster module        4. import 패키지 방식      import 패키지 방식을 사용해 패키지 전체를 불러와 사용할 수 있다.   참고: 이 방식도 3 방식의 init 모듈 수정 절차가 필요하다.   main.py 에서 import unit 으로 unit 패키지 전체를 불러온 뒤, 각 모듈의 함수를 호출한다.   # 4. import 패키지 # : 패키지 자체를 import  import unit unit.character.test() unit.item.test() unit.monster.test()          실행결과: 각 모듈의 함수가 잘 동작함을 알 수 있다.   (myvenv) ➜  python_basic /Users/usr/Documents/pyth on_basic/myvenv/bin/python /Users/usr/Documents/py thon_basic/myvenv/Chapter9/startcoding/main.py this is a character module this is a item module this is a monster module       이번 포스팅에서는 패키지에 대해 알아보았다. 다음 포스팅에서는 파일입출력 기본에 대해 알아보도록 하자.       본 포스팅은 패스트캠퍼스 환급 챌린지 참여를 위해 작성되었습니다.          패스트캠퍼스 강의 등록하기: https://bit.ly/3L3avNW       #패스트캠퍼스 #패캠챌린지 #직장인인강 #직장인자기계발 #패스트캠퍼스후기 #캐시백챌린지 #캐시백 #환급챌린지 #한번에끝내는파이썬웹개발초격차패키지Online  ","categories": ["Programming"],
        "tags": ["패스트캠퍼스","패캠챌린지","직장인인강","직장인자기계발","패스트캠퍼스후기","캐시백챌린지","캐시백","환급챌린지","한번에끝내는파이썬웹개발초격차패키지Online"],
        "url": "/programming/Python-Day28/",
        "teaser": null
      },{
        "title": "[Python]패스트캠퍼스 캐시백 챌린지 29일차",
        "excerpt":"     오늘도 어제에 이어서 “한 번에 끝내는 파이썬 웹 개발 초격차 패키지 Online” 의 챕터 10-1. 파일입출력 기본을 듣고 정리해보았다. 참고로 이 포스팅은 공부용으로 강의 내용을 요약한 것으로 자세한 강의 내용은 위 링크를 참조 할 것.        아래는 공부 인증 사진.                  01. 파일입출력 기본   1. 파일 입출력을 사용하는 이유      앞선 수업에서 사용자로부터 데이터를 입력 받을 때 사용하는 함수: input()   데이터를 표시: print()   프로그램 외부파일에 있는 데이터를 가져와야하거나 프로그램에서 만든 유의미한 데이터를 저장해야할 때에는 ⇒ 파일형태로 데이터를 읽고 저장해야함       [파일 입출력을 사용하는 이유]      파일로부터 데이터를 읽어와서 프로그램에 사용하기 위해   프로그램에서 만든 데이터를 파일 형태로 저장하기 위해        2. 파일 열기 모드      w: 쓰기 모드 (write)   a: 추가 모드 (append)   r: 읽기 모드 (read)       [파일 입출력을 할 때 필요한 과정: 파일 열기, 작업, 닫기]          1. 파일 쓰기   파일객체 = open(\"파일이름\", \"파일모드\") 파일객체.write(데이터) 파일객체.close()  # 예시 1 file = open(\"data.txt\", \"w\") file.write(\"1.스타트코딩과 함께 파이썬 공부\") file.close()      open 함수: data.txt 파일을 객체 형태로 가져와 file이라는 변수에 담아준다.   write 함수: 데이터를 파일객체에 쓴다.   close 함수: 파일을 닫아준다.       2. 파일 추가   파일객체 = open(\"파일이름\", \"파일모드\") 파일객체.write(데이터) 파일객체.close()  # 예시 1 file = open(\"data.txt\", \"a\") file.write(\"2.비전공자도 정말 쉽게 배울 수 있습니다.\") file.close()      open 함수: data.txt 파일을 객체 형태로 가져와 file이라는 변수에 담아준다.   write 함수: 데이터를 파일객체에 쓴다.   close 함수: 파일을 닫아준다.   w 모드 &amp; a 모드 차이점            w 모드 : 덮어쓰기(기존에 데이터가 있더라도 새로 데이터를 덮어쓴다)       a 모드 : 이어쓰기               3. 파일 읽기   파일객체 = open(\"파일이름\", \"파일모드\") 변수 = 파일객체.read(데이터) 파일객체.close()  # 예시 1 file = open(\"data.txt\", \"r\") data = file.read() file.close()      open 함수: data.txt 파일을 객체 형태로 가져와 file이라는 변수에 담아준다.   read 함수: data.txt 파일에 있는 데이터 전체를 가져온다.   close 함수: 파일을 닫아준다.        3. 실습   1. 파일 쓰기   # 1. 파일 쓰기 file = open(\"data.txt\", \"w\") file.write(\"1. 스타트코딩과 함께 파이썬 공부\") file.close()          파일을 실행하면 PYTHON_BASIC 폴더에 data.txt 가 생성된다.        경로를 설정하지 않았기 때문에 root 디렉터리 바로 아래에 파일이 생성된 것.                     data.txt 파일을 open 할 때 경로를 지정해주면 된다.   # 1. 파일 쓰기 file = open(\"./myvenv/Chapter10/data.txt\", \"w\") file.write(\"1. 스타트코딩과 함께 파이썬 공부\") file.close()               기존에 생성한 data.txt 파일을 삭제한 뒤, 다시 파일입출력.py 파일을 실행해주면 Chapter10 하위에 data.txt 파일이 생성된다.                     만약 생성된 data.txt 파일이 깨질 경우, encoding 방법을 설정해주면 깨지지 않는다.   # 1. 파일 쓰기 file = open(\"./myvenv/Chapter10/data.txt\", \"w\", encoding=\"utf-8\") file.write(\"1. 스타트코딩과 함께 파이썬 공부\") file.close()       2. 파일 추가   # 2. 파일 추가 file = open(\"./myvenv/Chapter10/data.txt\", \"a\", encoding=\"utf-8\") file.write(\"2. 비전공자도 정말 쉽게 배울 수 있습니다.\") file.close()          실행 결과   1. 스타트코딩과 함께 파이썬 공부2. 비전공자도 정말 쉽게 배울 수 있습니다.          1 과 2 사이에 행을 바꾸고 싶은 경우 문장 시작하는 부분에 \\n을 입력해주면 된다.   # 2. 파일 추가 file = open(\"./myvenv/Chapter10/data.txt\", \"a\", encoding=\"utf-8\") file.write(\"\\n2. 비전공자도 정말 쉽게 배울 수 있습니다.\") file.close()          실행 결과   1. 스타트코딩과 함께 파이썬 공부 2. 비전공자도 정말 쉽게 배울 수 있습니다.       3. 파일 읽기      파일 전체 읽기   # 3. 파일 읽기 file = open(\"./myvenv/Chapter10/data.txt\", \"r\", encoding=\"utf-8\")  # 3.1. 파일 전체 읽기 data = file.read() print(data) file.close()          실행 결과   (myvenv) ➜  python_basic /Users/usr/Documents/pyth on_basic/myvenv/bin/python /Users/usr/Documents/py thon_basic/myvenv/Chapter10/01.파일입출력.py 1. 스타트코딩과 함께 파이썬 공부 2. 비전공자도 정말 쉽게 배울 수 있습니다.          파일 한 줄 읽기   # 3. 파일 읽기 file = open(\"./myvenv/Chapter10/data.txt\", \"r\", encoding=\"utf-8\")  # 3.2. 파일 한 줄 읽기 while True:     data = file.readline()     print(data)     if data == \"\":         break      파일의 끝이 어디인지를 알 수 없기 때문에 파일의 끝을 알려주는 함수가 필요   데이터가 공백이었을 경우 무한반복문을 빠져나오도록 작성          실행결과   (myvenv) ➜  python_basic /Users/usr/Documents/pyth on_basic/myvenv/bin/python /Users/usr/Documents/py thon_basic/myvenv/Chapter10/01.파일입출력.py 1. 스타트코딩과 함께 파이썬 공부  2. 비전공자도 정말 쉽게 배울 수 있습니다.      print 문이 줄바꿈을 실행하기 때문에 줄이 띄어져 출력(없애려면 print 문에 end=””를 추가하자)        이번 포스팅에서는 파일입출력 기본에 대해 알아보았다. 다음 포스팅에서는 csv파일 입출력에 대해 알아보도록 하자.       본 포스팅은 패스트캠퍼스 환급 챌린지 참여를 위해 작성되었습니다.          패스트캠퍼스 강의 등록하기: https://bit.ly/3L3avNW       #패스트캠퍼스 #패캠챌린지 #직장인인강 #직장인자기계발 #패스트캠퍼스후기 #캐시백챌린지 #캐시백 #환급챌린지 #한번에끝내는파이썬웹개발초격차패키지Online  ","categories": ["Programming"],
        "tags": ["패스트캠퍼스","패캠챌린지","직장인인강","직장인자기계발","패스트캠퍼스후기","캐시백챌린지","캐시백","환급챌린지","한번에끝내는파이썬웹개발초격차패키지Online"],
        "url": "/programming/Python-Day29/",
        "teaser": null
      },{
        "title": "[Python]패스트캠퍼스 캐시백 챌린지 30일차",
        "excerpt":"     오늘도 어제에 이어서 “한 번에 끝내는 파이썬 웹 개발 초격차 패키지 Online” 의 챕터 10-2. csv파일입출력을 듣고 정리해보았다. 참고로 이 포스팅은 공부용으로 강의 내용을 요약한 것으로 자세한 강의 내용은 위 링크를 참조 할 것.        아래는 공부 인증 사진.                  1. 파일 입출력 기본(이어서)   1. pickle 모듈      파일에 파이썬 객체를 저장한다.   import pickle data = {     \"목표1\": \"매일 팔굽혀펴기 100회\",     \"목표2\": \"매일 코딩 공부 1시간\" }  file = open(\"data.pickle\", \"wb\") pickle.dump(data, file) file.close()      wb: write binary 모드. 컴퓨터가 바로 읽을 수 있는 데이터 형식   “data.pickle” 의 pickle은 .p 혹은 .pc 로 변경해도 된다.          파일로부터 파이썬 객체를 읽어보자.   import pickle file = open(\"data.pickle\", \"rb\") data = pickle.load(file) print(data)  file.close()      rb: read binary 모드.   data = pickle.load(file): 파일에서 데이터가 하나하나 로드되어 data 객체에 저장        2. With 구문      With 구문을 사용해보자.   # with 구문 사용 X file = open(\"data.txt\", \"r\") data = file.read() file.close()  # with 구문 사용 O with open(\"data.txt\", \"r\") as file:     data = file.read()      with 구문을 사용하는 이유: file.close 를 매번 사용하기 번거롭기 때문.        3. 실습      파이썬 객체를 pickle로 저장해보자.   # 1. 파이썬 객체를 pickle로 저장하기 import pickle  data = {     \"목표1\" : \"매일 팔굽혀 펴기 100회\",     \"목표2\" : \"매일 코딩 공부 1시간\" }  file = open(\"./myvenv/Chapter10/data.pickle\", \"wb\") pickle.dump(data, file) file.close()      코드를 실행하면 Chapter10 폴더 하위에 data.pickle 이라는 파일이 생성된다(바이너리 파일이므로 열어서 내용을 읽을 수 없음)          pickle 파일을 파이썬으로 가져와보자.   # 2. pickle 파일 파이썬으로 가져오기 file = open(\"./myvenv/Chapter10/data.pickle\", \"rb\") data = pickle.load(file) print(data) file.close()          실행 결과   (myvenv) ➜  python_basic /Users/usr/Documents/pyth on_basic/myvenv/bin/python /Users/usr/Documents/py thon_basic/myvenv/Chapter10/02.pickle.py {'목표1': '매일 팔굽혀 펴기 100회', '목표2': '매일 코딩 공부 1시간'}          with 구문도 사용해보자.   # with 구문을 사용하면 자동으로 file.close 해준다. with open(\"./myvenv/Chapter10/data.txt\", \"r\", encoding=\"utf-8\") as file:     data = file.read()     print(data)          실행 결과   (myvenv) ➜  python_basic /Users/usr/Documents/pyth on_basic/myvenv/bin/python /Users/usr/Documents/py thon_basic/myvenv/Chapter10/03.with구문.py 1. 스타트코딩과 함께 파이썬 공부 2. 비전공자도 정말 쉽게 배울 수 있습니다.        2. csv 파일 입출력   1. csv 파일이란?      CSV: comma-seperated values의 약어. 데이터가 콤마로 구분된 텍스트 파일 형식        예: student.csv       이름, 반, 번호       재석, 1, 20       홍철, 3, 8       형돈, 5, 32       ⇒ 테이블 형태의 데이터        2. csv 파일 입출력 사용방법   1. csv 파일 쓰기   # csv파일 쓰기 import csv  data = [     [\"이름\", \"반\", \"번호\"],     [\"재석\", 1, 20],     [\"홍철\", 3, 8],     [\"형돈\", 5, 32] ]  file = open(\"student.csv\", \"w\") writer = csv.writer(file) for d in data:     writer.writerow(d) file.close()        2. csv 파일 읽기   import csv  file = open(\"student.csv\", \"r\") reader = csv.reader(file) for d in reader:     print(d) file.close()        3. 실습   from asyncore import write import csv from dataclasses import dataclass # 내장 모듈  data = [     [\"이름\", \"반\", \"번호\"],     [\"재석\", 1, 20],     [\"홍철\", 3, 8],     [\"형돈\", 5, 32] ]  # Window의 경우 newline=\"\" (자동 띄어쓰기 방지), encoding=\"utf-8-sig\" (글씨 깨짐 방지) 삽입: open(\"student.csv\", \"w\", newline=\"\", encoding=\"\") file = open(\"./myvenv/Chapter10/student.csv\", \"w\") writer = csv.writer(file)  for d in data:     writer.writerow(d)  file.close()      for d in data: data의 데이터들을 하나씩 갖고와 d 에 저장한다.          csv파일 읽기 파일을 생성해 아래 코드를 작성한다.   import csv  file = open(\"./myvenv/Chapter10/student.csv\", \"r\") reader = csv.reader(file) for data in reader:     print(data) file.close()          실행결과   (myvenv) ➜  python_basic /Users/usr/Documents/pyth on_basic/myvenv/bin/python /Users/usr/Documents/py thon_basic/myvenv/Chapter10/05.csv파일읽기.py ['이름', '반', '번호'] ['재석', '1', '20'] ['홍철', '3', '8'] ['형돈', '5', '32']        이번 포스팅에서는 csv파일 입출력에 대해 알아보았다. 다음 포스팅에서는 파일입출력 실습문제를 풀어보도록 하자.       본 포스팅은 패스트캠퍼스 환급 챌린지 참여를 위해 작성되었습니다.          패스트캠퍼스 강의 등록하기: https://bit.ly/3L3avNW       #패스트캠퍼스 #패캠챌린지 #직장인인강 #직장인자기계발 #패스트캠퍼스후기 #캐시백챌린지 #캐시백 #환급챌린지 #한번에끝내는파이썬웹개발초격차패키지Online  ","categories": ["Programming"],
        "tags": ["패스트캠퍼스","패캠챌린지","직장인인강","직장인자기계발","패스트캠퍼스후기","캐시백챌린지","캐시백","환급챌린지","한번에끝내는파이썬웹개발초격차패키지Online"],
        "url": "/programming/Python-Day30/",
        "teaser": null
      }]
